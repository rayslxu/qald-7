// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//         Silei Xu <silei@cs.stanford.edu>

import * as $runtime from "../sentence-generator/runtime";
import type $SentenceGenerator from "../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../sentence-generator/types";
import * as $I18n from "../i18n/index";
import assert from 'assert';
import { Ast, Type } from 'thingtalk';
import * as C from './ast_manip';
import ThingpediaLoader from './load-thingpedia';
export const table_join_replace_placeholder : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "table_join_replace_placeholder";
export const action_replace_param_with_table : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "action_replace_param_with_table";
export const action_replace_param_with_stream : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "action_replace_param_with_stream";
export const the_out_param_Any : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot> = "the_out_param_Any";
export const the_out_param_pair : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "the_out_param_pair";
export const the_out_param_triple : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "the_out_param_triple";
export const pair_projection : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "pair_projection";
export const where_question : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "where_question";
export const boolean_projection : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "boolean_projection";
export const projection_Any : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "projection_Any";
export const verb_projection_Any : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "verb_projection_Any";
export const stream_projection_Any : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "stream_projection_Any";
export const placeholder : $SentenceGeneratorTypes.NonTerminal<C.Placeholder> = "placeholder";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   $grammar.declareSymbol("table_join_replace_placeholder");
   $grammar.declareSymbol("action_replace_param_with_table");
   $grammar.declareSymbol("action_replace_param_with_stream");
   $grammar.declareSymbol("the_out_param_Any");
   $grammar.addRule("the_out_param_Any", [new $runtime.NonTerminal("out_param_Any", "p", undefined)], $locale._("the ${p}"), ((p : C.ParamSlot) : (C.ParamSlot)|null => p), C.paramKeyFn, {  });
   if (!$options.flags.inference) {
       if (!$options.flags.turking) {
           $grammar.addRule("the_out_param_Any", [new $runtime.NonTerminal("out_param_Any", "p", undefined)], $locale._("its ${p}"), ((p : C.ParamSlot) : (C.ParamSlot)|null => p), C.paramKeyFn, {  });
           $grammar.addRule("the_out_param_Any", [new $runtime.NonTerminal("out_param_Any", "p", undefined)], $locale._("their ${p}"), ((p : C.ParamSlot) : (C.ParamSlot)|null => p), C.paramKeyFn, {  });
       }
   }
   $grammar.declareSymbol("the_out_param_pair");
   $grammar.addRule("the_out_param_pair", [new $runtime.NonTerminal("out_param_Any", "p1", undefined), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${p1} and ${p2}"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(p1.schema, p2.schema));
        if (p1.name === p2.name)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("the_out_param_triple");
   $grammar.addRule("the_out_param_triple", [new $runtime.NonTerminal("out_param_Any", "p1", undefined), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("out_param_Any", "p3", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${p1} , ${p2} {,|} and ${p3}"), ((p1 : C.ParamSlot, p2 : C.ParamSlot, p3 : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(p1.schema, p2.schema));
        assert(C.isSameFunction(p1.schema, p3.schema));
        if (p1.name === p2.name || p1.name === p3.name || p2.name === p3.name)
            return null;
        return [p1, p2, p3];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("pair_projection");
   $grammar.addRule("pair_projection", [new $runtime.NonTerminal("the_out_param_pair", "outParams", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("{both|} ${outParams} of ${table}"), ((outParams : C.ParamSlot[], table : Ast.Expression) : (Ast.Expression)|null => C.makeMultiFieldProjection($loader, 'table', table, outParams)), C.expressionKeyFn, {  });
   $grammar.addRule("pair_projection", [new $runtime.NonTerminal("the_out_param_triple", "outParams", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("${outParams} of the ${table}"), ((outParams : C.ParamSlot[], table : Ast.Expression) : (Ast.Expression)|null => C.makeMultiFieldProjection($loader, 'table', table, outParams)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("where_question");
   $grammar.addRule("where_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("where is the ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Location, table, 'geo')), C.expressionKeyFn, {  });
   $grammar.addRule("where_question", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("where is the ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Location, table, 'geo')), C.expressionKeyFn, {  });
   $grammar.declareSymbol("boolean_projection");
   $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("npp_boolean_projection", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("does {the||any} ${table} have ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Boolean, table, p)), C.expressionKeyFn, {  });
   $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("avp_boolean_projection", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("does {the||any} ${table} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Boolean, table, p)), C.expressionKeyFn, {  });
   $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("pvp_boolean_projection", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|} ${table} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Boolean, table, p)), C.expressionKeyFn, {  });
   $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("preposition_boolean_projection", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|} ${table} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Boolean, table, p)), C.expressionKeyFn, {  });
   $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("npi_boolean_projection", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|} ${table} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Boolean, table, p)), C.expressionKeyFn, {  });
   $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("npv_boolean_projection", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|} ${table} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Boolean, table, p)), C.expressionKeyFn, {  });
   $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("apv_boolean_projection", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|} ${table} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', Type.Boolean, table, p)), C.expressionKeyFn, {  });
   for (const proj of $loader.projections) {
       if (proj.category === 'pvp' || proj.category === 'passive_verb' || proj.category === 'preposition') {
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} ${table} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} ${table} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           }
       }
       if (proj.category === 'avp' || proj.category === 'verb') {
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {do|does|did} {the|} ${table} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {do|does|did} {the|} ${table} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           }
       }
       if (proj.category === 'reverse_verb') {
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           }
       }
       if (proj.category === 'reverse_passive_verb') {
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           }
       }
       if (proj.category === 'property') {
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           }
       }
       if (proj.category === 'reverse_property') {
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} {a|an|the|} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} {a|an|the|} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           }
       }
       if (proj.category === 'reverse_base') {
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           $grammar.declareSymbol("question_projection_table");
           $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
               $grammar.declareSymbol("command_projection_table");
               $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("" + (proj.base) + " {that|which|} {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {  });
           }
       }
   }
   $grammar.declareSymbol("projection_Any");
   $grammar.addRule("projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${outParam} of ${table}"), ((outParam : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {  });
   $grammar.addRule("projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${outParam} of the ${table}"), ((outParam : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("verb_projection_Any");
   $grammar.addRule("verb_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${outParam} {do|does} {the|} ${table} have"), ((outParam : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {  });
   $grammar.addRule("verb_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${outParam} {do|does} {the|} ${table} have"), ((outParam : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("stream_projection_Any");
   if (!$options.flags.nostream) {
       $grammar.addRule("stream_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${outParam} of new ${table}"), ((outParam : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'stream', null, table, outParam)), C.expressionKeyFn, {  });
       $grammar.addRule("stream_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${outParam} of the new ${table}"), ((outParam : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => C.makeSingleFieldProjection($loader, 'stream', null, table, outParam)), C.expressionKeyFn, {  });
       $grammar.addRule("stream_projection_Any", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("new ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.makeTypeBasedStreamProjection(table)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("placeholder");
   $grammar.addRule("placeholder", [], $locale._("some number"), (() : (C.Placeholder)|null => ({ type: Type.Number })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some value"), (() : (C.Placeholder)|null => ({ type: Type.Number })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("something"), (() : (C.Placeholder)|null => ({ type: Type.String })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some value"), (() : (C.Placeholder)|null => ({ type: Type.Currency })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some amount"), (() : (C.Placeholder)|null => ({ type: Type.Currency })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some time"), (() : (C.Placeholder)|null => ({ type: Type.Time })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain time"), (() : (C.Placeholder)|null => ({ type: Type.Time })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some date"), (() : (C.Placeholder)|null => ({ type: Type.Date })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain date"), (() : (C.Placeholder)|null => ({ type: Type.Date })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some time"), (() : (C.Placeholder)|null => ({ type: Type.Date })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain time"), (() : (C.Placeholder)|null => ({ type: Type.Date })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some location"), (() : (C.Placeholder)|null => ({ type: Type.Location })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a location"), (() : (C.Placeholder)|null => ({ type: Type.Location })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some place"), (() : (C.Placeholder)|null => ({ type: Type.Location })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a place"), (() : (C.Placeholder)|null => ({ type: Type.Location })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain place"), (() : (C.Placeholder)|null => ({ type: Type.Location })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("somewhere"), (() : (C.Placeholder)|null => ({ type: Type.Location })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some duration"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('ms') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some amount of time"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('ms') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some size"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('byte') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain size"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('byte') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain weight"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('kg') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain temperature"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('C') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some distance"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('m') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some length"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('m') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some size"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('m2') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain size"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('m2') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some volume"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('m3') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain volume"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('m3') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some speed"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('mps') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("a certain speed"), (() : (C.Placeholder)|null => ({ type: new Type.Measure('mps') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some image"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:picture') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some picture"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:picture') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some photo"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:picture') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("somebody"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:username') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("someone"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:username') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some one"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:username') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some person"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:username') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("somebody"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("someone"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some one"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some person"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some number"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some phone number"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("somebody"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("someone"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some one"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some person"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some email address"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some file"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some directory"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some folder"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some url"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:url') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some website"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:url') })), C.placeholderKeyFn, {  });
   $grammar.addRule("placeholder", [], $locale._("some link"), (() : (C.Placeholder)|null => ({ type: new Type.Entity('tt:url') })), C.placeholderKeyFn, {  });
};
