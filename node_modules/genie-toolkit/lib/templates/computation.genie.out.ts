// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

import * as $runtime from "../sentence-generator/runtime";
import type $SentenceGenerator from "../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../sentence-generator/types";
import * as $I18n from "../i18n/index";
import assert from 'assert';
import { Ast, Type } from 'thingtalk';
import * as C from './ast_manip';
import ThingpediaLoader from './load-thingpedia';
export const projection_Measure_m : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "projection_Measure_m";
export const compute_question : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "compute_question";
export const with_arg_min_max_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "with_arg_min_max_table";
export const projection_Number : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "projection_Number";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {

    const HERE = new Ast.Value.Location(new Ast.Location.Relative('current_location'));

    function hasGeoLocationOutput(schema : Ast.FunctionDef) {
        const arg = schema.getArgument('geo');
        return arg && !arg.is_input && arg.type === Type.Location;
    }
   $grammar.declareSymbol("projection_Measure_m");
   $grammar.declareSymbol("compute_question");
   $grammar.declareSymbol("with_arg_min_max_table");
   $grammar.declareSymbol("projection_Measure_m");
   if (!$options.flags.turking) {
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("the distance {of|to} ${table} {from here|}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("the distance {of|to} the ${table} {from here|}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("how {far|near|close} ${table} is {from here|}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("how {far|near|close} the ${table} is {from here|}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("the distance {of|to} ${table} from ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("the distance from ${place} {of|to} ${table}"), ((place : Ast.LocationValue, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("the distance {of|to} the ${table} from ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("the distance from ${place} {of|to} the ${table}"), ((place : Ast.LocationValue, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("how {far|near|close} from ${place} ${table} is"), ((place : Ast.LocationValue, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} ${table} is from ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("how {far|near|close} from ${place} the ${table} is"), ((place : Ast.LocationValue, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} the ${table} is from ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("projection_Number");
   if (!$options.flags.turking) {
       $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the number of ${p} {of|in|in the} ${table}"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the number of ${p} {of|in} the ${table}"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the number of ${p} with ${filter} {of|in|in the} ${table}"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the number of ${p} with ${filter} {of|in} the ${table}"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the number of ${p} {of|in|in the} ${table}"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the number of ${p} {of|in} the ${table}"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("compute_question");
   if (!$options.flags.turking) {
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("how {far|near|close} {is|are} ${table} {from here|} {?|}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("how {far|near|close} {is|are} the ${table} {from here|} {?|}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} {is|are} ${table} {from|to} ${place} {?|}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} {is|are} the ${table} {from|to} ${place} {?|}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'));
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} {does|do} ${table} have ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (table.schema!.getArgType(p.name)!.isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} {in a|in|in the} ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (table.schema!.getArgType(p.name)!.isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} are there {in a|in|in the} ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (table.schema!.getArgType(p.name)!.isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} {does|do} the ${table} have ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (table.schema!.getArgType(p.name)!.isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} in the ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (table.schema!.getArgType(p.name)!.isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} are there in the ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            assert (table.schema!.getArgType(p.name)!.isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} {does|do} ${table} have ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {

            assert (table.schema!.getArgType(p.name)!.isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} {in a|in|in the} ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {

            assert (table.schema!.getArgType(p.name)!.isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} are there {in a|in|in the} ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {

            assert (table.schema!.getArgType(p.name)!.isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} {does|do} the ${table} have ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {

            assert (table.schema!.getArgType(p.name)!.isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} in the ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {

            assert (table.schema!.getArgType(p.name)!.isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} are there in the ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {

            assert (table.schema!.getArgType(p.name)!.isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, Type.Number);
        }), C.expressionKeyFn, {  });
       if (!$options.flags.dialogues) {
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} with ${filter} {does|do} ${table} have ?"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} with ${filter} {in a|in|in the} ${table} ?"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} with ${filter} are there {in a|in|in the} ${table} ?"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} with ${filter} {does|do} the ${table} have ?"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} with ${filter} in the ${table} ?"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} with ${filter} are there in the ${table} ?"), ((p : C.ParamSlot, filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const ptype = table.schema!.getArgType(p.name);
            if (!ptype || !(ptype instanceof Type.Array) || !(filter instanceof Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem as Type;
            if (!(elementType instanceof Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, Type.Number);
        }), C.expressionKeyFn, {  });
       }
       if ($options.flags.aggregation) {
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]])], $locale._("how many ${table} are there ?"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert(table.schema!.is_list);
            const newSchema = table.schema!.filterArguments((arg) => arg.direction !== Ast.ArgDirection.OUT)
                .addArguments([new Ast.ArgumentDef(null, Ast.ArgDirection.OUT, 'count', Type.Number)]);
            newSchema.is_list = false;
            const agg = new Ast.AggregationExpression(null, table, '*', 'count', newSchema);
            return new Ast.ProjectionExpression(null, agg, ['count'], [], [], newSchema);
        }), C.expressionKeyFn, {  });
           $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]])], $locale._("{please|} count the ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert(table.schema!.is_list);
            const newSchema = table.schema!.filterArguments((arg) => arg.direction !== Ast.ArgDirection.OUT)
                .addArguments([new Ast.ArgumentDef(null, Ast.ArgDirection.OUT, 'count', Type.Number)]);
            newSchema.is_list = false;
            const agg = new Ast.AggregationExpression(null, table, '*', 'count', newSchema);
            return new Ast.ProjectionExpression(null, agg, ['count'], [], [], newSchema);
        }), C.expressionKeyFn, {  });
           if (!$options.flags.schema_org) {
               $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Any", "p", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} are {in|in the} ${table} ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumeric())
                return null;
            if (!table.schema!.is_list)
                return null;

            const newSchema = table.schema!.filterArguments((arg) => arg.direction !== Ast.ArgDirection.OUT || arg.name === p.name);
            newSchema.is_list = false;
            const agg = new Ast.AggregationExpression(null, table, p.name, 'sum', newSchema);
            return new Ast.ProjectionExpression(null, agg, [p.name], [], [], newSchema);
        }), C.expressionKeyFn, {  });
           }
           if (!$options.flags.schema_org) {
               $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Any", "p", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("how many ${p} {do|does} ${table} have ?"), ((p : C.ParamSlot, table : Ast.Expression) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumeric())
                return null;
            if (!table.schema!.is_list)
                return null;

            const newSchema = table.schema!.filterArguments((arg) => arg.direction !== Ast.ArgDirection.OUT || arg.name === p.name);
            newSchema.is_list = false;
            const agg = new Ast.AggregationExpression(null, table, p.name, 'sum', newSchema);
            return new Ast.ProjectionExpression(null, agg, [p.name], [], [], newSchema);
        }), C.expressionKeyFn, {  });
           }
       }
   }
   $grammar.declareSymbol("with_arg_min_max_table");
   if (!$options.flags.turking) {
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("{nearest|closest} ${table} {|from here|to here|to me}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("{nearest|closest} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]])], $locale._("{farthest|most far away} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), HERE], new Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("{nearest|closest} ${table} to ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {that is|which is} {nearest|closest} to ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {nearest|closest} to ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("{nearest|closest} ${table} to ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {that is|which is} {nearest|closest} to ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {nearest|closest} to ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("{farthest|most far away} ${table} from ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {that is|which is} {farthest|most far away} from ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {farthest|most far away} from ${place}"), ((table : Ast.Expression, place : Ast.LocationValue) : (Ast.Expression)|null => {
            assert (hasGeoLocationOutput(table.schema!));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new Ast.Value.VarRef('geo'), place], new Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} with the {most|highest number of|largest number of|largest count of} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeArgMaxMinTable(table, conflictParam, 'desc');
            return C.makeAggComputeArgMinMaxExpression(table, 'count', null, p, Type.Number, 'desc');
        }), C.expressionKeyFn, { weight: (0.33) });
       if (!$options.flags.turking) {
           $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} with the {least|fewest|smallest number of|tiniest number of|smallest count of} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeArgMaxMinTable(table, conflictParam, 'asc');
            return C.makeAggComputeArgMinMaxExpression(table, 'count', null, p, Type.Number, 'asc');
        }), C.expressionKeyFn, { weight: (0.33) });
       }
       if ($options.flags.turking) {
           $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} with the {fewest|smallest number of} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeArgMaxMinTable(table, conflictParam, 'asc');
            return C.makeAggComputeArgMinMaxExpression(table, 'count', null, p, Type.Number, 'asc');
        }), C.expressionKeyFn, { weight: (0.33) });
       }
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} with the {most|highest number of|largest number of|largest count of} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeArgMaxMinTable(table, p.name, 'desc');
        }), C.expressionKeyFn, { weight: (0.33) });
       if (!$options.flags.turking) {
           $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} with the {least|fewest|smallest number of|tiniest number of|smallest count of} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeArgMaxMinTable(table, p.name, 'asc');
        }), C.expressionKeyFn, { weight: (0.33) });
       }
       if ($options.flags.turking) {
           $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} with the {fewest|smallest number of} ${p}"), ((table : Ast.Expression, p : C.ParamSlot) : (Ast.Expression)|null => {
            const arg = table.schema!.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeArgMaxMinTable(table, p.name, 'asc');
        }), C.expressionKeyFn, { weight: (0.33) });
       }
   }
};
