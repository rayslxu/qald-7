// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
//         Giovanni Campagna <gcampagn@cs.stanford.edu>

import * as $runtime from "../sentence-generator/runtime";
import type $SentenceGenerator from "../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../sentence-generator/types";
import * as $I18n from "../i18n/index";
import { Ast, Type } from 'thingtalk';
import * as C from './ast_manip';
import ThingpediaLoader from './load-thingpedia';
export const complete_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "complete_table";
export const complete_get_command : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "complete_get_command";
export const if_filtered_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "if_filtered_table";
export const one_if_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "one_if_filter_table";
export const two_if_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "two_if_filter_table";
export const with_filtered_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "with_filtered_table";
export const answer_noun_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "answer_noun_phrase";
export const one_with_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "one_with_filter_table";
export const one_which_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "one_which_filter_table";
export const one_clean_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "one_clean_filter_table";
export const two_with_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "two_with_filter_table";
export const two_which_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "two_which_filter_table";
export const two_clean_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "two_clean_filter_table";
export const three_with_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "three_with_filter_table";
export const three_which_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "three_which_filter_table";
export const three_clean_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "three_clean_filter_table";
export const anything_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "anything_phrase";
export const anything_with_filter_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "anything_with_filter_phrase";
export const anything_which_filter_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "anything_which_filter_phrase";
export const anything_clean_filter_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "anything_clean_filter_phrase";
export const verb_filtered_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "verb_filtered_table";
export const one_be_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "one_be_filter_table";
export const one_have_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "one_have_filter_table";
export const one_verb_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "one_verb_filter_table";
export const two_be_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "two_be_filter_table";
export const two_have_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "two_have_filter_table";
export const two_verb_filter_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "two_verb_filter_table";
export const generic_argminmax : $SentenceGeneratorTypes.NonTerminal<C.ArgMinMax> = "generic_argminmax";
export const with_arg_min_max_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "with_arg_min_max_table";
export const have_arg_min_max_table : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "have_arg_min_max_table";
export const edge_stream : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "edge_stream";
export const stream : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "stream";
export const with_filtered_table_join : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "with_filtered_table_join";
export const have_filtered_table_join : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "have_filtered_table_join";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   $grammar.declareSymbol("complete_table");
   $grammar.addRule("complete_table", [new $runtime.NonTerminal("thingpedia_complete_query", "q", undefined)], "${q}", ((q : Ast.Expression) : (Ast.Expression)|null => {
        if (q instanceof Ast.AggregationExpression)
            return null;
        return q;
    }), C.expressionKeyFn, {  });
   if (!$options.flags.notablejoin) {
       $grammar.addRule("complete_table", [new $runtime.NonTerminal("table_join_replace_placeholder", undefined, undefined)], "${table_join_replace_placeholder}", (($0 : Ast.ChainExpression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   }
   $grammar.addRule("complete_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("preposition_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${param}"), ((table : Ast.Expression, param : C.InputParamSlot) : (Ast.Expression)|null => C.addActionInputParam($loader, table, param)), C.expressionKeyFn, {  });
   $grammar.addRule("complete_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {with|having} ${param}"), ((table : Ast.Expression, param : C.InputParamSlot) : (Ast.Expression)|null => C.addActionInputParam($loader, table, param)), C.expressionKeyFn, {  });
   $grammar.addRule("complete_table", [new $runtime.NonTerminal("apv_input_param", "param", undefined), new $runtime.NonTerminal("complete_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void)])], $locale._("${param} ${table}"), ((param : C.InputParamSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addActionInputParam($loader, table, param)), C.expressionKeyFn, {  });
   $grammar.addRule("complete_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("pvp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${param}"), ((table : Ast.Expression, param : C.InputParamSlot) : (Ast.Expression)|null => C.addActionInputParam($loader, table, param)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("complete_get_command");
   $grammar.addRule("complete_get_command", [new $runtime.NonTerminal("thingpedia_complete_get_command", undefined, undefined)], "${thingpedia_complete_get_command}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("complete_get_command", [new $runtime.NonTerminal("complete_get_command", "table", undefined), new $runtime.NonTerminal("preposition_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${param}"), ((table : Ast.Expression, param : C.InputParamSlot) : (Ast.Expression)|null => C.addActionInputParam($loader, table, param)), C.expressionKeyFn, {  });
   $grammar.addRule("complete_get_command", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {with|having} ${param}"), ((table : Ast.Expression, param : C.InputParamSlot) : (Ast.Expression)|null => C.addActionInputParam($loader, table, param)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("if_filtered_table");
   if (!$options.flags.always_filter) {
       $grammar.addRule("if_filtered_table", [new $runtime.NonTerminal("complete_table", undefined, undefined)], "${complete_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   }
   $grammar.addRule("if_filtered_table", [new $runtime.NonTerminal("one_if_filter_table", undefined, undefined)], "${one_if_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   if (!$options.flags.turking) {
       $grammar.addRule("if_filtered_table", [new $runtime.NonTerminal("two_if_filter_table", undefined, undefined)], "${two_if_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   }
   $grammar.declareSymbol("one_if_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_if_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} if ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter, { ifFilter: true })), C.expressionKeyFn, {  });
       $grammar.addRule("one_if_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), (null) as ReturnType<typeof C.filterKeyFn>["functionName"]])], $locale._("${table} if ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter, { ifFilter: true })), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("two_if_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_if_filter_table", [new $runtime.NonTerminal("one_if_filter_table", "table", undefined), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter, { ifFilter: true })), C.expressionKeyFn, {  });
       $grammar.addRule("two_if_filter_table", [new $runtime.NonTerminal("one_if_filter_table", "table", undefined), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), (null) as ReturnType<typeof C.filterKeyFn>["functionName"]])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter, { ifFilter: true })), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("with_filtered_table");
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("complete_table", undefined, undefined)], "${complete_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { weight: (3), identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("one_with_filter_table", undefined, undefined)], "${one_with_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("one_which_filter_table", undefined, undefined)], "${one_which_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("one_clean_filter_table", undefined, undefined)], "${one_clean_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("two_with_filter_table", undefined, undefined)], "${two_with_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("two_which_filter_table", undefined, undefined)], "${two_which_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("two_clean_filter_table", undefined, undefined)], "${two_clean_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("three_with_filter_table", undefined, undefined)], "${three_with_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { weight: (0.1), identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("three_which_filter_table", undefined, undefined)], "${three_which_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { weight: (0.1), identity: (true) });
   $grammar.addRule("with_filtered_table", [new $runtime.NonTerminal("three_clean_filter_table", undefined, undefined)], "${three_clean_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { weight: (0.1), identity: (true) });
   $grammar.declareSymbol("answer_noun_phrase");
   $grammar.addRule("answer_noun_phrase", [new $runtime.NonTerminal("one_with_filter_table", undefined, undefined)], "${one_with_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { weight: (10), identity: (true) });
   $grammar.addRule("answer_noun_phrase", [new $runtime.NonTerminal("one_which_filter_table", undefined, undefined)], "${one_which_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { weight: (10), identity: (true) });
   $grammar.addRule("answer_noun_phrase", [new $runtime.NonTerminal("one_clean_filter_table", undefined, undefined)], "${one_clean_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { weight: (10), identity: (true) });
   $grammar.addRule("answer_noun_phrase", [new $runtime.NonTerminal("two_with_filter_table", undefined, undefined)], "${two_with_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("answer_noun_phrase", [new $runtime.NonTerminal("two_which_filter_table", undefined, undefined)], "${two_which_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("answer_noun_phrase", [new $runtime.NonTerminal("two_clean_filter_table", undefined, undefined)], "${two_clean_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.declareSymbol("one_with_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_with_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {with|having} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_with_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {with|having} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       if (!$options.flags.nofilter) {
           $grammar.addRule("one_with_filter_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("within_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : ({ distance : Ast.Value, place : Ast.Value })) : (Ast.Expression)|null => C.makeWithinGeoDistanceExpression($loader, table, filter.place, filter.distance)), C.expressionKeyFn, {  });
       }
   }
   $grammar.declareSymbol("one_which_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_which_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_which_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_which_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_which_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_which_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_which_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_which_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("reverse_verb_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("one_clean_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_clean_filter_table", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("complete_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${filter} ${table}"), ((filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_clean_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_clean_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("preposition_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_clean_filter_table", [new $runtime.NonTerminal("quality_filter", "filter", undefined), new $runtime.NonTerminal("complete_table", "table", undefined)], $locale._("${filter} ${table}"), ((filter : C.DomainIndependentFilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_clean_filter_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("nearby_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("two_with_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {and having|and with|, with|and have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {with|having|that have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {and having|and with|, with|and have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {with|having|that have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("one_with_filter_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${filter} ${table}"), ((filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       if (!$options.flags.nofilter) {
           $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("within_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : ({ distance : Ast.Value, place : Ast.Value })) : (Ast.Expression)|null => C.makeWithinGeoDistanceExpression($loader, table, filter.place, filter.distance)), C.expressionKeyFn, {  });
       }
       if (!$options.flags.nofilter) {
           $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("within_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : ({ distance : Ast.Value, place : Ast.Value })) : (Ast.Expression)|null => C.makeWithinGeoDistanceExpression($loader, table, filter.place, filter.distance)), C.expressionKeyFn, {  });
       }
       if (!$options.flags.nofilter) {
           $grammar.addRule("two_with_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("within_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : ({ distance : Ast.Value, place : Ast.Value })) : (Ast.Expression)|null => C.makeWithinGeoDistanceExpression($loader, table, filter.place, filter.distance)), C.expressionKeyFn, {  });
       }
   }
   $grammar.declareSymbol("two_which_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined), new $runtime.NonTerminal("reverse_verb_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined), new $runtime.NonTerminal("reverse_verb_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("reverse_verb_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       if (!$options.flags.nofilter) {
           $grammar.addRule("two_which_filter_table", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("one_which_filter_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${filter} ${table}"), ((filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       }
   }
   $grammar.declareSymbol("two_clean_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_clean_filter_table", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("one_clean_filter_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${filter} ${table}"), ((filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_clean_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_clean_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined), new $runtime.NonTerminal("preposition_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_clean_filter_table", [new $runtime.NonTerminal("quality_filter", "filter", undefined), new $runtime.NonTerminal("one_clean_filter_table", "table", undefined)], $locale._("${filter} ${table}"), ((filter : C.DomainIndependentFilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_clean_filter_table", [new $runtime.NonTerminal("one_clean_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("nearby_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("three_with_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {and having|and with|, with|and have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {with|having|that have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {and having|and with|, with|and have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {with|having|that have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("two_with_filter_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${filter} ${table}"), ((filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       if (!$options.flags.nofilter) {
           $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("within_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : ({ distance : Ast.Value, place : Ast.Value })) : (Ast.Expression)|null => C.makeWithinGeoDistanceExpression($loader, table, filter.place, filter.distance)), C.expressionKeyFn, {  });
       }
       if (!$options.flags.nofilter) {
           $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("within_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : ({ distance : Ast.Value, place : Ast.Value })) : (Ast.Expression)|null => C.makeWithinGeoDistanceExpression($loader, table, filter.place, filter.distance)), C.expressionKeyFn, {  });
       }
       if (!$options.flags.nofilter) {
           $grammar.addRule("three_with_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("within_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : ({ distance : Ast.Value, place : Ast.Value })) : (Ast.Expression)|null => C.makeWithinGeoDistanceExpression($loader, table, filter.place, filter.distance)), C.expressionKeyFn, {  });
       }
   }
   $grammar.declareSymbol("three_which_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined), new $runtime.NonTerminal("reverse_verb_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined), new $runtime.NonTerminal("reverse_verb_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} have ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("reverse_verb_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} {which|that} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("three_which_filter_table", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("two_which_filter_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${filter} ${table}"), ((filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("three_clean_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("three_clean_filter_table", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("two_clean_filter_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${filter} ${table}"), ((filter : C.FilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_clean_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_clean_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined), new $runtime.NonTerminal("preposition_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_clean_filter_table", [new $runtime.NonTerminal("quality_filter", "filter", undefined), new $runtime.NonTerminal("two_clean_filter_table", "table", undefined)], $locale._("${filter} ${table}"), ((filter : C.DomainIndependentFilterSlot, table : Ast.Expression) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("three_clean_filter_table", [new $runtime.NonTerminal("two_clean_filter_table", "table", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("nearby_filter", "filter", undefined)], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("anything_phrase");
   $grammar.addRule("anything_phrase", [new $runtime.NonTerminal("anything_with_filter_phrase", undefined, undefined)], "${anything_with_filter_phrase}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("anything_phrase", [new $runtime.NonTerminal("anything_which_filter_phrase", undefined, undefined)], "${anything_which_filter_phrase}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("anything_phrase", [new $runtime.NonTerminal("anything_clean_filter_phrase", undefined, undefined)], "${anything_clean_filter_phrase}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.declareSymbol("anything_with_filter_phrase");
   $grammar.addRule("anything_with_filter_phrase", [new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{any|some} ${phrase} {with|having} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_with_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} {with|having} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("anything_which_filter_phrase");
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{any|some} ${phrase} {which|that} {has|have} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{any|some} ${phrase} {which|that} {is|are} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{any|some} ${phrase} {which|that} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{any|some} ${phrase} {which|that} {is|are} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} {which|that} {has|have} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} {which|that} {is|are} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} {which|that} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_which_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} {which|that} {is|are} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("anything_clean_filter_phrase");
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("apv_filter", "filter", undefined), new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("{any|some} ${filter} ${phrase}"), ((filter : C.FilterSlot, phrase : Ast.InvocationExpression) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{any|some} ${phrase} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("generic_base_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("preposition_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{any|some} ${phrase} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined), new $runtime.NonTerminal("preposition_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${phrase} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", ["has_geo" as ("has_geo" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["has_geo"]]), new $runtime.NonTerminal("nearby_filter", "filter", undefined)], $locale._("${phrase} ${filter}"), ((phrase : Ast.InvocationExpression, filter : C.DomainIndependentFilterSlot) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.addRule("anything_clean_filter_phrase", [new $runtime.NonTerminal("quality_filter", "filter", undefined), new $runtime.NonTerminal("generic_anything_noun_phrase", "phrase", undefined)], $locale._("${filter} ${phrase}"), ((filter : C.DomainIndependentFilterSlot, phrase : Ast.InvocationExpression) : (Ast.Expression)|null => C.addFilter($loader, phrase, filter)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("verb_filtered_table");
   $grammar.addRule("verb_filtered_table", [new $runtime.NonTerminal("one_be_filter_table", undefined, undefined)], "${one_be_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("verb_filtered_table", [new $runtime.NonTerminal("one_have_filter_table", undefined, undefined)], "${one_have_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("verb_filtered_table", [new $runtime.NonTerminal("one_verb_filter_table", undefined, undefined)], "${one_verb_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("verb_filtered_table", [new $runtime.NonTerminal("two_be_filter_table", undefined, undefined)], "${two_be_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("verb_filtered_table", [new $runtime.NonTerminal("two_have_filter_table", undefined, undefined)], "${two_have_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("verb_filtered_table", [new $runtime.NonTerminal("two_verb_filter_table", undefined, undefined)], "${two_verb_filter_table}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.declareSymbol("one_be_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_be_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_be_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_be_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("one_be_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("one_have_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_have_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {get|have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_have_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {get|have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("one_verb_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("one_verb_filter_table", [new $runtime.NonTerminal("complete_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("two_be_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined), new $runtime.NonTerminal("npi_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined), new $runtime.NonTerminal("pvp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined), new $runtime.NonTerminal("apv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_be_filter_table", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined), new $runtime.NonTerminal("npv_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {is|are} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("two_have_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_have_filter_table", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {get|have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_have_filter_table", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_have_filter_table", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {get|have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_have_filter_table", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {get|have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_have_filter_table", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_have_filter_table", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined), new $runtime.NonTerminal("npp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {|,} and {get|have} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("two_verb_filter_table");
   if (!$options.flags.nofilter) {
       $grammar.addRule("two_verb_filter_table", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_verb_filter_table", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
       $grammar.addRule("two_verb_filter_table", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined), new $runtime.NonTerminal("avp_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => C.addFilter($loader, table, filter)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("generic_argminmax");
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{maximum|highest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{minimum|lowest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{most costly|most expensive|maximum} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{least costly|cheapest|minimum} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{longest|most lasting} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("shortest ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{maximum|largest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{minimum|smallest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{heaviest|largest|maximum} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{lightest|smallest|minimum} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{hottest|highest|maximum} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{coolest|lowest|minimum} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{farthest|most distant|longest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{nearest|closest|shortest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{largest|biggest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("smallest ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{largest|biggest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("smallest ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{fastest|quickest|speediest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{slowest|most slowly} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{latest|most recent} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{earliest|soonest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{latest|most recent} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'desc']), C.argMinMaxKeyFn, {  });
   $grammar.addRule("generic_argminmax", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("{earliest|soonest} ${p}"), ((p : C.ParamSlot) : (C.ArgMinMax)|null => [p, 'asc']), C.argMinMaxKeyFn, {  });
   $grammar.declareSymbol("with_arg_min_max_table");
   if ($options.flags.aggregation) {
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {with|which has|which have} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {with|which has|which have} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("complete_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${argminmax} ${t}"), ((argminmax : C.ArgMinMax, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_clean_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {with|which has|which have} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_clean_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {with|which has|which have} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_clean_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_clean_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_clean_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("one_clean_filter_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${argminmax} ${t}"), ((argminmax : C.ArgMinMax, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_clean_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_with_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_with_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_with_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_with_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_with_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("one_with_filter_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${argminmax} ${t}"), ((argminmax : C.ArgMinMax, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_with_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_with_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_with_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_with_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_with_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_with_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("two_with_filter_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${argminmax} ${t}"), ((argminmax : C.ArgMinMax, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_with_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {that|which} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_which_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and have the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_which_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and have the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_which_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_which_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_which_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("one_which_filter_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${argminmax} ${t}"), ((argminmax : C.ArgMinMax, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("one_which_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_which_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and have the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_which_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and have the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_which_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_which_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_which_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("two_which_filter_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${argminmax} ${t}"), ((argminmax : C.ArgMinMax, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("two_which_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("constant_Number", "count", undefined), new $runtime.NonTerminal("with_filtered_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${argminmax} ${count} ${t}"), ((argminmax : C.ArgMinMax, count : Ast.NumberValue, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1], count)), C.expressionKeyFn, {  });
       $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("constant_Number", "count", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", undefined), new $runtime.NonTerminal("with_filtered_table", "t", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void)])], $locale._("${count} ${argminmax} ${t}"), ((count : Ast.NumberValue, argminmax : C.ArgMinMax, t : Ast.Expression) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1], count)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("have_arg_min_max_table");
   if ($options.flags.aggregation) {
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {has|gets} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {has|gets} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {has|gets} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {has|gets} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_have_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_have_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_have_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_have_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_have_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_have_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_verb_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_verb_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_verb_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_verb_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_verb_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_verb_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_be_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_be_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_be_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_be_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {|is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_be_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {|is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("one_be_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {|is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_have_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_have_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_have_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_have_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_have_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_have_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_verb_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_verb_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_verb_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_verb_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_verb_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_verb_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_be_filter_table", "t", undefined), new $runtime.NonTerminal("generic_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_be_filter_table", "t", undefined), new $runtime.NonTerminal("npp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} {and|and has} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_be_filter_table", "t", undefined), new $runtime.NonTerminal("avp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_be_filter_table", "t", undefined), new $runtime.NonTerminal("pvp_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {|is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_be_filter_table", "t", undefined), new $runtime.NonTerminal("apv_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {|is|are} the ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
       $grammar.addRule("have_arg_min_max_table", [new $runtime.NonTerminal("two_be_filter_table", "t", undefined), new $runtime.NonTerminal("preposition_argminmax", "argminmax", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.argMinMaxKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${t} and {|is|are} ${argminmax}"), ((t : Ast.Expression, argminmax : C.ArgMinMax) : (Ast.Expression)|null => C.makeArgMaxMinTable(t, argminmax[0].name, argminmax[1])), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("edge_stream");
   $grammar.addRule("edge_stream", [new $runtime.NonTerminal("projection_Any", "p", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("constant_Any", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{when|if} the ${p} {becomes|becomes equal to} ${x}"), ((p : Ast.Expression, x : Ast.Value) : (Ast.Expression)|null => C.makeEdgeFilterStream($loader, p, '==', x)), C.expressionKeyFn, {  });
   $grammar.addRule("edge_stream", [new $runtime.NonTerminal("projection_Any", "p", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{when|if} the ${p} {becomes greater than|becomes higher than|goes above|increases above} ${x}"), ((p : Ast.Expression, x : Ast.Value) : (Ast.Expression)|null => C.makeEdgeFilterStream($loader, p, '>=', x)), C.expressionKeyFn, {  });
   $grammar.addRule("edge_stream", [new $runtime.NonTerminal("projection_Any", "p", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{when|if} the ${p} {becomes smaller than|becomes lower than|goes below|decreases above} ${x}"), ((p : Ast.Expression, x : Ast.Value) : (Ast.Expression)|null => C.makeEdgeFilterStream($loader, p, '<=', x)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("stream");
   $grammar.addRule("stream", [new $runtime.NonTerminal("thingpedia_complete_stream", undefined, undefined)], "${thingpedia_complete_stream}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   if (!$options.flags.turking) {
       $grammar.addRule("stream", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{when|if|in case|whenever|any time|should|anytime} ${table} {change|update}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(table, { monitorItemID : false })), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("stream", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{when|if|in case|whenever|any time|should|anytime} ${table} update"), ((table : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(table, { monitorItemID : false })), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("stream", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{in case of changes|in case of variations|in case of updates|if something changes|when something changes|if there are changes|if there are updates} in ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(table, { monitorItemID : false })), C.expressionKeyFn, {  });
       $grammar.addRule("stream", [new $runtime.NonTerminal("projection_Any", "proj", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{when|if|in case|whenever|any time|anytime} ${proj} changes"), ((proj : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(proj, { monitorItemID : false })), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("stream", [new $runtime.NonTerminal("complete_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("edge_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{when|if|in case|whenever|any time|should|anytime} ${table} change and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => {
        if (!table.schema!.is_monitorable || !C.checkFilter($loader, table, filter) || table.schema!.is_list)
            return null;
        const withFilter = C.addFilter($loader, table, filter, { ifFilter: true });
        if (!withFilter)
            return null;
        return C.tableToStream(withFilter, { monitorItemID : false });
    }), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("stream", [new $runtime.NonTerminal("complete_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{when|if|in case|whenever|any time|should|anytime} ${table} change and ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => {
        if (!table.schema!.is_monitorable || !C.checkFilter($loader, table, filter))
            return null;
        if ($loader.flags.turking && table.schema!.is_list)
            return null;
        const withFilter = C.addFilter($loader, table, filter, { ifFilter: true });
        if (!withFilter)
            return null;
        return C.tableToStream(withFilter, { monitorItemID : false });
    }), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("stream", [new $runtime.NonTerminal("edge_stream", undefined, undefined)], "${edge_stream}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   }
   $grammar.declareSymbol("with_filtered_table_join");
   if (!$options.flags.notablejoin) {
       $grammar.addRule("with_filtered_table_join", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Any_hidden", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "subquery", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${table} {with|having|that has|that have|which has|which have} ${p} ${subquery}"), ((table : Ast.Expression, p : C.ParamSlot, subquery : Ast.Expression) : (Ast.Expression)|null => C.addComparisonSubquery(table, subquery, p.name)), C.expressionKeyFn, {  });
       $grammar.addRule("with_filtered_table_join", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "subquery", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${table} with ${p} ${subquery}"), ((table : Ast.Expression, p : C.ParamSlot, subquery : Ast.Expression) : (Ast.Expression)|null => C.addComparisonSubquery(table, subquery, p.name)), C.expressionKeyFn, {  });
       $grammar.addRule("with_filtered_table_join", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_pvp", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "subquery", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${table} ${p} ${subquery}"), ((table : Ast.Expression, p : C.ParamSlot, subquery : Ast.Expression) : (Ast.Expression)|null => C.addComparisonSubquery(table, subquery, p.name)), C.expressionKeyFn, {  });
       $grammar.addRule("with_filtered_table_join", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_avp", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "subquery", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${table} {who|which|that} ${p} ${subquery}"), ((table : Ast.Expression, p : C.ParamSlot, subquery : Ast.Expression) : (Ast.Expression)|null => C.addComparisonSubquery(table, subquery, p.name)), C.expressionKeyFn, {  });
       $grammar.addRule("with_filtered_table_join", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Any_hidden", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "subquery", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${table} {of|for|in} ${p} ${subquery}"), ((table : Ast.Expression, p : C.ParamSlot, subquery : Ast.Expression) : (Ast.Expression)|null => C.addReverseComparisonSubquery(table, subquery, null)), C.expressionKeyFn, {  });
       if (!$options.flags.turking) {
           $grammar.addRule("with_filtered_table_join", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Any_hidden", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "subquery", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${table} 's ${p} ${subquery}"), ((table : Ast.Expression, p : C.ParamSlot, subquery : Ast.Expression) : (Ast.Expression)|null => C.addReverseComparisonSubquery(table, subquery, null)), C.expressionKeyFn, {  });
       }
   }
   $grammar.declareSymbol("have_filtered_table_join");
   if (!$options.flags.notablejoin) {
       $grammar.addRule("have_filtered_table_join", [new $runtime.NonTerminal("verb_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Any_hidden", "p", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)]), new $runtime.NonTerminal("with_filtered_table", "subquery", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${table} {and|and have|and also|and in addition|but also} ${p} ${subquery}"), ((table : Ast.Expression, p : C.ParamSlot, subquery : Ast.Expression) : (Ast.Expression)|null => C.addComparisonSubquery(table, subquery, p.name)), C.expressionKeyFn, {  });
   }
};
