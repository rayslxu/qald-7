// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

import * as $runtime from "../sentence-generator/runtime";
import type $SentenceGenerator from "../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../sentence-generator/types";
import * as $I18n from "../i18n/index";
import { Ast, } from 'thingtalk';
import * as C from './ast_manip';
import ThingpediaLoader from './load-thingpedia';
import { $load as $load___shared, } from "./shared.genie.out";
export {  };
import { $load as $load___constants,at_time, constant_date_point, constant_date_range, constant_day_of_week, unit_Measure_ms, constant_pairs, constant_or_pairs, constant_nor_pairs, constant_String_ContextRef } from "./constants.genie.out";
export { at_time, constant_date_point, constant_date_range, constant_day_of_week, unit_Measure_ms, constant_pairs, constant_or_pairs, constant_nor_pairs, constant_String_ContextRef };
import { $load as $load___timers,timer } from "./timers.genie.out";
export { timer };
import { $load as $load___filters,get_predicate_filter, if_filter, edge_filter, either_filter, range, range_filter, with_filter, range_with_filter, nearby_filter, whose_npp_filter, quality_filter, within_filter, npp_id_soft_filter, pvp_id_soft_filter } from "./filters.genie.out";
export { get_predicate_filter, if_filter, edge_filter, either_filter, range, range_filter, with_filter, range_with_filter, nearby_filter, whose_npp_filter, quality_filter, within_filter, npp_id_soft_filter, pvp_id_soft_filter };
import { $load as $load___projections,the_out_param_pair, the_out_param_triple, pair_projection, where_question, boolean_projection, verb_projection_Any } from "./projections.genie.out";
export { the_out_param_pair, the_out_param_triple, pair_projection, where_question, boolean_projection, verb_projection_Any };
import { $load as $load___aggregation,projection_Number } from "./aggregation.genie.out";
export { projection_Number };
import { $load as $load___computation,projection_Measure_m, compute_question } from "./computation.genie.out";
export { projection_Measure_m, compute_question };
import { $load as $load___who_questions,who_complete_table, who_with_filtered_table, who_one_with_filter_table, who_one_which_filter_table, who_one_clean_filter_table, who_two_with_filter_table, who_two_which_filter_table, who_two_clean_filter_table, who_verb_filtered_table, who_one_be_filter_table, who_one_have_filter_table, who_one_verb_filter_table, who_two_be_filter_table, who_two_have_filter_table, who_two_verb_filter_table, whose_filtered_table } from "./who_questions.genie.out";
export { who_complete_table, who_with_filtered_table, who_one_with_filter_table, who_one_which_filter_table, who_one_clean_filter_table, who_two_with_filter_table, who_two_which_filter_table, who_two_clean_filter_table, who_verb_filtered_table, who_one_be_filter_table, who_one_have_filter_table, who_one_verb_filter_table, who_two_be_filter_table, who_two_have_filter_table, who_two_verb_filter_table, whose_filtered_table };
import { $load as $load___commands,forward_get_do_command, backward_get_do_command, forward_when_do_rule, backward_when_do_rule, when_get_stream, when_get_do_rule, timer_rule, generic_preamble_for_answer, generic_preamble_for_action, generic_verb_for_search, imperative_verb_for_search, generic_search_preamble, generic_lookup_preamble, generic_article, search_command, complete_question, projection_question, explicit_when_condition, when_command, monitor_command, complete_action, say_command } from "./commands.genie.out";
export { forward_get_do_command, backward_get_do_command, forward_when_do_rule, backward_when_do_rule, when_get_stream, when_get_do_rule, timer_rule, generic_preamble_for_answer, generic_preamble_for_action, generic_verb_for_search, imperative_verb_for_search, generic_search_preamble, generic_lookup_preamble, generic_article, search_command, complete_question, projection_question, explicit_when_condition, when_command, monitor_command, complete_action, say_command };
import { $load as $load___stream_tables,complete_table, complete_get_command, if_filtered_table, one_if_filter_table, two_if_filter_table, answer_noun_phrase, one_with_filter_table, one_which_filter_table, one_clean_filter_table, two_with_filter_table, two_which_filter_table, two_clean_filter_table, three_with_filter_table, three_which_filter_table, three_clean_filter_table, anything_phrase, anything_with_filter_phrase, anything_which_filter_phrase, anything_clean_filter_phrase, verb_filtered_table, one_be_filter_table, one_have_filter_table, one_verb_filter_table, two_be_filter_table, two_have_filter_table, two_verb_filter_table, generic_argminmax, have_arg_min_max_table, edge_stream, stream, with_filtered_table_join, have_filtered_table_join } from "./stream_tables.genie.out";
export { complete_table, complete_get_command, if_filtered_table, one_if_filter_table, two_if_filter_table, answer_noun_phrase, one_with_filter_table, one_which_filter_table, one_clean_filter_table, two_with_filter_table, two_which_filter_table, two_clean_filter_table, three_with_filter_table, three_which_filter_table, three_clean_filter_table, anything_phrase, anything_with_filter_phrase, anything_which_filter_phrase, anything_clean_filter_phrase, verb_filtered_table, one_be_filter_table, one_have_filter_table, one_verb_filter_table, two_be_filter_table, two_have_filter_table, two_verb_filter_table, generic_argminmax, have_arg_min_max_table, edge_stream, stream, with_filtered_table_join, have_filtered_table_join };
import { $load as $load___joins,short_phrase_table, out_param_symmetric, self_join_table, generic_join_table } from "./joins.genie.out";
export { short_phrase_table, out_param_symmetric, self_join_table, generic_join_table };
import { $load as $load___verification,boolean_question } from "./verification.genie.out";
export { boolean_question };
import { $load as $load___qualifier, } from "./qualifier.genie.out";
export {  };
import { $load as $load___wikidata, } from "./wikidata.genie.out";
export {  };
export const $root : $SentenceGeneratorTypes.NonTerminal<Ast.Input> = "$root";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   await $load___shared($options, $locale, $grammar, $loader);
   await $load___constants($options, $locale, $grammar, $loader);
   await $load___timers($options, $locale, $grammar, $loader);
   await $load___filters($options, $locale, $grammar, $loader);
   await $load___projections($options, $locale, $grammar, $loader);
   await $load___aggregation($options, $locale, $grammar, $loader);
   await $load___computation($options, $locale, $grammar, $loader);
   await $load___who_questions($options, $locale, $grammar, $loader);
   await $load___commands($options, $locale, $grammar, $loader);
   await $load___stream_tables($options, $locale, $grammar, $loader);
   await $load___joins($options, $locale, $grammar, $loader);
   await $load___verification($options, $locale, $grammar, $loader);
   await $load___qualifier($options, $locale, $grammar, $loader);
   await $load___wikidata($options, $locale, $grammar, $loader);
   $grammar.declareSymbol("$root");
   $grammar.addRule("$root", [new $runtime.NonTerminal("thingpedia_complete_program", "p", undefined)], "${p}", ((p : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, p)), undefined, {  });
   if (!$options.flags.nostream) {
       if ($options.flags.timer) {
           $grammar.addRule("$root", [new $runtime.NonTerminal("timer_rule", "stmt", undefined)], "${stmt}", ((stmt : Ast.ChainExpression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, { weight: (0.2) });
       }
       $grammar.addRule("$root", [new $runtime.NonTerminal("monitor_command", "stmt", undefined)], "${stmt}", ((stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, { weight: (0.2) });
       $grammar.addRule("$root", [new $runtime.NonTerminal("when_command", "stmt", undefined)], "${stmt}", ((stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, { weight: (0.2) });
   }
   $grammar.addRule("$root", [new $runtime.NonTerminal("say_command", "stmt", undefined)], "${stmt}", ((stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, { weight: (0.1) });
   $grammar.addRule("$root", [new $runtime.NonTerminal("complete_action", "stmt", undefined)], "${stmt}", ((stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, {  });
   $grammar.addRule("$root", [new $runtime.NonTerminal("generic_preamble_for_action", undefined, undefined), new $runtime.NonTerminal("complete_action", "stmt", undefined)], $locale._("${generic_preamble_for_action} ${stmt}"), (($0 : string, stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, {  });
   $grammar.addRule("$root", [new $runtime.NonTerminal("generic_preamble_for_action", undefined, undefined), new $runtime.NonTerminal("forward_get_do_command", "stmt", undefined)], $locale._("${generic_preamble_for_action} ${stmt}"), (($0 : string, stmt : Ast.ChainExpression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, {  });
   $grammar.addRule("$root", [new $runtime.NonTerminal("backward_get_do_command", "stmt", undefined)], "${stmt}", ((stmt : Ast.ChainExpression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, { weight: (0.1) });
   $grammar.addRule("$root", [new $runtime.NonTerminal("search_command", "stmt", undefined)], "${stmt}", ((stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, {  });
   $grammar.addRule("$root", [new $runtime.NonTerminal("complete_question", "stmt", undefined)], "${stmt}", ((stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, {  });
   $grammar.addRule("$root", [new $runtime.NonTerminal("projection_question", "stmt", undefined)], "${stmt}", ((stmt : Ast.Expression) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, {  });
   $grammar.addRule("$root", [new $runtime.NonTerminal("boolean_question", "stmt", undefined)], "${stmt}", ((stmt : any) : (Ast.Input)|null => C.makeProgram($loader, stmt)), undefined, { weight: (0.2) });
};
