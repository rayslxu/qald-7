// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

import * as $runtime from "../sentence-generator/runtime";
import type $SentenceGenerator from "../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../sentence-generator/types";
import * as $I18n from "../i18n/index";
import { Ast, Type } from 'thingtalk';
import * as C from './ast_manip';
import ThingpediaLoader from './load-thingpedia';
export const forward_get_do_command : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "forward_get_do_command";
export const backward_get_do_command : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "backward_get_do_command";
export const forward_when_do_rule : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "forward_when_do_rule";
export const backward_when_do_rule : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "backward_when_do_rule";
export const when_get_stream : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "when_get_stream";
export const when_get_do_rule : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "when_get_do_rule";
export const timer_rule : $SentenceGeneratorTypes.NonTerminal<Ast.ChainExpression> = "timer_rule";
export const generic_preamble_for_answer : $SentenceGeneratorTypes.NonTerminal<string> = "generic_preamble_for_answer";
export const generic_preamble_for_action : $SentenceGeneratorTypes.NonTerminal<string> = "generic_preamble_for_action";
export const generic_verb_for_search : $SentenceGeneratorTypes.NonTerminal<string> = "generic_verb_for_search";
export const imperative_verb_for_search : $SentenceGeneratorTypes.NonTerminal<string> = "imperative_verb_for_search";
export const generic_search_preamble : $SentenceGeneratorTypes.NonTerminal<string> = "generic_search_preamble";
export const generic_lookup_preamble : $SentenceGeneratorTypes.NonTerminal<string> = "generic_lookup_preamble";
export const generic_article : $SentenceGeneratorTypes.NonTerminal<string> = "generic_article";
export const search_command : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "search_command";
export const complete_question : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "complete_question";
export const projection_question : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "projection_question";
export const explicit_when_condition : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "explicit_when_condition";
export const when_command : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "when_command";
export const monitor_command : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "monitor_command";
export const complete_action : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "complete_action";
export const say_command : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "say_command";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   $grammar.declareSymbol("forward_get_do_command");
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("if_filtered_table", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{get|take|retrieve} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("complete_get_command", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {and then|then|,} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("after {you get|taking|getting|retrieving} ${table} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{get|take|retrieve} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("projection_Any", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{get|take|retrieve} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("projection_Any", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("after {you get|taking|getting|retrieving} ${table} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("if_filtered_table", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{get|take|retrieve} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("complete_get_command", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${table} {and then|then|,} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("after {you get|taking|getting|retrieving} ${table} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{get|take|retrieve} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("forward_get_do_command", [new $runtime.NonTerminal("forward_get_do_command", "command", undefined), new $runtime.NonTerminal("out_param_Any", "joinArg", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${command} {with the same|with identical|using the same} ${joinArg}"), ((command : Ast.ChainExpression, joinArg : C.ParamSlot) : (Ast.ChainExpression)|null => C.addSameNameParameterPassing($loader, command, joinArg)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("backward_get_do_command");
   $grammar.addRule("backward_get_do_command", [new $runtime.NonTerminal("action_coref_same_sentence", "action", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void)])], $locale._("${action} after {getting|taking|you get|you retrieve} ${table}"), ((action : C.ExpressionWithCoreference, table : Ast.Expression) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("backward_get_do_command", [new $runtime.NonTerminal("action_coref_same_sentence", "action", undefined), new $runtime.NonTerminal("projection_Any", "table", ["projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void)])], $locale._("${action} after {getting|taking|you get|you retrieve} ${table}"), ((action : C.ExpressionWithCoreference, table : Ast.Expression) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.addRule("backward_get_do_command", [new $runtime.NonTerminal("action_coref_same_sentence", "action", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void)])], $locale._("${action} after {getting|taking|you get|you retrieve} ${table}"), ((action : C.ExpressionWithCoreference, table : Ast.Expression) : (Ast.ChainExpression)|null => C.addParameterPassing(table, action)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("forward_when_do_rule");
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("complete_action", "action", undefined)], $locale._("${stream} ${action}"), ((stream : Ast.Expression, action : Ast.Expression) : (Ast.ChainExpression)|null => C.makeChainExpression(stream, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("complete_action", "action", undefined), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${stream} ${action} if ${filter}"), ((stream : Ast.Expression, action : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.ChainExpression)|null => {
        const newStream = C.addFilter($loader, stream, filter);
        if (!newStream)
            return null;
        return C.makeChainExpression(newStream, action);
    }), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${stream} ${action}"), ((stream : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(stream, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${stream} ${action}"), ((stream : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(stream, action)), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{monitor|watch} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.whenDoRule(table, action, { monitorItemID: false })), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("projection_Any", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{monitor|watch} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.whenDoRule(table, action, { monitorItemID: false })), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("projection_Any", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{monitor|watch} ${table} {and then|then} ${action}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.whenDoRule(table, action, { monitorItemID: false })), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{check for new ${table} {and then|then} ${action}|when there are new ${table} ${action}}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.whenDoRule(table, action, { monitorItemID: true })), C.expressionKeyFn, {  });
   $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("projection_Any", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("action_coref_same_sentence", "action", ["corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{check for new ${table} {and then|then} ${action}|when there are new ${table} ${action}}"), ((table : Ast.Expression, action : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.whenDoRule(table, action, { monitorItemID: true })), C.expressionKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("forward_when_do_rule", [new $runtime.NonTerminal("forward_when_do_rule", "rule", undefined), new $runtime.NonTerminal("out_param_Any", "joinArg", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${rule} {with the same|with identical|using the same} ${joinArg}"), ((rule : Ast.ChainExpression, joinArg : C.ParamSlot) : (Ast.ChainExpression)|null => C.addSameNameParameterPassing($loader, rule, joinArg)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("backward_when_do_rule");
   $grammar.addRule("backward_when_do_rule", [new $runtime.NonTerminal("complete_action", "action", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${action} ${stream}"), ((action : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.makeChainExpression(stream, action)), C.expressionKeyFn, {  });
   $grammar.addRule("backward_when_do_rule", [new $runtime.NonTerminal("action_coref_same_sentence", "action", undefined), new $runtime.NonTerminal("stream", "stream", ["implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void)])], $locale._("${action} ${stream}"), ((action : C.ExpressionWithCoreference, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.addParameterPassing(stream, action)), C.expressionKeyFn, {  });
   $grammar.addRule("backward_when_do_rule", [new $runtime.NonTerminal("action_coref_same_sentence", "action", undefined), new $runtime.NonTerminal("stream", "stream", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void)])], $locale._("${action} ${stream}"), ((action : C.ExpressionWithCoreference, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.addParameterPassing(stream, action)), C.expressionKeyFn, {  });
   $grammar.addRule("backward_when_do_rule", [new $runtime.NonTerminal("action_coref_same_sentence", "action", undefined), new $runtime.NonTerminal("complete_table", "table", ["implicitParamPassingType" as ("implicitParamPassingType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "corefType" as ("corefType" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void)])], $locale._("${action} {when there are new|after checking for new} ${table}"), ((action : C.ExpressionWithCoreference, table : Ast.Expression) : (Ast.ChainExpression)|null => C.whenDoRule(table, action, { monitorItemID: true })), C.expressionKeyFn, {  });
   $grammar.addRule("backward_when_do_rule", [new $runtime.NonTerminal("action_coref_same_sentence", "action", undefined), new $runtime.NonTerminal("complete_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "corefFunctionName" as ("corefFunctionName" extends keyof ReturnType<typeof C.expressionWithCoreferenceKeyFn> ? string : void)])], $locale._("${action} {when there are new|after checking for new} ${table}"), ((action : C.ExpressionWithCoreference, table : Ast.Expression) : (Ast.ChainExpression)|null => C.whenDoRule(table, action, { monitorItemID: true })), C.expressionKeyFn, {  });
   $grammar.declareSymbol("when_get_stream");
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("complete_get_command", "table", undefined)], $locale._("${stream} ${table}"), ((stream : Ast.Expression, table : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("imperative_verb_for_search", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${stream} ${imperative_verb_for_search} ${table}"), ((stream : Ast.Expression, $0 : string, table : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${stream} ${generic_verb_for_search} ${table}"), ((stream : Ast.Expression, $0 : string, table : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("imperative_verb_for_search", undefined, undefined), new $runtime.NonTerminal("projection_Any", "table", undefined)], $locale._("${stream} ${imperative_verb_for_search} {|what is} ${table}"), ((stream : Ast.Expression, $0 : string, table : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("projection_Any", "table", undefined)], $locale._("${stream} ${generic_verb_for_search} {|what is} ${table}"), ((stream : Ast.Expression, $0 : string, table : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("complete_get_command", "table", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${table} ${stream}"), ((table : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("imperative_verb_for_search", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${imperative_verb_for_search} ${table} ${stream}"), (($0 : string, table : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${generic_verb_for_search} ${table} ${stream}"), (($0 : string, table : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${generic_preamble_for_answer} ${table} ${stream}"), (($0 : string, table : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("imperative_verb_for_search", undefined, undefined), new $runtime.NonTerminal("projection_Any", "table", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${imperative_verb_for_search} ${table} ${stream}"), (($0 : string, table : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("projection_Any", "table", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${generic_verb_for_search} ${table} ${stream}"), (($0 : string, table : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("projection_Any", "table", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${generic_preamble_for_answer} ${table} ${stream}"), (($0 : string, table : Ast.Expression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamQuery($loader, stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("get_command_coref_same_sentence", "table", undefined)], $locale._("${stream} ${table}"), ((stream : Ast.Expression, table : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("imperative_verb_for_search", undefined, undefined), new $runtime.NonTerminal("query_coref_same_sentence", "table", undefined)], $locale._("${stream} ${imperative_verb_for_search} ${table}"), ((stream : Ast.Expression, $0 : string, table : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(stream, table)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_stream", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("query_coref_same_sentence", "table", undefined)], $locale._("${stream} ${generic_verb_for_search} ${table}"), ((stream : Ast.Expression, $0 : string, table : C.ExpressionWithCoreference) : (Ast.ChainExpression)|null => C.addParameterPassing(stream, table)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("when_get_do_rule");
   $grammar.addRule("when_get_do_rule", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("forward_get_do_command", "command", undefined)], $locale._("${stream} ${command}"), ((stream : Ast.Expression, command : Ast.ChainExpression) : (Ast.ChainExpression)|null => C.combineStreamCommand(stream, command)), C.expressionKeyFn, {  });
   $grammar.addRule("when_get_do_rule", [new $runtime.NonTerminal("forward_get_do_command", "command", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("${command} ${stream}"), ((command : Ast.ChainExpression, stream : Ast.Expression) : (Ast.ChainExpression)|null => C.combineStreamCommand(stream, command)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("timer_rule");
   $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined), new $runtime.NonTerminal("complete_get_command", "table", undefined)], $locale._("${timer} ${table}"), ((timer : Ast.FunctionCallExpression, table : Ast.Expression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, table)), C.expressionKeyFn, {  });
   $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined), new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${timer} ${generic_verb_for_search} ${table}"), ((timer : Ast.FunctionCallExpression, $0 : string, table : Ast.Expression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, table)), C.expressionKeyFn, {  });
   $grammar.addRule("timer_rule", [new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("timer", "timer", undefined)], $locale._("${generic_verb_for_search} ${table} ${timer}"), (($0 : string, table : Ast.Expression, timer : Ast.FunctionCallExpression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, table)), C.expressionKeyFn, {  });
   $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${timer} {tell me|give me|show me|present|retrieve|pull up} ${table}"), ((timer : Ast.FunctionCallExpression, table : Ast.Expression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, table)), C.expressionKeyFn, {  });
   $grammar.addRule("timer_rule", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("timer", "timer", undefined)], $locale._("{tell me|give me|show me|present|retrieve|pull up} ${table} ${timer}"), ((table : Ast.Expression, timer : Ast.FunctionCallExpression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, table)), C.expressionKeyFn, {  });
   $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined), new $runtime.NonTerminal("complete_action", "action", undefined)], $locale._("${timer} ${action}"), ((timer : Ast.FunctionCallExpression, action : Ast.Expression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, action)), C.expressionKeyFn, {  });
   $grammar.addRule("timer_rule", [new $runtime.NonTerminal("generic_preamble_for_action", undefined, undefined), new $runtime.NonTerminal("complete_action", "action", undefined), new $runtime.NonTerminal("timer", "timer", undefined)], $locale._("${generic_preamble_for_action} ${action} ${timer}"), (($0 : string, action : Ast.Expression, timer : Ast.FunctionCallExpression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, action)), C.expressionKeyFn, {  });
   if (!$options.flags.primonly) {
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined), new $runtime.NonTerminal("forward_get_do_command", "command", undefined)], $locale._("${timer} ${command}"), ((timer : Ast.FunctionCallExpression, command : Ast.ChainExpression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, command)), C.expressionKeyFn, {  });
   }
   if (!$options.flags.primonly) {
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("forward_get_do_command", "command", undefined), new $runtime.NonTerminal("timer", "timer", undefined)], $locale._("${command} ${timer}"), ((command : Ast.ChainExpression, timer : Ast.FunctionCallExpression) : (Ast.ChainExpression)|null => C.makeChainExpression(timer, command)), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("generic_preamble_for_answer");
   $grammar.addRule("generic_preamble_for_answer", [], $locale._("i am looking for"), (() : (string)|null => "i am looking for"), undefined, { identity: (true) });
   $grammar.addRule("generic_preamble_for_answer", [], $locale._("i would like"), (() : (string)|null => "i would like"), undefined, { identity: (true) });
   $grammar.addRule("generic_preamble_for_answer", [], $locale._("i want"), (() : (string)|null => "i want"), undefined, { identity: (true) });
   $grammar.addRule("generic_preamble_for_answer", [], $locale._("i need"), (() : (string)|null => "i need"), undefined, { identity: (true) });
   $grammar.declareSymbol("generic_preamble_for_action");
   $grammar.addRule("generic_preamble_for_action", [], $locale._("i am looking to"), (() : (string)|null => "i am looking to"), undefined, { identity: (true) });
   $grammar.addRule("generic_preamble_for_action", [], $locale._("i would like to"), (() : (string)|null => "i would like to"), undefined, { identity: (true) });
   $grammar.addRule("generic_preamble_for_action", [], $locale._("i want to"), (() : (string)|null => "i want to"), undefined, { identity: (true) });
   $grammar.addRule("generic_preamble_for_action", [], $locale._("i need to"), (() : (string)|null => "i need to"), undefined, { identity: (true) });
   $grammar.addRule("generic_preamble_for_action", [], $locale._("please"), (() : (string)|null => "please"), undefined, { identity: (true) });
   $grammar.declareSymbol("generic_verb_for_search");
   $grammar.addRule("generic_verb_for_search", [], $locale._("search for"), (() : (string)|null => "search for"), undefined, { identity: (true) });
   $grammar.addRule("generic_verb_for_search", [], $locale._("search"), (() : (string)|null => "search"), undefined, { identity: (true) });
   $grammar.addRule("generic_verb_for_search", [], $locale._("find"), (() : (string)|null => "find"), undefined, { identity: (true) });
   $grammar.addRule("generic_verb_for_search", [], $locale._("get"), (() : (string)|null => "get"), undefined, { identity: (true) });
   $grammar.addRule("generic_verb_for_search", [], $locale._("retrieve"), (() : (string)|null => "retrieve"), undefined, { identity: (true) });
   $grammar.declareSymbol("imperative_verb_for_search");
   $grammar.addRule("imperative_verb_for_search", [], $locale._("show me"), (() : (string)|null => "show me"), undefined, { identity: (true) });
   $grammar.addRule("imperative_verb_for_search", [], $locale._("tell me"), (() : (string)|null => "tell me"), undefined, { identity: (true) });
   $grammar.addRule("imperative_verb_for_search", [], $locale._("give me"), (() : (string)|null => "give me"), undefined, { identity: (true) });
   $grammar.addRule("imperative_verb_for_search", [], $locale._("find me"), (() : (string)|null => "find me"), undefined, { identity: (true) });
   $grammar.declareSymbol("generic_search_preamble");
   $grammar.addRule("generic_search_preamble", [], $locale._("search"), (() : (string)|null => "search"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("find"), (() : (string)|null => "find"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("get"), (() : (string)|null => "get"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("show me"), (() : (string)|null => "show me"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("give me"), (() : (string)|null => "give me"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("find me"), (() : (string)|null => "find me"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i want"), (() : (string)|null => "i want"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i need"), (() : (string)|null => "i need"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i am looking for"), (() : (string)|null => "i am looking for"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i am looking for a particular"), (() : (string)|null => "i am looking for a particular"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i am looking for a certain"), (() : (string)|null => "i am looking for a certain"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i would like"), (() : (string)|null => "i would like"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i need"), (() : (string)|null => "i need"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i need some information about"), (() : (string)|null => "i need some information about"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i would like information about"), (() : (string)|null => "i would like information about"), undefined, { identity: (true) });
   $grammar.addRule("generic_search_preamble", [], $locale._("i would like to hear about"), (() : (string)|null => "i would like to hear about"), undefined, { identity: (true) });
   $grammar.declareSymbol("generic_lookup_preamble");
   $grammar.addRule("generic_lookup_preamble", [], $locale._("show me"), (() : (string)|null => "show me"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("tell me"), (() : (string)|null => "tell me"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("give me"), (() : (string)|null => "give me"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("find me"), (() : (string)|null => "find me"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("search"), (() : (string)|null => "search"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("find"), (() : (string)|null => "find"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("i want to know"), (() : (string)|null => "i want to know"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("i need to know"), (() : (string)|null => "i need to know"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("i am looking for"), (() : (string)|null => "i am looking for"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("i would like to know"), (() : (string)|null => "i would like to know"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("i would like"), (() : (string)|null => "i would like"), undefined, { identity: (true) });
   $grammar.addRule("generic_lookup_preamble", [], $locale._("i need"), (() : (string)|null => "i need"), undefined, { identity: (true) });
   $grammar.declareSymbol("generic_article");
   $grammar.addRule("generic_article", [], $locale._("a"), (() : (string)|null => "a"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("an"), (() : (string)|null => "an"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("the"), (() : (string)|null => "the"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("some"), (() : (string)|null => "some"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("any"), (() : (string)|null => "any"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("all"), (() : (string)|null => "all"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("all the"), (() : (string)|null => "all the"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("every"), (() : (string)|null => "every"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("a list of"), (() : (string)|null => "a list of"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("a list of all"), (() : (string)|null => "a list of all"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("the list of"), (() : (string)|null => "the list of"), undefined, { identity: (true) });
   $grammar.addRule("generic_article", [], $locale._("the list of all"), (() : (string)|null => "the list of all"), undefined, { identity: (true) });
   $grammar.declareSymbol("search_command");
   $grammar.addRule("search_command", [new $runtime.NonTerminal("complete_get_command", "table", undefined)], "${table}", ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("get ${generic_article} ${table}"), (($0 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${generic_preamble_for_answer} ${generic_article} ${table}"), (($0 : string, $1 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${generic_verb_for_search} ${generic_article} ${table}"), (($0 : string, $1 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_preamble_for_action", undefined, undefined), new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${generic_preamble_for_action} ${generic_verb_for_search} ${generic_article} ${table}"), (($0 : string, $1 : string, $2 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]])], $locale._("{please|} {list|enumerate} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${generic_preamble_for_answer} ${generic_article} ${table}"), (($0 : string, $1 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${generic_verb_for_search} ${generic_article} ${table}"), (($0 : string, $1 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_preamble_for_action", undefined, undefined), new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("${generic_preamble_for_action} ${generic_verb_for_search} ${generic_article} ${table}"), (($0 : string, $1 : string, $2 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", undefined)], $locale._("${generic_preamble_for_answer} the ${table}"), (($0 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", undefined)], $locale._("${generic_verb_for_search} the ${table}"), (($0 : string, table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_lookup_preamble", undefined, undefined), new $runtime.NonTerminal("projection_Any", "proj", undefined)], $locale._("${generic_lookup_preamble} ${proj}"), (($0 : string, proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, { weight: (0.45) });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("projection_Any", "proj", undefined)], $locale._("{show me|tell me} what is ${proj}"), ((proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, { weight: (0.45) });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_lookup_preamble", undefined, undefined), new $runtime.NonTerminal("pair_projection", "proj", undefined)], $locale._("${generic_lookup_preamble} ${proj}"), (($0 : string, proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, { weight: (0.1) });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("generic_lookup_preamble", undefined, undefined), new $runtime.NonTerminal("command_projection_table", "proj", undefined)], $locale._("${generic_lookup_preamble} ${proj}"), (($0 : string, proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, {  });
   $grammar.addRule("search_command", [new $runtime.NonTerminal("command_projection_table", "proj", undefined)], $locale._("{show me|tell me} what is the ${proj}"), ((proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("complete_question");
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("verb_filtered_table", "table", undefined)], $locale._("{what|which} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_be_filter_table", "table", undefined)], $locale._("{what|which} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_have_filter_table", "table", undefined)], $locale._("{what|which} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_verb_filter_table", "table", undefined)], $locale._("{what|which} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_be_filter_table", "table", undefined)], $locale._("{what|which} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_have_filter_table", "table", undefined)], $locale._("{what|which} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_verb_filter_table", "table", undefined)], $locale._("{what|which} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("{is|are} there {any|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_with_filter_table", "table", undefined)], $locale._("{is|are} there {any|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_which_filter_table", "table", undefined)], $locale._("{is|are} there {any|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("one_clean_filter_table", "table", undefined)], $locale._("{is|are} there {any|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_with_filter_table", "table", undefined)], $locale._("{is|are} there {any|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_which_filter_table", "table", undefined)], $locale._("{is|are} there {any|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("two_clean_filter_table", "table", undefined)], $locale._("{is|are} there {any|} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("with_filtered_table_join", "table", undefined)], $locale._("{what|which} {are|is} {the|} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("have_filtered_table_join", "table", undefined)], $locale._("{what|which} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("with_arg_min_max_table", "table", undefined)], $locale._("{what|which} is the ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("have_arg_min_max_table", "table", undefined)], $locale._("{which|what} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_verb_filtered_table", "table", undefined)], $locale._("{who|which person|which individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_be_filter_table", "table", undefined)], $locale._("{who|which person|which individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_have_filter_table", "table", undefined)], $locale._("{who|which person|which individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_verb_filter_table", "table", undefined)], $locale._("{who|which person|which individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_be_filter_table", "table", undefined)], $locale._("{who|which person|which individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_have_filter_table", "table", undefined)], $locale._("{who|which person|which individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_verb_filter_table", "table", undefined)], $locale._("{who|which person|which individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_with_filtered_table", "table", undefined)], $locale._("{who is the person|who is the one|who is the individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_with_filter_table", "table", undefined)], $locale._("{who is the person|who is the one|who is the individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_which_filter_table", "table", undefined)], $locale._("{who is the person|who is the one|who is the individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_clean_filter_table", "table", undefined)], $locale._("{who is the person|who is the one|who is the individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_with_filter_table", "table", undefined)], $locale._("{who is the person|who is the one|who is the individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_which_filter_table", "table", undefined)], $locale._("{who is the person|who is the one|who is the individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_clean_filter_table", "table", undefined)], $locale._("{who is the person|who is the one|who is the individual} ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("whose_filtered_table", "table", undefined)], $locale._("whose ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_verb_filtered_table", "table", undefined)], $locale._("who ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_be_filter_table", "table", undefined)], $locale._("who ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_have_filter_table", "table", undefined)], $locale._("who ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_one_verb_filter_table", "table", undefined)], $locale._("who ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_be_filter_table", "table", undefined)], $locale._("who ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_have_filter_table", "table", undefined)], $locale._("who ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("who_two_verb_filter_table", "table", undefined)], $locale._("who ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   if ($options.flags.turking) {
       $grammar.addRule("complete_question", [new $runtime.NonTerminal("whose_filtered_table", "table", undefined)], $locale._("whose ${table} ?"), ((table : Ast.Expression) : (Ast.Expression)|null => table), C.expressionKeyFn, {  });
   }
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("compute_question", undefined, undefined)], "${compute_question}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("complete_question", [new $runtime.NonTerminal("where_question", undefined, undefined)], "${where_question}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.declareSymbol("projection_question");
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("projection_Any", "proj", undefined)], $locale._("what is ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && proj.schema!.getArgType(proj.args[0]) instanceof Type.Array)
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, {  });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("pair_projection", "proj", undefined)], $locale._("what is ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && proj.schema!.getArgType(proj.args[0]) instanceof Type.Array)
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, { weight: (0.1) });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("projection_Any", "proj", ["projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((new Type.Entity('tt:username'))) as ReturnType<typeof C.expressionKeyFn>["projectionType"]])], $locale._("who is ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && proj.schema!.getArgType(proj.args[0]) instanceof Type.Array)
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, {  });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("projection_Any", "proj", ["projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((new Type.Entity('tt:email_address'))) as ReturnType<typeof C.expressionKeyFn>["projectionType"]])], $locale._("who is ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && proj.schema!.getArgType(proj.args[0]) instanceof Type.Array)
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, {  });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("projection_Any", "proj", undefined)], $locale._("what are ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && !(proj.schema!.getArgType(proj.args[0]) instanceof Type.Array))
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, {  });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("pair_projection", "proj", undefined)], $locale._("what are ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && !(proj.schema!.getArgType(proj.args[0]) instanceof Type.Array))
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, { weight: (0.1) });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("projection_Any", "proj", ["projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((new Type.Entity('tt:username'))) as ReturnType<typeof C.expressionKeyFn>["projectionType"]])], $locale._("who are ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && !(proj.schema!.getArgType(proj.args[0]) instanceof Type.Array))
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, {  });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("projection_Any", "proj", ["projectionType" as ("projectionType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((new Type.Entity('tt:email_address'))) as ReturnType<typeof C.expressionKeyFn>["projectionType"]])], $locale._("who are ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => {
        if (proj instanceof Ast.ProjectionExpression && !(proj.schema!.getArgType(proj.args[0]) instanceof Type.Array))
            return null;
        return C.sayProjection($loader, proj);
    }), C.expressionKeyFn, {  });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("verb_projection_Any", "proj", undefined)], $locale._("{what|which} ${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, {  });
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("question_projection_table", "proj", undefined)], $locale._("${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, {  });
   if ($options.flags.turking) {
       $grammar.addRule("projection_question", [new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("where is the ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, C.makeSingleFieldProjection($loader, 'table', Type.Location, table, 'geo'))), C.expressionKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("projection_question", [new $runtime.NonTerminal("with_filtered_table", "table", undefined)], $locale._("where {is|are} {|the} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, C.makeSingleFieldProjection($loader, 'table', Type.Location, table, 'geo'))), C.expressionKeyFn, {  });
   }
   $grammar.addRule("projection_question", [new $runtime.NonTerminal("boolean_projection", "proj", undefined)], $locale._("${proj} ?"), ((proj : Ast.Expression) : (Ast.Expression)|null => C.sayProjection($loader, proj)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("explicit_when_condition");
   $grammar.addRule("explicit_when_condition", [new $runtime.NonTerminal("complete_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{if|when} ${filter} in ${table}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => {
        if (C.hasExistentialSubquery(filter.ast))
            return null;
        if (!table.schema!.is_monitorable)
            return null;
        if ($loader.flags.turking && table.schema!.is_list)
            return null;
        const withFilter = C.addFilter($loader, table, filter, { ifFilter: true });
        if (!withFilter)
            return null;
        return C.tableToStream(withFilter, { monitorItemID : false });
    }), C.expressionKeyFn, {  });
   $grammar.addRule("explicit_when_condition", [new $runtime.NonTerminal("complete_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("edge_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{if|when} ${filter} in ${table}"), ((table : Ast.Expression, filter : C.FilterSlot) : (Ast.Expression)|null => {
        if (C.hasExistentialSubquery(filter.ast))
            return null;
        if (!table.schema!.is_monitorable || table.schema!.is_list)
            return null;
        const withFilter = C.addFilter($loader, table, filter, { ifFilter: true });
        if (!withFilter)
            return null;
        return C.tableToStream(withFilter, { monitorItemID : false });
    }), C.expressionKeyFn, {  });
   $grammar.declareSymbol("when_command");
   $grammar.addRule("when_command", [new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("notify me ${stream}"), ((stream : Ast.Expression) : (Ast.Expression)|null => stream), C.expressionKeyFn, {  });
   $grammar.addRule("when_command", [new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("{alert me|inform me|let me know|i get notified|i get alerted} ${stream}"), ((stream : Ast.Expression) : (Ast.Expression)|null => stream), C.expressionKeyFn, {  });
   $grammar.addRule("when_command", [new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("send me {a message|an alert|a notification|a pop up notification|a popup notification} ${stream}"), ((stream : Ast.Expression) : (Ast.Expression)|null => stream), C.expressionKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("when_command", [new $runtime.NonTerminal("projection_Any", "proj", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{let me know|notify me} {of|about} {changes|updates} in ${proj}"), ((proj : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(proj, { monitorItemID : false })), C.expressionKeyFn, {  });
   }
   if (!$options.flags.nofilter) {
       $grammar.addRule("when_command", [new $runtime.NonTerminal("explicit_when_condition", "stream", undefined)], $locale._("{alert me|tell me|notify me|let me know} ${stream}"), ((stream : Ast.Expression) : (Ast.Expression)|null => stream), C.expressionKeyFn, {  });
   }
   if (!$options.flags.primonly) {
       $grammar.addRule("when_command", [new $runtime.NonTerminal("when_get_stream", undefined, undefined)], "${when_get_stream}", (($0 : Ast.ChainExpression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
       $grammar.addRule("when_command", [new $runtime.NonTerminal("forward_when_do_rule", undefined, undefined)], "${forward_when_do_rule}", (($0 : Ast.ChainExpression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
       $grammar.addRule("when_command", [new $runtime.NonTerminal("backward_when_do_rule", undefined, undefined)], "${backward_when_do_rule}", (($0 : Ast.ChainExpression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
       if (!$options.flags.turking) {
           $grammar.addRule("when_command", [new $runtime.NonTerminal("action_replace_param_with_stream", "stmt", undefined)], $locale._("{auto|automatically|continuously} ${stmt}"), ((stmt : Ast.ChainExpression) : (Ast.Expression)|null => stmt), C.expressionKeyFn, {  });
       }
       if ($options.flags.turking) {
           $grammar.addRule("when_command", [new $runtime.NonTerminal("action_replace_param_with_stream", "stmt", undefined)], $locale._("automatically ${stmt}"), ((stmt : Ast.ChainExpression) : (Ast.Expression)|null => stmt), C.expressionKeyFn, {  });
       }
   }
   if ($options.flags.triple_commands) {
       $grammar.addRule("when_command", [new $runtime.NonTerminal("when_get_do_rule", undefined, undefined)], "${when_get_do_rule}", (($0 : Ast.ChainExpression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   }
   $grammar.declareSymbol("monitor_command");
   $grammar.addRule("monitor_command", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{monitor|watch} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(table, { monitorItemID : false })), C.expressionKeyFn, {  });
   $grammar.addRule("monitor_command", [new $runtime.NonTerminal("projection_Any", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{monitor|watch} ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(table, { monitorItemID : false })), C.expressionKeyFn, {  });
   $grammar.addRule("monitor_command", [new $runtime.NonTerminal("if_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{let me know|notify me} {of|about} {changes|updates} in ${table}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(table, { monitorItemID : false })), C.expressionKeyFn, {  });
   $grammar.addRule("monitor_command", [new $runtime.NonTerminal("if_filtered_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]])], $locale._("{let me know|notify me} {{of|about} new ${table}|when there are new ${table}}"), ((table : Ast.Expression) : (Ast.Expression)|null => C.tableToStream(table, { monitorItemID : true })), C.expressionKeyFn, {  });
   if (!$options.flags.nofilter) {
       $grammar.addRule("monitor_command", [new $runtime.NonTerminal("complete_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{monitor|watch} ${table} and {alert me|notify me|inform me|warn me} {if|when} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => {
            if (C.hasExistentialSubquery(filter.ast))
                return null;
            if (table.schema!.is_list || !table.schema!.is_monitorable)
                return null;
            const withFilter = C.addFilter($loader, table, filter);
            if (!withFilter)
                return null;
            return C.tableToStream(withFilter, { monitorItemID : true });
        }), C.expressionKeyFn, {  });
       $grammar.addRule("monitor_command", [new $runtime.NonTerminal("complete_table", "table", ["is_monitorable" as ("is_monitorable" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_monitorable"]]), new $runtime.NonTerminal("if_filter", "filter", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), (null) as ReturnType<typeof C.filterKeyFn>["functionName"]])], $locale._("{monitor|watch} ${table} and {alert me|notify me|inform me|warn me} {if|when} ${filter}"), ((table : Ast.Expression, filter : C.FilterSlot|C.DomainIndependentFilterSlot) : (Ast.Expression)|null => {
            if (C.hasExistentialSubquery(filter.ast))
                return null;
            if (table.schema!.is_list || !table.schema!.is_monitorable)
                return null;
            const withFilter = C.addFilter($loader, table, filter);
            if (!withFilter)
                return null;
            return C.tableToStream(withFilter, { monitorItemID : true });
        }), C.expressionKeyFn, {  });
   }
   $grammar.declareSymbol("complete_action");
   $grammar.addRule("complete_action", [new $runtime.NonTerminal("thingpedia_complete_action", undefined, undefined)], "${thingpedia_complete_action}", (($0 : Ast.Expression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("complete_action", [new $runtime.NonTerminal("action_replace_param_with_table", undefined, undefined)], "${action_replace_param_with_table}", (($0 : Ast.ChainExpression) : (Ast.Expression)|null => { return $0; }), C.expressionKeyFn, { identity: (true) });
   $grammar.addRule("complete_action", [new $runtime.NonTerminal("complete_action", "command", undefined), new $runtime.NonTerminal("preposition_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${command} ${param}"), ((command : Ast.Expression, param : C.InputParamSlot) : (Ast.Expression)|null => C.addActionInputParam($loader, command, param)), C.expressionKeyFn, {  });
   $grammar.addRule("complete_action", [new $runtime.NonTerminal("complete_action", "command", undefined), new $runtime.NonTerminal("npp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${command} {with|having} ${param}"), ((command : Ast.Expression, param : C.InputParamSlot) : (Ast.Expression)|null => C.addActionInputParam($loader, command, param)), C.expressionKeyFn, {  });
   $grammar.declareSymbol("say_command");
   if ($loader.standardSchemas.say) {
       $grammar.declareSymbol("timer_rule");
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined)], $locale._("send me a {reminder|message} ${timer}"), ((timer : Ast.FunctionCallExpression) : (Ast.ChainExpression)|null => C.makeReminder($loader, timer)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("constant_Date", "date", undefined)], $locale._("send me a {reminder|message} for ${date}"), ((date : Ast.Value) : (Ast.ChainExpression)|null => C.makeDateReminder($loader, date)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("constant_Measure_ms", "duration", undefined)], $locale._("send me a {reminder|message} in ${duration}"), ((duration : Ast.Value) : (Ast.ChainExpression)|null => C.makeDurationReminder($loader, duration)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined), new $runtime.NonTerminal("constant_String", "message", undefined)], $locale._("send me a {message|alert|notification|reminder|popup notification} ${timer} {saying|with the text} ${message}"), ((timer : Ast.FunctionCallExpression, message : Ast.Value) : (Ast.ChainExpression)|null => C.makeReminder($loader, timer, message)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("constant_Date", "date", undefined), new $runtime.NonTerminal("constant_String", "message", undefined)], $locale._("{{remind me|tell me to|send me an alert|send me a reminder} to ${message} {on|at} ${date}|{set an|} alarm at ${date} named ${message}}"), ((date : Ast.Value, message : Ast.Value) : (Ast.ChainExpression)|null => C.makeDateReminder($loader, date, message)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("constant_Measure_ms", "duration", undefined), new $runtime.NonTerminal("constant_String", "message", undefined)], $locale._("{{remind me|tell me|{set an|} alarm|send me an alert|send me a reminder} to ${message} in ${duration}|set a timer for ${duration} {named|saying|with the text} ${message}}"), ((duration : Ast.Value, message : Ast.Value) : (Ast.ChainExpression)|null => C.makeDurationReminder($loader, duration, message)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("timer", "timer", undefined)], $locale._("set a {timer|alarm} ${timer}"), ((timer : Ast.FunctionCallExpression) : (Ast.ChainExpression)|null => C.makeAlarm($loader, timer)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("constant_Date", "date", undefined)], $locale._("set a {alarm|timer} for ${date}"), ((date : Ast.Value) : (Ast.ChainExpression)|null => C.makeDateAlarm($loader, date)), C.expressionKeyFn, {  });
       $grammar.addRule("timer_rule", [new $runtime.NonTerminal("constant_Measure_ms", "duration", undefined)], $locale._("{set a|} {timer for|alarm in} ${duration}"), ((duration : Ast.Value) : (Ast.ChainExpression)|null => C.makeDurationAlarm($loader, duration)), C.expressionKeyFn, {  });
       $grammar.declareSymbol("when_command");
       if (!$options.flags.turking) {
           $grammar.addRule("when_command", [new $runtime.NonTerminal("stream", "stream", undefined), new $runtime.NonTerminal("constant_String", "constant", undefined)], $locale._("alert me ${stream} {saying|with the text} ${constant}"), ((stream : Ast.Expression, constant : Ast.Value) : (Ast.Expression)|null => C.makeChainExpression(stream, C.builtinSayAction($loader, constant)!)), C.expressionKeyFn, {  });
           $grammar.addRule("when_command", [new $runtime.NonTerminal("constant_String", "constant", undefined), new $runtime.NonTerminal("stream", "stream", undefined)], $locale._("show {the notification|the message|a popup notification that says|a popup containing} ${constant} ${stream}"), ((constant : Ast.Value, stream : Ast.Expression) : (Ast.Expression)|null => C.makeChainExpression(stream, C.builtinSayAction($loader, constant)!)), C.expressionKeyFn, {  });
       }
       $grammar.declareSymbol("say_command");
       $grammar.addRule("say_command", [new $runtime.NonTerminal("constant_String", "c", undefined)], $locale._("say ${c}"), ((c : Ast.Value) : (Ast.Expression)|null => C.builtinSayAction($loader, c)), C.expressionKeyFn, {  });
       $grammar.addRule("say_command", [new $runtime.NonTerminal("constant_String", "c", undefined)], $locale._("send me a message saying ${c}"), ((c : Ast.Value) : (Ast.Expression)|null => C.builtinSayAction($loader, c)), C.expressionKeyFn, {  });
       $grammar.addRule("say_command", [new $runtime.NonTerminal("constant_String", "c", undefined)], $locale._("show a popup that says ${c}"), ((c : Ast.Value) : (Ast.Expression)|null => C.builtinSayAction($loader, c)), C.expressionKeyFn, {  });
   }
};
