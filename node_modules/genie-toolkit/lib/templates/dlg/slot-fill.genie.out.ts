// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

// Slot fill templates: the agent asks a question, and the user replies
//
// There are two types slot-fill templates:
// - for searches: the agent is trying to add a filter
// - for actions/queries w/ parameters: the agent is trying to add a parameter

import * as $runtime from "../../sentence-generator/runtime";
import type $SentenceGenerator from "../../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../../sentence-generator/types";
import * as $I18n from "../../i18n/index";
import { Ast, Type } from 'thingtalk';
import * as C from '../ast_manip';
import ThingpediaLoader from '../load-thingpedia';
export const one_param_slot_fill_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "one_param_slot_fill_question";
export const two_param_slot_fill_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "two_param_slot_fill_question";
export const slot_fill_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "slot_fill_question";
export const imprecise_slot_fill_answer_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Value|C.InputParamSlot> = "imprecise_slot_fill_answer_phrase";
export const imprecise_slot_fill_coref_answer : $SentenceGeneratorTypes.NonTerminal<Ast.Value|C.InputParamSlot> = "imprecise_slot_fill_coref_answer";
export const imprecise_slot_fill_answer : $SentenceGeneratorTypes.NonTerminal<Ast.Value|C.InputParamSlot> = "imprecise_slot_fill_answer";
export const precise_slot_fill_answer : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "precise_slot_fill_answer";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   $grammar.declareSymbol("one_param_slot_fill_question");
   $grammar.addRule("one_param_slot_fill_question", [new $runtime.NonTerminal("thingpedia_slot_fill_question", "p", undefined)], $locale._("${p} ?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => [p]), C.paramArrayKeyFn, { priority: (0.1) });
   $grammar.addRule("one_param_slot_fill_question", [new $runtime.NonTerminal("input_param", "p", undefined), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined)], $locale._("what ${p} ${prefer_question_phrase} ?"), ((p : C.ParamSlot, $0 : string) : (C.ParamSlot[])|null => [p]), C.paramArrayKeyFn, {  });
   $grammar.addRule("one_param_slot_fill_question", [], $locale._("when would you like your reminder?"), (() : (C.ParamSlot[])|null => [{ schema: $loader.standardSchemas.ontimer, name: 'date', type: new Type.Array(Type.Date), filterable: false, symmetric: false, ast: new Ast.Value.VarRef('date') }]), C.paramArrayKeyFn, { priority: (0.2) });
   $grammar.addRule("one_param_slot_fill_question", [], $locale._("when would you like your reminder?"), (() : (C.ParamSlot[])|null => [{ schema: $loader.standardSchemas.attimer, name: 'time', type: new Type.Array(Type.Date), filterable: false, symmetric: false, ast: new Ast.Value.VarRef('date') }]), C.paramArrayKeyFn, { priority: (0.2) });
   $grammar.declareSymbol("two_param_slot_fill_question");
   $grammar.addRule("two_param_slot_fill_question", [new $runtime.NonTerminal("input_param", "p1", undefined), new $runtime.NonTerminal("input_param", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined)], $locale._("what ${p1} and ${p2} ${prefer_question_phrase} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot, $0 : string) : (C.ParamSlot[])|null => {
        if (p1.name === p2.name || !C.isSameFunction(p1.schema, p2.schema))
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_slot_fill_question", [new $runtime.NonTerminal("thingpedia_slot_fill_question", "p1", undefined), new $runtime.NonTerminal("input_param", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined)], $locale._("${p1} and what ${p2} ${prefer_question_phrase} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot, $0 : string) : (C.ParamSlot[])|null => {
        if (p1.name === p2.name || !C.isSameFunction(p1.schema, p2.schema))
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_slot_fill_question", [new $runtime.NonTerminal("input_param", "p1", undefined), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined), new $runtime.NonTerminal("thingpedia_slot_fill_question", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("what ${p1} ${prefer_question_phrase} and ${p2} ?"), ((p1 : C.ParamSlot, $0 : string, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p1.name === p2.name || !C.isSameFunction(p1.schema, p2.schema))
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("slot_fill_question");
   $grammar.addRule("slot_fill_question", [new $runtime.NonTerminal("one_param_slot_fill_question", undefined, undefined)], "${one_param_slot_fill_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { priority: (0.1), identity: (true) });
   if (!$options.flags.inference) {
       $grammar.addRule("slot_fill_question", [new $runtime.NonTerminal("two_param_slot_fill_question", undefined, undefined)], "${two_param_slot_fill_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { identity: (true) });
   }
   $grammar.declareSymbol("imprecise_slot_fill_answer_phrase");
   $grammar.addRule("imprecise_slot_fill_answer_phrase", [new $runtime.NonTerminal("constant_Any", "slot", undefined)], "${slot}", ((slot : Ast.Value) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_answer_phrase", [new $runtime.NonTerminal("npp_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_answer_phrase", [new $runtime.NonTerminal("apv_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_answer_phrase", [new $runtime.NonTerminal("pvp_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_answer_phrase", [new $runtime.NonTerminal("preposition_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.declareSymbol("imprecise_slot_fill_coref_answer");
   $grammar.addRule("imprecise_slot_fill_coref_answer", [new $runtime.NonTerminal("coref_constant", "slot", undefined)], "${slot}", ((slot : Ast.Value) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_coref_answer", [new $runtime.NonTerminal("coref_npp_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_coref_answer", [new $runtime.NonTerminal("coref_apv_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_coref_answer", [new $runtime.NonTerminal("coref_pvp_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_coref_answer", [new $runtime.NonTerminal("coref_preposition_input_param", "slot", undefined)], "${slot}", ((slot : C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => slot), undefined, {  });
   $grammar.declareSymbol("imprecise_slot_fill_answer");
   $grammar.addRule("imprecise_slot_fill_answer", [new $runtime.NonTerminal("imprecise_slot_fill_answer_phrase", "ans", undefined)], $locale._("${ans} {please|} ."), ((ans : Ast.Value|C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => ans), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_answer", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("imprecise_slot_fill_answer_phrase", "ans", undefined)], $locale._("${generic_preamble_for_answer} ${ans} ."), (($0 : string, ans : Ast.Value|C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => ans), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_answer", [new $runtime.NonTerminal("imprecise_slot_fill_coref_answer", "ans", undefined)], $locale._("${ans} {please|} ."), ((ans : Ast.Value|C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => ans), undefined, {  });
   $grammar.addRule("imprecise_slot_fill_answer", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("imprecise_slot_fill_coref_answer", "ans", undefined)], $locale._("${generic_preamble_for_answer} ${ans} ."), (($0 : string, ans : Ast.Value|C.InputParamSlot) : (Ast.Value|C.InputParamSlot)|null => ans), undefined, {  });
   $grammar.declareSymbol("precise_slot_fill_answer");
   $grammar.addRule("precise_slot_fill_answer", [new $runtime.NonTerminal("generic_preamble_for_action", undefined, undefined), new $runtime.NonTerminal("action_continuation_command", "action", undefined)], $locale._("${generic_preamble_for_action} ${action}"), (($0 : string, action : Ast.Invocation) : (Ast.Invocation)|null => action), C.invocationKeyFn, {  });
   $grammar.addRule("precise_slot_fill_answer", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("continuation_query", "query", undefined)], $locale._("${generic_preamble_for_answer} ${generic_article} ${query}"), (($0 : string, $1 : string, query : Ast.Invocation) : (Ast.Invocation)|null => query), C.invocationKeyFn, {  });
   $grammar.addRule("precise_slot_fill_answer", [new $runtime.NonTerminal("generic_verb_for_search", undefined, undefined), new $runtime.NonTerminal("generic_article", undefined, undefined), new $runtime.NonTerminal("continuation_query", "query", undefined)], $locale._("${generic_verb_for_search} ${generic_article} ${query}"), (($0 : string, $1 : string, query : Ast.Invocation) : (Ast.Invocation)|null => query), C.invocationKeyFn, {  });
};
