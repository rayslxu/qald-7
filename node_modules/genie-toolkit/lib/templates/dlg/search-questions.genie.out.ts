// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

// Slot fill templates: the agent asks a question, and the user replies
//
// There are two types slot-fill templates:
// - for searches: the agent is trying to add a filter
// - for actions/queries w/ parameters: the agent is trying to add a parameter

import * as $runtime from "../../sentence-generator/runtime";
import type $SentenceGenerator from "../../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../../sentence-generator/types";
import * as $I18n from "../../i18n/index";
import { Ast, } from 'thingtalk';
import * as C from '../ast_manip';
import * as D from '../dialogue_acts';
import * as S from '../state_manip';
import ThingpediaLoader from '../load-thingpedia';
export const one_param_direct_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "one_param_direct_search_question";
export const one_param_direct_search_question_with_preamble : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "one_param_direct_search_question_with_preamble";
export const two_param_direct_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "two_param_direct_search_question";
export const one_param_yesno_direct_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "one_param_yesno_direct_search_question";
export const one_param_yesno_direct_search_question_with_preamble : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "one_param_yesno_direct_search_question_with_preamble";
export const two_param_yesno_direct_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "two_param_yesno_direct_search_question";
export const question_npp_filter_pair : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot> = "question_npp_filter_pair";
export const question_apv_filter_pair : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot> = "question_apv_filter_pair";
export const question_avp_filter_pair : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot> = "question_avp_filter_pair";
export const question_preposition_filter_pair : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot> = "question_preposition_filter_pair";
export const question_pvp_filter_pair : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot> = "question_pvp_filter_pair";
export const disjunctive_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "disjunctive_search_question";
export const generic_question : $SentenceGeneratorTypes.NonTerminal<never[]> = "generic_question";
export const simple_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "simple_search_question";
export const search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "search_question";
export const verbose_search_answer : $SentenceGeneratorTypes.NonTerminal<Ast.Expression> = "verbose_search_answer";
export const verbose_search_answer_with_action : $SentenceGeneratorTypes.NonTerminal<[Ast.Expression, Ast.Invocation]> = "verbose_search_answer_with_action";
export const precise_search_question_answer : $SentenceGeneratorTypes.NonTerminal<D.PreciseSearchQuestionAnswer> = "precise_search_question_answer";
export const specific_dontcare_phrase : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot> = "specific_dontcare_phrase";
export const coref_constant : $SentenceGeneratorTypes.NonTerminal<Ast.Value> = "coref_constant";
export const imprecise_search_coref_answer : $SentenceGeneratorTypes.NonTerminal<Ast.Value|C.FilterSlot> = "imprecise_search_coref_answer";
export const imprecise_search_answer_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Value|C.FilterSlot> = "imprecise_search_answer_phrase";
export const imprecise_search_answer : $SentenceGeneratorTypes.NonTerminal<Ast.Value|C.FilterSlot> = "imprecise_search_answer";
export const imprecise_search_question_answer : $SentenceGeneratorTypes.NonTerminal<Ast.Value|C.FilterSlot|'dontcare'> = "imprecise_search_question_answer";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   $grammar.declareSymbol("one_param_direct_search_question");
   $grammar.addRule("one_param_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined)], $locale._("what ${p} ${prefer_question_phrase} ?"), ((p : C.ParamSlot, $0 : string) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("one_param_direct_search_question", [new $runtime.NonTerminal("thingpedia_search_question", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]])], $locale._("${p} ?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("one_param_direct_search_question_with_preamble");
   $grammar.addRule("one_param_direct_search_question_with_preamble", [new $runtime.NonTerminal("search_result_preamble", undefined, undefined), new $runtime.NonTerminal("one_param_direct_search_question", "question", undefined)], $locale._("${search_result_preamble} ${question}"), (($0 : S.ContextInfo, question : C.ParamSlot[]) : (C.ParamSlot[])|null => question), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("two_param_direct_search_question");
   $grammar.addRule("two_param_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined)], $locale._("what ${p1} and ${p2} ${prefer_question_phrase} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot, $0 : string) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_direct_search_question", [new $runtime.NonTerminal("thingpedia_search_question", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined)], $locale._("${p1} and what ${p2} ${prefer_question_phrase} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot, $0 : string) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("prefer_question_phrase", undefined, undefined), new $runtime.NonTerminal("thingpedia_search_question", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("what ${p1} ${prefer_question_phrase} and ${p2} ?"), ((p1 : C.ParamSlot, $0 : string, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("one_param_yesno_direct_search_question");
   $grammar.addRule("one_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]])], $locale._("any preference of ${p} ?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("one_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]])], $locale._("do you have a specific ${p} in mind?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("one_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]])], $locale._("do you have a preference of ${p} ?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("one_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]])], $locale._("do you have a preferred ${p} ?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("one_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]])], $locale._("are you looking for a specific ${p} ?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("one_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]])], $locale._("are you interested in a specific ${p} ?"), ((p : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p.name === 'id')
            return null;
        if (!p.filterable)
            return null;
        return [p];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("one_param_yesno_direct_search_question_with_preamble");
   $grammar.addRule("one_param_yesno_direct_search_question_with_preamble", [new $runtime.NonTerminal("search_result_preamble", undefined, undefined), new $runtime.NonTerminal("one_param_yesno_direct_search_question", "question", undefined)], $locale._("${search_result_preamble} ${question}"), (($0 : S.ContextInfo, question : C.ParamSlot[]) : (C.ParamSlot[])|null => question), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("two_param_yesno_direct_search_question");
   $grammar.addRule("two_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("any preference of ${p1} or ${p2} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("do you have a specific ${p1} or ${p2} in mind?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("do you have a preference of ${p1} or ${p2} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("do you have a preferred ${p1} or ${p2} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("are you looking for a specific ${p1} or ${p2} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("two_param_yesno_direct_search_question", [new $runtime.NonTerminal("out_param_Any", "p1", ["filterable" as ("filterable" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["filterable"]]), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("are you interested in a specific ${p1} or ${p2} ?"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(p1.schema, p2.schema))
            return null;
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        if (!p1.filterable || !p2.filterable)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("question_npp_filter_pair");
   $grammar.addRule("question_npp_filter_pair", [new $runtime.NonTerminal("ctx_with_result_noquestion", "ctx", undefined), new $runtime.NonTerminal("npp_filter", "f1", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)]), new $runtime.NonTerminal("npp_filter", "f2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${f1} or ${f2}"), ((ctx : S.ContextInfo, f1 : C.FilterSlot, f2 : C.FilterSlot) : (C.ParamSlot)|null => D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2)), C.paramKeyFn, {  });
   $grammar.addRule("question_npp_filter_pair", [new $runtime.NonTerminal("ctx_with_result_noquestion", "ctx", undefined), new $runtime.NonTerminal("npp_filter", "f1", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)]), new $runtime.NonTerminal("constant_Any", "c", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 1, "type" as ("type" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${ctx} ${f1} or ${c}"), ((ctx : S.ContextInfo, f1 : C.FilterSlot, c : Ast.Value) : (C.ParamSlot)|null => D.checkFilterPairForDisjunctiveQuestionWithConstant(ctx, f1, c)), C.paramKeyFn, {  });
   $grammar.declareSymbol("question_apv_filter_pair");
   $grammar.addRule("question_apv_filter_pair", [new $runtime.NonTerminal("ctx_with_result_noquestion", "ctx", undefined), new $runtime.NonTerminal("apv_filter", "f1", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)]), new $runtime.NonTerminal("apv_filter", "f2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${f1} or ${f2}"), ((ctx : S.ContextInfo, f1 : C.FilterSlot, f2 : C.FilterSlot) : (C.ParamSlot)|null => D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2)), C.paramKeyFn, {  });
   $grammar.declareSymbol("question_avp_filter_pair");
   $grammar.addRule("question_avp_filter_pair", [new $runtime.NonTerminal("ctx_with_result_noquestion", "ctx", undefined), new $runtime.NonTerminal("avp_filter", "f1", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)]), new $runtime.NonTerminal("constant_Any", "c", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 1, "type" as ("type" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("${ctx} ${f1} or ${c}"), ((ctx : S.ContextInfo, f1 : C.FilterSlot, c : Ast.Value) : (C.ParamSlot)|null => D.checkFilterPairForDisjunctiveQuestionWithConstant(ctx, f1, c)), C.paramKeyFn, {  });
   $grammar.declareSymbol("question_preposition_filter_pair");
   $grammar.addRule("question_preposition_filter_pair", [new $runtime.NonTerminal("ctx_with_result_noquestion", "ctx", undefined), new $runtime.NonTerminal("preposition_filter", "f1", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)]), new $runtime.NonTerminal("preposition_filter", "f2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${f1} or ${f2}"), ((ctx : S.ContextInfo, f1 : C.FilterSlot, f2 : C.FilterSlot) : (C.ParamSlot)|null => D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2)), C.paramKeyFn, {  });
   $grammar.declareSymbol("question_pvp_filter_pair");
   $grammar.addRule("question_pvp_filter_pair", [new $runtime.NonTerminal("ctx_with_result_noquestion", "ctx", undefined), new $runtime.NonTerminal("pvp_filter", "f1", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)]), new $runtime.NonTerminal("pvp_filter", "f2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "currentFunction" as ("currentFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${f1} or ${f2}"), ((ctx : S.ContextInfo, f1 : C.FilterSlot, f2 : C.FilterSlot) : (C.ParamSlot)|null => D.checkFilterPairForDisjunctiveQuestion(ctx, f1, f2)), C.paramKeyFn, {  });
   $grammar.declareSymbol("disjunctive_search_question");
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("question_npp_filter_pair", "question", undefined)], $locale._("{are you looking for|would you like|do you need} something with ${question} ?"), ((question : C.ParamSlot) : (C.ParamSlot[])|null => [question]), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("question_apv_filter_pair", "question", undefined)], $locale._("{are you looking for|would you like|do you need} something ${question} ?"), ((question : C.ParamSlot) : (C.ParamSlot[])|null => [question]), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("question_preposition_filter_pair", "question", undefined)], $locale._("{are you looking for|would you like|do you need} something ${question} ?"), ((question : C.ParamSlot) : (C.ParamSlot[])|null => [question]), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("question_pvp_filter_pair", "question", undefined)], $locale._("{are you looking for|would you like|do you need} something ${question} ?"), ((question : C.ParamSlot) : (C.ParamSlot[])|null => [question]), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("question_avp_filter_pair", "question", undefined)], $locale._("{are you looking for|would you like|do you need} something that ${question} ?"), ((question : C.ParamSlot) : (C.ParamSlot[])|null => [question]), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("base_table", "table", undefined), new $runtime.NonTerminal("question_npp_filter_pair", "question", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{are you looking for|would you like|do you need} a ${table} {with|that has} ${question} ?"), ((table : Ast.InvocationExpression, question : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(table.schema!, question.schema))
            return null;
        return [question];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("question_apv_filter_pair", "question", undefined), new $runtime.NonTerminal("base_table", "table", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{are you looking for|would you like|do you need} a ${question} ${table} ?"), ((question : C.ParamSlot, table : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(table.schema!, question.schema))
            return null;
        return [question];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("base_table", "table", undefined), new $runtime.NonTerminal("question_pvp_filter_pair", "question", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{are you looking for|would you like|do you need} a ${table} ${question} ?"), ((table : Ast.InvocationExpression, question : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(table.schema!, question.schema))
            return null;
        return [question];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("base_table", "table", undefined), new $runtime.NonTerminal("question_preposition_filter_pair", "question", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{are you looking for|would you like|do you need} a ${table} ${question} ?"), ((table : Ast.InvocationExpression, question : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(table.schema!, question.schema))
            return null;
        return [question];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("disjunctive_search_question", [new $runtime.NonTerminal("base_table", "table", undefined), new $runtime.NonTerminal("question_avp_filter_pair", "question", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{are you looking for|would you like|do you need} a ${table} that ${question} ?"), ((table : Ast.InvocationExpression, question : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (!C.isSameFunction(table.schema!, question.schema))
            return null;
        return [question];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("generic_question");
   $grammar.addRule("generic_question", [], $locale._("which one would you like ?"), (() : (never[])|null => []), undefined, {  });
   $grammar.addRule("generic_question", [], $locale._("do you have a specific one in mind ?"), (() : (never[])|null => []), undefined, {  });
   $grammar.addRule("generic_question", [], $locale._("do you have any more information to narrow down the search ?"), (() : (never[])|null => []), undefined, {  });
   $grammar.declareSymbol("simple_search_question");
   $grammar.addRule("simple_search_question", [new $runtime.NonTerminal("one_param_direct_search_question", undefined, undefined)], "${one_param_direct_search_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { priority: (0.1), identity: (true) });
   $grammar.addRule("simple_search_question", [new $runtime.NonTerminal("two_param_direct_search_question", undefined, undefined)], "${two_param_direct_search_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { identity: (true) });
   if ($options.flags.disjunctive_search_questions) {
       $grammar.addRule("simple_search_question", [new $runtime.NonTerminal("disjunctive_search_question", undefined, undefined)], "${disjunctive_search_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { identity: (true) });
   }
   $grammar.addRule("simple_search_question", [new $runtime.NonTerminal("one_param_yesno_direct_search_question", undefined, undefined)], "${one_param_yesno_direct_search_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { priority: (0.1), identity: (true) });
   $grammar.addRule("simple_search_question", [new $runtime.NonTerminal("two_param_yesno_direct_search_question", undefined, undefined)], "${two_param_yesno_direct_search_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { identity: (true) });
   $grammar.declareSymbol("search_question");
   $grammar.addRule("search_question", [new $runtime.NonTerminal("simple_search_question", undefined, undefined)], "${simple_search_question}", (($0 : C.ParamSlot[]) : (C.ParamSlot[])|null => { return $0; }), C.paramArrayKeyFn, { identity: (true) });
   $grammar.addRule("search_question", [new $runtime.NonTerminal("search_result_preamble", undefined, undefined), new $runtime.NonTerminal("simple_search_question", "question", undefined)], $locale._("${search_result_preamble} ${question}"), (($0 : S.ContextInfo, question : C.ParamSlot[]) : (C.ParamSlot[])|null => question), C.paramArrayKeyFn, { weight: (0.1) });
   $grammar.declareSymbol("verbose_search_answer");
   if ($options.flags.multiwoz) {
       $grammar.addRule("verbose_search_answer", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("answer_noun_phrase", "query", undefined)], $locale._("${generic_preamble_for_answer} {a|the} ${query}"), (($0 : string, query : Ast.Expression) : (Ast.Expression)|null => query), C.expressionKeyFn, {  });
   }
   $grammar.addRule("verbose_search_answer", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("anything_phrase", "query", undefined)], $locale._("${generic_preamble_for_answer} ${query}"), (($0 : string, query : Ast.Expression) : (Ast.Expression)|null => query), C.expressionKeyFn, {  });
   $grammar.declareSymbol("verbose_search_answer_with_action");
   $grammar.addRule("verbose_search_answer_with_action", [new $runtime.NonTerminal("verbose_search_answer", "query", undefined), new $runtime.NonTerminal("generic_preamble_for_action", undefined, undefined), new $runtime.NonTerminal("coref_action_command", "action", undefined)], $locale._("${query} {.|,} ${generic_preamble_for_action} ${action}"), ((query : Ast.Expression, $0 : string, action : Ast.Invocation) : ([Ast.Expression, Ast.Invocation])|null => {
        // check that one of the parameters of action has the right type to param pass into the action
        let idArg = query.schema!.getArgument('id');
        if (!idArg)
            return null;

        let found = false;
        for (let arg of action.schema!.iterateArguments()) {
            if (!arg.is_input)
                continue
            if (arg.type.equals(idArg.type)) {
                found = true;
                break;
            }
        }
        if (!found)
            return null;
        return [query, action];
    }), undefined, {  });
   $grammar.declareSymbol("precise_search_question_answer");
   $grammar.addRule("precise_search_question_answer", [new $runtime.NonTerminal("verbose_search_answer", "table", undefined)], "${table}", ((table : Ast.Expression) : (D.PreciseSearchQuestionAnswer)|null => [table, null, false]), D.preciseSearchQuestionAnswerKeyFn, {  });
   $grammar.addRule("precise_search_question_answer", [new $runtime.NonTerminal("verbose_search_answer", "table", undefined)], $locale._("{yes|yes ,|} ${table}"), ((table : Ast.Expression) : (D.PreciseSearchQuestionAnswer)|null => [table, null, true]), D.preciseSearchQuestionAnswerKeyFn, {  });
   $grammar.addRule("precise_search_question_answer", [new $runtime.NonTerminal("verbose_search_answer_with_action", "table_action", undefined)], "${table_action}", ((table_action : [Ast.Expression, Ast.Invocation]) : (D.PreciseSearchQuestionAnswer)|null => [...table_action, false]), D.preciseSearchQuestionAnswerKeyFn, {  });
   $grammar.addRule("precise_search_question_answer", [new $runtime.NonTerminal("verbose_search_answer_with_action", "table_action", undefined)], $locale._("{yes|yes ,|} ${table_action}"), ((table_action : [Ast.Expression, Ast.Invocation]) : (D.PreciseSearchQuestionAnswer)|null => [...table_action, true]), D.preciseSearchQuestionAnswerKeyFn, {  });
   $grammar.declareSymbol("specific_dontcare_phrase");
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("the ${param} does not matter ."), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeDontCareFilter(param)), C.filterKeyFn, {  });
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("the ${param} is not an issue ."), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeDontCareFilter(param)), C.filterKeyFn, {  });
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("the ${param} is not important ."), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeDontCareFilter(param)), C.filterKeyFn, {  });
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("the ${param} does not matter . can you suggest one ?"), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeDontCareFilter(param)), C.filterKeyFn, {  });
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i {do not have a|have no} preference of  ${param} ."), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeDontCareFilter(param)), C.filterKeyFn, {  });
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i {do not have a|have no} preference of  ${param} . what do you recommend ?"), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeDontCareFilter(param)), C.filterKeyFn, {  });
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i have no preference of  ${param} . please make a recommendation ."), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeDontCareFilter(param)), C.filterKeyFn, {  });
   $grammar.addRule("specific_dontcare_phrase", [new $runtime.NonTerminal("npp_filter", "param", undefined)], $locale._("{i do not care that it has|it need not have|i do not need} ${param}"), ((param : C.FilterSlot) : (C.FilterSlot)|null => {
        if (!(param.ast instanceof Ast.AtomBooleanExpression))
            return null;
        if (!(param.ast.value instanceof Ast.BooleanValue) || param.ast.value.value !== true)
            return null;
        return C.makeDontCareFilter({ schema: param.schema, type: param.ptype, name: param.ast.name,
            filterable: param.schema.getArgument(param.ast.name)!.getImplementationAnnotation<boolean>('filterable') ?? true,
            symmetric: param.schema.getArgument(param.ast.name)!.getImplementationAnnotation<boolean>('symmetric') ?? false,
            ast: new Ast.Value.VarRef(param.ast.name) });
    }), C.filterKeyFn, {  });
   $grammar.declareSymbol("coref_constant");
   $grammar.addRule("coref_constant", [new $runtime.NonTerminal("ctx_multidomain", "ctx", undefined), new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${ctx} {the|the same} ${base} 's ${param} ."), ((ctx : S.ContextInfo, base : Ast.InvocationExpression, param : C.ParamSlot) : (Ast.Value)|null => D.corefConstant(ctx, base, param)), C.valueKeyFn, {  });
   $grammar.addRule("coref_constant", [new $runtime.NonTerminal("ctx_multidomain", "ctx", undefined), new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 2, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("${ctx} ${generic_preamble_for_answer} {the|the same} ${base} 's ${param} ."), ((ctx : S.ContextInfo, $0 : string, base : Ast.InvocationExpression, param : C.ParamSlot) : (Ast.Value)|null => D.corefConstant(ctx, base, param)), C.valueKeyFn, {  });
   $grammar.addRule("coref_constant", [new $runtime.NonTerminal("ctx_multidomain", "ctx", undefined), new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${ctx} the same ${param} as the ${base} ."), ((ctx : S.ContextInfo, param : C.ParamSlot, base : Ast.InvocationExpression) : (Ast.Value)|null => D.corefConstant(ctx, base, param)), C.valueKeyFn, {  });
   $grammar.addRule("coref_constant", [new $runtime.NonTerminal("ctx_multidomain", "ctx", undefined), new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 2, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${ctx} ${generic_preamble_for_answer} the same ${param} as the ${base} ."), ((ctx : S.ContextInfo, $0 : string, param : C.ParamSlot, base : Ast.InvocationExpression) : (Ast.Value)|null => D.corefConstant(ctx, base, param)), C.valueKeyFn, {  });
   $grammar.addRule("coref_constant", [new $runtime.NonTerminal("ctx_multidomain", "ctx", undefined), new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${ctx} {the same as the|the} ${param} of the ${base} ."), ((ctx : S.ContextInfo, param : C.ParamSlot, base : Ast.InvocationExpression) : (Ast.Value)|null => D.corefConstant(ctx, base, param)), C.valueKeyFn, {  });
   $grammar.addRule("coref_constant", [new $runtime.NonTerminal("ctx_multidomain", "ctx", undefined), new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 2, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${ctx} ${generic_preamble_for_answer} {the same as the|the} ${param} of the ${base} ."), ((ctx : S.ContextInfo, $0 : string, param : C.ParamSlot, base : Ast.InvocationExpression) : (Ast.Value)|null => D.corefConstant(ctx, base, param)), C.valueKeyFn, {  });
   $grammar.declareSymbol("imprecise_search_coref_answer");
   $grammar.addRule("imprecise_search_coref_answer", [new $runtime.NonTerminal("coref_constant", "slot", undefined)], "${slot}", ((slot : Ast.Value) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_coref_answer", [new $runtime.NonTerminal("coref_npp_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_coref_answer", [new $runtime.NonTerminal("coref_apv_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_coref_answer", [new $runtime.NonTerminal("coref_pvp_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_coref_answer", [new $runtime.NonTerminal("coref_preposition_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.declareSymbol("imprecise_search_answer_phrase");
   $grammar.addRule("imprecise_search_answer_phrase", [new $runtime.NonTerminal("constant_Any", "slot", undefined)], "${slot}", ((slot : Ast.Value) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_answer_phrase", [new $runtime.NonTerminal("npp_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_answer_phrase", [new $runtime.NonTerminal("apv_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_answer_phrase", [new $runtime.NonTerminal("pvp_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.addRule("imprecise_search_answer_phrase", [new $runtime.NonTerminal("preposition_filter", "slot", undefined)], "${slot}", ((slot : C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => slot), undefined, {  });
   $grammar.declareSymbol("imprecise_search_answer");
   $grammar.addRule("imprecise_search_answer", [new $runtime.NonTerminal("imprecise_search_answer_phrase", "ans", undefined)], $locale._("${ans} {please|} ."), ((ans : Ast.Value|C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => ans), undefined, {  });
   $grammar.addRule("imprecise_search_answer", [new $runtime.NonTerminal("generic_preamble_for_answer", undefined, undefined), new $runtime.NonTerminal("imprecise_search_answer_phrase", "ans", undefined)], $locale._("${generic_preamble_for_answer} ${ans} ."), (($0 : string, ans : Ast.Value|C.FilterSlot) : (Ast.Value|C.FilterSlot)|null => ans), undefined, {  });
   $grammar.declareSymbol("imprecise_search_question_answer");
   $grammar.addRule("imprecise_search_question_answer", [new $runtime.NonTerminal("imprecise_search_answer", undefined, undefined)], "${imprecise_search_answer}", (($0 : Ast.Value|C.FilterSlot) : (Ast.Value|C.FilterSlot|'dontcare')|null => { return $0; }), undefined, { identity: (true) });
   $grammar.addRule("imprecise_search_question_answer", [new $runtime.NonTerminal("imprecise_search_coref_answer", undefined, undefined)], "${imprecise_search_coref_answer}", (($0 : Ast.Value|C.FilterSlot) : (Ast.Value|C.FilterSlot|'dontcare')|null => { return $0; }), undefined, { identity: (true) });
   if ($options.flags.dontcare) {
       $grammar.addRule("imprecise_search_question_answer", [new $runtime.NonTerminal("generic_dontcare_phrase", undefined, undefined)], "${generic_dontcare_phrase}", (($0 : string) : (Ast.Value|C.FilterSlot|'dontcare')|null => 'dontcare'), undefined, { weight: (0.1) });
       $grammar.addRule("imprecise_search_question_answer", [new $runtime.NonTerminal("no_dontcare_phrase", undefined, undefined)], "${no_dontcare_phrase}", (($0 : string) : (Ast.Value|C.FilterSlot|'dontcare')|null => 'dontcare'), undefined, { weight: (0.1) });
       $grammar.addRule("imprecise_search_question_answer", [new $runtime.NonTerminal("specific_dontcare_phrase", undefined, undefined)], "${specific_dontcare_phrase}", (($0 : C.FilterSlot) : (Ast.Value|C.FilterSlot|'dontcare')|null => { return $0; }), undefined, { identity: (true) });
   }
};
