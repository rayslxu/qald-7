// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

// Coref question templates: questions about the current result, referred by coreference ("it", "that", "the restaurant")

import * as $runtime from "../../sentence-generator/runtime";
import type $SentenceGenerator from "../../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../../sentence-generator/types";
import * as $I18n from "../../i18n/index";
import assert from 'assert';
import { Ast } from 'thingtalk';
import * as C from '../ast_manip';
import * as D from '../dialogue_acts';
import ThingpediaLoader from '../load-thingpedia';
export const out_param_list_for_coref_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "out_param_list_for_coref_question";
export const simple_user_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "simple_user_search_question";
export const simple_user_search_question_for_list : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "simple_user_search_question_for_list";
export const boolean_user_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "boolean_user_search_question";
export const boolean_user_search_question_for_list : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "boolean_user_search_question_for_list";
export const user_search_question_with_name : $SentenceGeneratorTypes.NonTerminal<[Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]]> = "user_search_question_with_name";
export const boolean_user_search_question_with_name : $SentenceGeneratorTypes.NonTerminal<[Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]]> = "boolean_user_search_question_with_name";
export const user_search_question : $SentenceGeneratorTypes.NonTerminal<C.ParamSlot[]> = "user_search_question";
export const user_search_question_for_list : $SentenceGeneratorTypes.NonTerminal<D.UserSearchQuestionForList> = "user_search_question_for_list";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   $grammar.declareSymbol("out_param_list_for_coref_question");
   $grammar.addRule("out_param_list_for_coref_question", [new $runtime.NonTerminal("out_param_Any", "p1", undefined), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${p1} and ${p2}"), ((p1 : C.ParamSlot, p2 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p1.name === 'id' || p2.name === 'id' || p1.name === p2.name)
            return null;
        assert(C.isSameFunction(p1.schema, p2.schema));
        return [p1, p2];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("out_param_list_for_coref_question", [new $runtime.NonTerminal("out_param_Any", "p1", undefined), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)]), new $runtime.NonTerminal("out_param_Any", "p3", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${p1} , ${p2} {,|} and ${p3}"), ((p1 : C.ParamSlot, p2 : C.ParamSlot, p3 : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (p1.name === 'id' || p2.name === 'id' || p3.name === 'id')
            return null;
        if (p1.name === p2.name || p2.name === p3.name || p1.name === p3.name)
            return null;
        assert(C.isSameFunction(p1.schema, p2.schema));
        assert(C.isSameFunction(p1.schema, p3.schema));
        return [p1, p2, p3];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("simple_user_search_question");
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("{can you tell me|} what is {the|its} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("can you tell me {the|its} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("{can you tell me|} what ${param} does it have ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i would like to {know|see} {the|its} ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i need {the|its} ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i just need {the|its} ${param} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined)], $locale._("{can you tell me|} what {is|are} {the|its} ${params} ?"), ((params : C.ParamSlot[]) : (C.ParamSlot[])|null => params), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined)], $locale._("can you tell me {the|its} ${params} ?"), ((params : C.ParamSlot[]) : (C.ParamSlot[])|null => params), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined)], $locale._("i would like to {know|see} {the|its} ${params} {first|} ."), ((params : C.ParamSlot[]) : (C.ParamSlot[])|null => params), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined)], $locale._("i need {the|its} ${params} {first|} ."), ((params : C.ParamSlot[]) : (C.ParamSlot[])|null => params), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined)], $locale._("i just need {the|its} ${params} ."), ((params : C.ParamSlot[]) : (C.ParamSlot[])|null => params), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{can you tell me|} what is the ${param} of the ${base} ?"), ((param : C.ParamSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("can you tell me the ${param} of the ${base} ?"), ((param : C.ParamSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{can you tell me|} what ${param} does the ${base} have ?"), ((param : C.ParamSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("i would like to {know|see} the ${param} of the ${base} {first|} ."), ((param : C.ParamSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("i just need {the|its} the ${param} of the ${base} ."), ((param : C.ParamSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} what is the ${base} 's ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("can you tell me the ${base} 's ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} the ${base} 's ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i just need {the|its} the ${base} 's ${param} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("{can you tell me|} what {is|are} the ${params} of the ${base} ?"), ((params : C.ParamSlot[], base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("can you tell me the ${params} of the ${base} ?"), ((params : C.ParamSlot[], base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("{can you tell me|} what ${params} does the ${base} have ?"), ((params : C.ParamSlot[], base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("i would like to {know|see} the ${params} of the ${base} {first|} ."), ((params : C.ParamSlot[], base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("i just need {the|its} the ${params} of the ${base} ."), ((params : C.ParamSlot[], base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_list_for_coref_question", "params", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} what is the ${base} 's ${params} ?"), ((base : Ast.InvocationExpression, params : C.ParamSlot[]) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_list_for_coref_question", "params", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("can you tell me the ${base} 's ${params} ?"), ((base : Ast.InvocationExpression, params : C.ParamSlot[]) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_list_for_coref_question", "params", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} the ${base} 's ${params} {first|} ."), ((base : Ast.InvocationExpression, params : C.ParamSlot[]) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("out_param_list_for_coref_question", "params", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i just need {the|its} the ${base} 's ${params} ."), ((base : Ast.InvocationExpression, params : C.ParamSlot[]) : (C.ParamSlot[])|null => {
        if (!params.every((p) => C.isSameFunction(base.schema!, p.schema)))
            return null;
        return params;
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} does {it|this|that} have ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} is there ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {it|this|that} has ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} there is ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("avp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} does {it|this|that} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("avp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {it|this|that} ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("pvp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} is {it|this|that} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("pvp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {it|this|that} is ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("preposition_boolean_projection", "param", undefined)], $locale._("{can you tell me|} is {it|this|that} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("preposition_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {it|this|that} is ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npi_boolean_projection", "param", undefined)], $locale._("{can you tell me|} is it ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npi_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {it|this|that} is ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npv_boolean_projection", "param", undefined)], $locale._("{can you tell me|} is it ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("npv_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {it|this|that} is ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("apv_boolean_projection", "param", undefined)], $locale._("{can you tell me|} is it ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("apv_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {it|this|that} is ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npp_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} does the ${base} have ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npp_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} {if|whether} the ${base} has ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("avp_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} does the ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("avp_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} {if|whether} the ${base} ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("pvp_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} is the ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("pvp_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} {if|whether} the ${base} is ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("preposition_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} is the ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("preposition_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} {if|whether} the ${base} is ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npi_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} is the ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npi_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} {if|whether} the ${base} is ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npv_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} is the ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npv_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} {if|whether} the ${base} is ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("apv_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{can you tell me|} is the ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("apv_boolean_projection", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("i would like to {know|see} {if|whether} the ${base} is ${param} {first|} ."), ((base : Ast.InvocationExpression, param : C.ParamSlot) : (C.ParamSlot[])|null => {
        assert(C.isSameFunction(base.schema!, param.schema));
        return [param];
    }), C.paramArrayKeyFn, {  });
   for (const proj of $loader.projections) {
       if (proj.category === 'pvp' || proj.category === 'preposition') {
           $grammar.declareSymbol("simple_user_search_question");
           $grammar.addRule("simple_user_search_question", [], $locale._("{can you tell me|} " + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {it|this|that} " + (proj.canonical) + " ?"), (() : (C.ParamSlot[])|null => {
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.addRule("simple_user_search_question", [], $locale._("i would like to {know|see} " + (proj.pronoun) + " " + (proj.base) + " {it|this|that} {is|was|are|were} " + (proj.canonical) + " {first|} ."), (() : (C.ParamSlot[])|null => {
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.declareSymbol("simple_user_search_question");
           $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined)], $locale._("{can you tell me|} " + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} the ${base} " + (proj.canonical) + " ?"), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
            if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                return null;
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("i would like to {know|see} " + (proj.pronoun) + " " + (proj.base) + " the ${base} {is|was|are|were} " + (proj.canonical) + " {first|} ."), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
            if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                return null;
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("simple_user_search_question");
               $grammar.addRule("simple_user_search_question", [], $locale._("i would like to {know|see} the " + (proj.base) + " {that|which|} {it|this|that} {is|was|are|were} " + (proj.canonical) + " {first|} ."), (() : (C.ParamSlot[])|null => {
                if (proj.pname === 'id')
                    return null;
                return [proj.pslot];
            }), C.paramArrayKeyFn, {  });
               $grammar.declareSymbol("simple_user_search_question");
               $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("i would like to {know|see} the " + (proj.base) + " {that|which|} the ${base} {is|was|are|were} " + (proj.canonical) + " {first|} ."), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
                if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                    return null;
                if (proj.pname === 'id')
                    return null;
                return [proj.pslot];
            }), C.paramArrayKeyFn, {  });
           }
       }
       if (proj.category === 'avp') {
           $grammar.declareSymbol("simple_user_search_question");
           $grammar.addRule("simple_user_search_question", [], $locale._("{can you tell me|} " + (proj.pronoun) + " " + (proj.base) + " {do|does|did} {it|this|that} " + (proj.canonical) + " ?"), (() : (C.ParamSlot[])|null => {
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.addRule("simple_user_search_question", [], $locale._("i would like to {know|see} " + (proj.pronoun) + " " + (proj.base) + " {it|this|that} " + (proj.canonical) + " {first|} ."), (() : (C.ParamSlot[])|null => {
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.declareSymbol("simple_user_search_question");
           $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("{can you tell me|} " + (proj.pronoun) + " " + (proj.base) + " {do|does|did} the ${base} " + (proj.canonical) + " ?"), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
            if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                return null;
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined)], $locale._("i would like to {know|see} " + (proj.pronoun) + " " + (proj.base) + " the ${base} " + (proj.canonical) + " {first|} ."), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
            if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                return null;
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("simple_user_search_question");
               $grammar.addRule("simple_user_search_question", [], $locale._("i would like to {know|see} the " + (proj.base) + " {that|which|} {it|this|that} " + (proj.canonical) + " {first|} ."), (() : (C.ParamSlot[])|null => {
                if (proj.pname === 'id')
                    return null;
                return [proj.pslot];
            }), C.paramArrayKeyFn, {  });
               $grammar.declareSymbol("simple_user_search_question");
               $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("i would like to {know|see} the " + (proj.base) + " {that|which|} the ${base} " + (proj.canonical) + " {first|} ."), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
                if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                    return null;
                if (proj.pname === 'id')
                    return null;
                return [proj.pslot];
            }), C.paramArrayKeyFn, {  });
           }
       }
       if (proj.category === 'reverse_verb') {
           $grammar.declareSymbol("simple_user_search_question");
           $grammar.addRule("simple_user_search_question", [], $locale._("{can you tell me|} " + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " {it|this|that} ?"), (() : (C.ParamSlot[])|null => {
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.addRule("simple_user_search_question", [], $locale._("i would like to {know|see} " + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " {it|this|that} {first|} ."), (() : (C.ParamSlot[])|null => {
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.declareSymbol("simple_user_search_question");
           $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("{can you tell me|} " + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " the ${base} ?"), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
            if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                return null;
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", undefined)], $locale._("i would like to {know|see} " + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " the ${base} {first|} ."), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
            if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                return null;
            if (proj.pname === 'id')
                return null;
            return [proj.pslot];
        }), C.paramArrayKeyFn, {  });
           if (proj.base) {
               $grammar.declareSymbol("simple_user_search_question");
               $grammar.addRule("simple_user_search_question", [], $locale._("i would like to {know|see} the " + (proj.base) + " {that|which|} " + (proj.canonical) + " {it|this|that} {first|} ."), (() : (C.ParamSlot[])|null => {
                if (proj.pname === 'id')
                    return null;
                return [proj.pslot];
            }), C.paramArrayKeyFn, {  });
               $grammar.declareSymbol("simple_user_search_question");
               $grammar.addRule("simple_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), ((proj.pslot.schema.qualifiedName)) as ReturnType<typeof C.expressionKeyFn>["functionName"]])], $locale._("i would like to {know|see} the " + (proj.base) + " {that|which|} " + (proj.canonical) + " the ${base} {first|} ."), ((base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
                if (!C.isSameFunction(base.schema!, proj.pslot.schema))
                    return null;
                if (proj.pname === 'id')
                    return null;
                return [proj.pslot];
            }), C.paramArrayKeyFn, {  });
           }
       }
   }
   $grammar.declareSymbol("simple_user_search_question_for_list");
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("{can you tell me|} what are {the|their} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("can you tell me {the|their} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("can you tell me the ${param} {for both of them|for all of them} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("{can you tell me|} what ${param} does it have ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i would like to {know|see} {both of|} {the|their} ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i need {the|their} ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("out_param_Any", "param", undefined)], $locale._("i just need {the|their} ${param} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        if (param.name === 'id')
            return null;
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} do {they|these|those} have ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} are there ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {they|these|those} have ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} there are ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("avp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} do {they|these|those} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("avp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {they|these|those} ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("pvp_boolean_projection", "param", undefined)], $locale._("{can you tell me|} are {they|these|those} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("pvp_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {they|these|those} are ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("preposition_boolean_projection", "param", undefined)], $locale._("{can you tell me|} are {they|these|those} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("preposition_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {they|these|those} are ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npi_boolean_projection", "param", undefined)], $locale._("{can you tell me|} are {they|these|those} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npi_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {they|these|those} are ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npv_boolean_projection", "param", undefined)], $locale._("{can you tell me|} are {they|these|those} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("npv_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {they|these|those} are ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("apv_boolean_projection", "param", undefined)], $locale._("{can you tell me|} are {they|these|those} ${param} ?"), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("simple_user_search_question_for_list", [new $runtime.NonTerminal("apv_boolean_projection", "param", undefined)], $locale._("i would like to {know|see} {if|whether} {they|these|those} are ${param} {first|} ."), ((param : C.ParamSlot) : (C.ParamSlot[])|null => {
        return [param];
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("boolean_user_search_question");
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("npp_filter", "param", undefined)], $locale._("does {that|it|this} have ${param} ?"), ((param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(null, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("avp_filter", "param", undefined)], $locale._("does {that|it|this} ${param} ?"), ((param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(null, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("apv_filter", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("is {that|it|this} a ${param} ${base} ?"), ((param : C.FilterSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("apv_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|this|that} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("pvp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {that|it|this} a ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("pvp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|this|that} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("preposition_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {that|it|this} a ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("preposition_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {the|this|that} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("avp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {that|it|this} a ${base} {that|which} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("avp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("does {the|this|that} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("npp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is {that|it|this} a ${base} {that has|with} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question", [new $runtime.NonTerminal("base_table", "base", ["is_list" as ("is_list" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), (true) as ReturnType<typeof C.expressionKeyFn>["is_list"]]), new $runtime.NonTerminal("npp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("does {the|this|that} ${base} have ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => {
        if (!base.schema!.is_list)
            return null;
        return D.booleanQuestion(base, param);
    }), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("boolean_user_search_question_for_list");
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("npp_filter", "param", undefined)], $locale._("{does either of|does any of} {them|these|those} have ${param} ?"), ((param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(null, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("npp_filter", "param", undefined)], $locale._("do they have ${param} ?"), ((param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(null, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("avp_filter", "param", undefined)], $locale._("{does either of|does any of} {them|these|those} ${param} ?"), ((param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(null, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("avp_filter", "param", undefined)], $locale._("do they ${param} ?"), ((param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(null, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("apv_filter", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("{is either of|is any of} {them|these|those} a ${param} ${base} ?"), ((param : C.FilterSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("apv_filter", "param", undefined), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("are they ${param} ${base} ?"), ((param : C.FilterSlot, base : Ast.InvocationExpression) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("apv_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("are {the|these|those} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("pvp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{is either of|is any of} {them|these|those} a ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("pvp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("are they ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("pvp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("are {the|these|those} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("preposition_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{is either of|is any of} {them|these|those} a ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("preposition_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("are they ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("preposition_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("are {the|these|those} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("avp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{is either of|is any of} {them|these|those} a ${base} {that|which} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("avp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("are they ${base} {that|which} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("avp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("do {the|these|those} ${base} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("{is either of|is any of} {them|these|those} a ${base} {that has|with} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("are they ${base} {that has|with} ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.addRule("boolean_user_search_question_for_list", [new $runtime.NonTerminal("base_table", "base", undefined), new $runtime.NonTerminal("npp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("do {the|these|those} ${base} have ${param} ?"), ((base : Ast.InvocationExpression, param : C.FilterSlot) : (C.ParamSlot[])|null => D.booleanQuestion(base, param)), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("user_search_question_with_name");
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("{can you tell me|} what is ${name} 's ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.ParamSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        if (param.name === 'id')
            return null;
        return [name, [param]];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("constant_name", "name", ["type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void), 0, "associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{can you tell me|} what is the ${param} of ${name} ?"), ((param : C.ParamSlot, name : Ast.EntityValue|Ast.NumberValue) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        if (param.name === 'id')
            return null;
        return [name, [param]];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("can you tell me ${name} 's ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.ParamSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        if (param.name === 'id')
            return null;
        return [name, [param]];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("constant_name", "name", ["type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void), 0, "associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("can you tell me the ${param} of ${name} ?"), ((param : C.ParamSlot, name : Ast.EntityValue|Ast.NumberValue) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        if (param.name === 'id')
            return null;
        return [name, [param]];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("out_param_Any", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("i would like to {know|see} ${name} 's ${param} {first|} ."), ((name : Ast.EntityValue|Ast.NumberValue, param : C.ParamSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        if (param.name === 'id')
            return null;
        return [name, [param]];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("constant_name", "name", ["type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void), 0, "associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("i would like to {know|see} the ${param} of ${name} {first|} ."), ((param : C.ParamSlot, name : Ast.EntityValue|Ast.NumberValue) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        if (param.name === 'id')
            return null;
        return [name, [param]];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("out_param_list_for_coref_question", "params", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("{can you tell me|} what is ${name} 's ${params} ?"), ((name : Ast.EntityValue|Ast.NumberValue, params : C.ParamSlot[]) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        return [name, params];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("constant_name", "name", ["type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void), 0, "associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("{can you tell me|} what is the ${params} of ${name} ?"), ((params : C.ParamSlot[], name : Ast.EntityValue|Ast.NumberValue) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        return [name, params];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("out_param_list_for_coref_question", "params", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("can you tell me ${name} 's ${params} ?"), ((name : Ast.EntityValue|Ast.NumberValue, params : C.ParamSlot[]) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        return [name, params];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("constant_name", "name", ["type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void), 0, "associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("can you tell me the ${params} of ${name} ?"), ((params : C.ParamSlot[], name : Ast.EntityValue|Ast.NumberValue) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        return [name, params];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("out_param_list_for_coref_question", "params", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("i would like to {know|see} ${name} 's ${params} {first|} ."), ((name : Ast.EntityValue|Ast.NumberValue, params : C.ParamSlot[]) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        return [name, params];
    }), undefined, {  });
   $grammar.addRule("user_search_question_with_name", [new $runtime.NonTerminal("out_param_list_for_coref_question", "params", undefined), new $runtime.NonTerminal("constant_name", "name", ["type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void), 0, "associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.paramArrayKeyFn> ? string : void)])], $locale._("i would like to {know|see} the ${params} of ${name} {first|} ."), ((params : C.ParamSlot[], name : Ast.EntityValue|Ast.NumberValue) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        return [name, params];
    }), undefined, {  });
   $grammar.declareSymbol("boolean_user_search_question_with_name");
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("npp_filter", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("does ${name} have ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(null, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("avp_filter", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("does ${name} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(null, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("apv_filter", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("is ${name} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(null, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("pvp_filter", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("is ${name} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(null, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("preposition_filter", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)])], $locale._("is ${name} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(null, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("apv_filter", "param", ["associatedIdType" as ("associatedIdType" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)]), new $runtime.NonTerminal("base_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void)])], $locale._("is ${name} a ${param} ${base} ?"), ((name : Ast.EntityValue|Ast.NumberValue, param : C.FilterSlot, base : Ast.InvocationExpression) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(base, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("base_table", "base", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)]), new $runtime.NonTerminal("pvp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is ${name} a ${base} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, base : Ast.InvocationExpression, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(base, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("base_table", "base", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)]), new $runtime.NonTerminal("preposition_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is ${name} a ${base} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, base : Ast.InvocationExpression, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(base, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("base_table", "base", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)]), new $runtime.NonTerminal("avp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is ${name} a ${base} {that|which} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, base : Ast.InvocationExpression, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(base, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.addRule("boolean_user_search_question_with_name", [new $runtime.NonTerminal("constant_name", "name", undefined), new $runtime.NonTerminal("base_table", "base", ["idType" as ("idType" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.entityOrNumberValueKeyFn> ? string : void)]), new $runtime.NonTerminal("npp_filter", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.filterKeyFn> ? string : void), 1, "functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void)])], $locale._("is ${name} a ${base} {that has|with} ${param} ?"), ((name : Ast.EntityValue|Ast.NumberValue, base : Ast.InvocationExpression, param : C.FilterSlot) : ([Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]])|null => {
        const idArg = param.schema.getArgument('id');
        if (!idArg || !idArg.type.equals(name.getType()))
            return null;
        const questions = D.booleanQuestion(base, param);
        if (!questions)
            return null;
        return [name, questions];
    }), undefined, {  });
   $grammar.declareSymbol("user_search_question");
   $grammar.addRule("user_search_question", [new $runtime.NonTerminal("simple_user_search_question", "questions", undefined)], $locale._("{no ,|} ${questions}"), ((questions : C.ParamSlot[]) : (C.ParamSlot[])|null => questions), C.paramArrayKeyFn, {  });
   $grammar.addRule("user_search_question", [new $runtime.NonTerminal("thingpedia_user_question", "questions", undefined)], $locale._("{no ,|} ${questions} ?"), ((questions : C.ParamSlot[]) : (C.ParamSlot[])|null => questions), C.paramArrayKeyFn, { weight: (0.3) });
   $grammar.addRule("user_search_question", [new $runtime.NonTerminal("boolean_user_search_question", "questions", undefined)], "${questions}", ((questions : C.ParamSlot[]) : (C.ParamSlot[])|null => questions), C.paramArrayKeyFn, {  });
   $grammar.declareSymbol("user_search_question_for_list");
   $grammar.addRule("user_search_question_for_list", [new $runtime.NonTerminal("simple_user_search_question", "questions", undefined)], "${questions}", ((questions : C.ParamSlot[]) : (D.UserSearchQuestionForList)|null => [null, questions]), D.userSearchQuestionForListKeyFn, {  });
   $grammar.addRule("user_search_question_for_list", [new $runtime.NonTerminal("simple_user_search_question_for_list", "questions", undefined)], "${questions}", ((questions : C.ParamSlot[]) : (D.UserSearchQuestionForList)|null => [null, questions]), D.userSearchQuestionForListKeyFn, {  });
   $grammar.addRule("user_search_question_for_list", [new $runtime.NonTerminal("boolean_user_search_question_for_list", "questions", undefined)], "${questions}", ((questions : C.ParamSlot[]) : (D.UserSearchQuestionForList)|null => [null, questions]), D.userSearchQuestionForListKeyFn, {  });
   if ($options.flags.multiwoz) {
       $grammar.addRule("user_search_question_for_list", [new $runtime.NonTerminal("user_search_question_with_name", undefined, undefined)], "${user_search_question_with_name}", (($0 : [Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]]) : (D.UserSearchQuestionForList)|null => { return $0; }), D.userSearchQuestionForListKeyFn, { identity: (true) });
       $grammar.addRule("user_search_question_for_list", [new $runtime.NonTerminal("boolean_user_search_question_with_name", undefined, undefined)], "${boolean_user_search_question_with_name}", (($0 : [Ast.EntityValue|Ast.NumberValue, C.ParamSlot[]]) : (D.UserSearchQuestionForList)|null => { return $0; }), D.userSearchQuestionForListKeyFn, { identity: (true) });
   }
};
