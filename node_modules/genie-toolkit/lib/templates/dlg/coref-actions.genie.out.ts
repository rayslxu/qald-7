// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>

// Coref actions: actions that operate on the current result, referred by coreference ("it", "that", "the restaurant")

import * as $runtime from "../../sentence-generator/runtime";
import type $SentenceGenerator from "../../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../../sentence-generator/types";
import * as $I18n from "../../i18n/index";
import { Ast, } from 'thingtalk';
import * as C from '../ast_manip';
import * as D from '../dialogue_acts';
import * as S from '../state_manip';
import ThingpediaLoader from '../load-thingpedia';
export const coref_action_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "coref_action_phrase";
export const list_coref_action_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "list_coref_action_phrase";
export const contextual_action_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "contextual_action_phrase";
export const action_coref_recommendation : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "action_coref_recommendation";
export const action_coref_list_proposal : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "action_coref_list_proposal";
export const coref_action_command : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "coref_action_command";
export const action_by_name_command : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "action_by_name_command";
export const action_continuation_command : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "action_continuation_command";
export const continuation_query : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "continuation_query";
export const action_description_phrase : $SentenceGeneratorTypes.NonTerminal<Ast.Invocation> = "action_description_phrase";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {
   $grammar.declareSymbol("coref_action_phrase");
   $grammar.addRule("coref_action_phrase", [new $runtime.NonTerminal("action_coref_context", "action", undefined)], "${action}", ((action : C.ExpressionWithCoreference) : (Ast.Invocation)|null => {
        if (!(action.expression instanceof Ast.InvocationExpression))
            return null;
        if (action.slot !== null || !$loader.isIDType(action.type)) // TODO: non-id parameter passing
            return null;
        return C.replacePlaceholderWithUndefined(action.expression.invocation, action.pname!);
    }), C.invocationKeyFn, {  });
   $grammar.addRule("coref_action_phrase", [new $runtime.NonTerminal("get_command_coref_context", "action", undefined)], "${action}", ((action : C.ExpressionWithCoreference) : (Ast.Invocation)|null => {
        if (!(action.expression instanceof Ast.InvocationExpression))
            return null;
        if (action.slot !== null || !$loader.isIDType(action.type)) // TODO: non-id parameter passing
            return null;
        return C.replacePlaceholderWithUndefined(action.expression.invocation, action.pname!);
    }), C.invocationKeyFn, {  });
   $grammar.declareSymbol("list_coref_action_phrase");
   $grammar.addRule("list_coref_action_phrase", [new $runtime.NonTerminal("action_coref_list_context", "action", undefined)], "${action}", ((action : C.ExpressionWithCoreference) : (Ast.Invocation)|null => {
        if (!(action.expression instanceof Ast.InvocationExpression))
            return null;
        if (action.slot !== null || !$loader.isIDType(action.type)) // TODO: non-id parameter passing
            return null;
        return C.replacePlaceholderWithUndefined(action.expression.invocation, action.pname!);
    }), C.invocationKeyFn, {  });
   $grammar.addRule("list_coref_action_phrase", [new $runtime.NonTerminal("get_command_coref_list_context", "action", undefined)], "${action}", ((action : C.ExpressionWithCoreference) : (Ast.Invocation)|null => {
        if (!(action.expression instanceof Ast.InvocationExpression))
            return null;
        if (action.slot !== null || !$loader.isIDType(action.type)) // TODO: non-id parameter passing
            return null;
        return C.replacePlaceholderWithUndefined(action.expression.invocation, action.pname!);
    }), C.invocationKeyFn, {  });
   $grammar.declareSymbol("contextual_action_phrase");
   $grammar.addRule("contextual_action_phrase", [new $runtime.NonTerminal("complete_action", "action", undefined)], "${action}", ((action : Ast.Expression) : (Ast.Invocation)|null => {
        if (!(action instanceof Ast.InvocationExpression))
            return null;
        return action.invocation;
    }), C.invocationKeyFn, {  });
   $grammar.addRule("contextual_action_phrase", [new $runtime.NonTerminal("complete_get_command", "action", undefined)], "${action}", ((action : Ast.Expression) : (Ast.Invocation)|null => {
        if (!(action instanceof Ast.InvocationExpression))
            return null;
        return action.invocation;
    }), C.invocationKeyFn, {  });
   $grammar.declareSymbol("action_coref_recommendation");
   $grammar.addRule("action_coref_recommendation", [new $runtime.NonTerminal("coref_action_phrase", "action", undefined)], $locale._("would you like to ${action} ?"), ((action : Ast.Invocation) : (Ast.Invocation)|null => {
        if (action.in_params.some((ip) => !ip.value.isUndefined))
            return null;
        return action;
    }), C.invocationKeyFn, { priority: (1) });
   $grammar.addRule("action_coref_recommendation", [new $runtime.NonTerminal("coref_action_phrase", "action", undefined)], $locale._("would you like me to ${action}  for you ?"), ((action : Ast.Invocation) : (Ast.Invocation)|null => {
        if (action.in_params.some((ip) => !ip.value.isUndefined))
            return null;
        return action;
    }), C.invocationKeyFn, { priority: (1) });
   $grammar.declareSymbol("action_coref_list_proposal");
   $grammar.addRule("action_coref_list_proposal", [new $runtime.NonTerminal("list_coref_action_phrase", "action", undefined)], $locale._("would you like to ${action} ?"), ((action : Ast.Invocation) : (Ast.Invocation)|null => {
        if (action.in_params.some((ip) => !ip.value.isUndefined))
            return null;
        return action;
    }), C.invocationKeyFn, { priority: (1) });
   $grammar.declareSymbol("coref_action_command");
   $grammar.addRule("coref_action_command", [new $runtime.NonTerminal("ctx_with_action", "ctx", undefined), new $runtime.NonTerminal("coref_action_phrase", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void), 0, "nextFunction" as ("nextFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${base}"), ((ctx : S.ContextInfo, base : Ast.Invocation) : (Ast.Invocation)|null => D.contextualAction(ctx, base)), C.invocationKeyFn, {  });
   $grammar.addRule("coref_action_command", [new $runtime.NonTerminal("ctx_without_action", "ctx", undefined), new $runtime.NonTerminal("coref_action_phrase", "base", undefined)], $locale._("${ctx} ${base}"), ((ctx : S.ContextInfo, base : Ast.Invocation) : (Ast.Invocation)|null => base), C.invocationKeyFn, {  });
   $grammar.addRule("coref_action_command", [new $runtime.NonTerminal("coref_action_command", "action", undefined), new $runtime.NonTerminal("preposition_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
   $grammar.addRule("coref_action_command", [new $runtime.NonTerminal("coref_action_command", "action", undefined), new $runtime.NonTerminal("npp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} {with|having} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
   $grammar.declareSymbol("action_by_name_command");
   $grammar.addRule("action_by_name_command", [new $runtime.NonTerminal("ctx_incomplete_action", "ctx", undefined), new $runtime.NonTerminal("contextual_action_phrase", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void), 0, "nextFunction" as ("nextFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${base}"), ((ctx : S.ContextInfo, base : Ast.Invocation) : (Ast.Invocation)|null => D.contextualAction(ctx, base)), C.invocationKeyFn, {  });
   $grammar.addRule("action_by_name_command", [new $runtime.NonTerminal("ctx_without_action", "ctx", undefined), new $runtime.NonTerminal("contextual_action_phrase", "base", undefined)], $locale._("${ctx} ${base}"), ((ctx : S.ContextInfo, base : Ast.Invocation) : (Ast.Invocation)|null => base), C.invocationKeyFn, {  });
   $grammar.addRule("action_by_name_command", [new $runtime.NonTerminal("action_by_name_command", "action", undefined), new $runtime.NonTerminal("preposition_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
   $grammar.addRule("action_by_name_command", [new $runtime.NonTerminal("action_by_name_command", "action", undefined), new $runtime.NonTerminal("npp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} {with|having} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
   $grammar.declareSymbol("action_continuation_command");
   $grammar.addRule("action_continuation_command", [new $runtime.NonTerminal("ctx_incomplete_action", "ctx", undefined), new $runtime.NonTerminal("coref_action_phrase", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void), 0, "nextFunction" as ("nextFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${base}"), ((ctx : S.ContextInfo, base : Ast.Invocation) : (Ast.Invocation)|null => D.contextualAction(ctx, base)), C.invocationKeyFn, {  });
   $grammar.addRule("action_continuation_command", [new $runtime.NonTerminal("ctx_incomplete_action", "ctx", undefined), new $runtime.NonTerminal("contextual_action_phrase", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void), 0, "nextFunction" as ("nextFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${base}"), ((ctx : S.ContextInfo, base : Ast.Invocation) : (Ast.Invocation)|null => D.contextualAction(ctx, base)), C.invocationKeyFn, {  });
   $grammar.addRule("action_continuation_command", [new $runtime.NonTerminal("action_continuation_command", "action", undefined), new $runtime.NonTerminal("preposition_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
   $grammar.addRule("action_continuation_command", [new $runtime.NonTerminal("action_continuation_command", "action", undefined), new $runtime.NonTerminal("npp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} {with|having} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
   $grammar.declareSymbol("continuation_query");
   $grammar.addRule("continuation_query", [new $runtime.NonTerminal("ctx_incomplete_action", "ctx", undefined), new $runtime.NonTerminal("complete_table", "base", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.expressionKeyFn> ? string : void), 0, "nextFunction" as ("nextFunction" extends keyof ReturnType<typeof S.contextKeyFn> ? string : void)])], $locale._("${ctx} ${base}"), ((ctx : S.ContextInfo, base : Ast.Expression) : (Ast.Invocation)|null => {
        if (!(base instanceof Ast.InvocationExpression))
            return null;
        return D.contextualAction(ctx, base.invocation);
    }), C.invocationKeyFn, {  });
   $grammar.declareSymbol("action_description_phrase");
   $grammar.addRule("action_description_phrase", [new $runtime.NonTerminal("coref_action_phrase", undefined, undefined)], "${coref_action_phrase}", (($0 : Ast.Invocation) : (Ast.Invocation)|null => { return $0; }), C.invocationKeyFn, { identity: (true) });
   $grammar.addRule("action_description_phrase", [new $runtime.NonTerminal("thingpedia_complete_action", "action", undefined)], "${action}", ((action : Ast.Expression) : (Ast.Invocation)|null => {
        if (!(action instanceof Ast.InvocationExpression))
            return null;
        return action.invocation;
    }), C.invocationKeyFn, {  });
   $grammar.addRule("action_description_phrase", [new $runtime.NonTerminal("action_description_phrase", "action", undefined), new $runtime.NonTerminal("preposition_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
   $grammar.addRule("action_description_phrase", [new $runtime.NonTerminal("action_description_phrase", "action", undefined), new $runtime.NonTerminal("npp_input_param", "param", ["functionName" as ("functionName" extends keyof ReturnType<typeof C.inputParamKeyFn> ? string : void), 0, "functionName" as ("functionName" extends keyof ReturnType<typeof C.invocationKeyFn> ? string : void)])], $locale._("${action} {with|having} ${param}"), ((action : Ast.Invocation, param : C.InputParamSlot) : (Ast.Invocation)|null => C.addInvocationInputParam($loader, action, param)), C.invocationKeyFn, {  });
};
