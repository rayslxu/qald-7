// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
//         Giovanni Campagna <gcampagn@cs.stanford.edu>

import * as $runtime from "../sentence-generator/runtime";
import type $SentenceGenerator from "../sentence-generator/generator";
import * as $SentenceGeneratorTypes from "../sentence-generator/types";
import * as $I18n from "../i18n/index";
import assert from 'assert';
import { Ast, Type } from 'thingtalk';
import * as C from './ast_manip';
import ThingpediaLoader from './load-thingpedia';
export const get_predicate_filter : $SentenceGeneratorTypes.NonTerminal<C.DomainIndependentFilterSlot> = "get_predicate_filter";
export const if_filter : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot|C.DomainIndependentFilterSlot> = "if_filter";
export const edge_filter : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot> = "edge_filter";
export const either_filter : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot> = "either_filter";
export const range : $SentenceGeneratorTypes.NonTerminal<[Ast.Value, Ast.Value]> = "range";
export const range_filter : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot> = "range_filter";
export const with_filter : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot> = "with_filter";
export const range_with_filter : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot> = "range_with_filter";
export const both_prefix : $SentenceGeneratorTypes.NonTerminal<string> = "both_prefix";
export const nearby_filter : $SentenceGeneratorTypes.NonTerminal<C.DomainIndependentFilterSlot> = "nearby_filter";
export const whose_npp_filter : $SentenceGeneratorTypes.NonTerminal<C.FilterSlot> = "whose_npp_filter";
export const quality_filter : $SentenceGeneratorTypes.NonTerminal<C.DomainIndependentFilterSlot> = "quality_filter";
export const within_filter : $SentenceGeneratorTypes.NonTerminal<({ distance : Ast.Value, place : Ast.Value })> = "within_filter";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {

const HERE = new Ast.Value.Location(new Ast.Location.Relative('current_location'));
   $grammar.declareSymbol("get_predicate_filter");
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("constant_Time", "t1", undefined)], $locale._("before ${t1}"), ((t1 : Ast.Value) : (C.DomainIndependentFilterSlot)|null => C.timeSubquery($loader, null, t1)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("constant_Time", "t2", undefined)], $locale._("after ${t2}"), ((t2 : Ast.Value) : (C.DomainIndependentFilterSlot)|null => C.timeSubquery($loader, t2, null)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("constant_Time", "t1", undefined), new $runtime.NonTerminal("constant_Time", "t2", undefined)], $locale._("between ${t1} and ${t2}"), ((t1 : Ast.Value, t2 : Ast.Value) : (C.DomainIndependentFilterSlot)|null => C.timeSubquery($loader, t1, t2)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("constant_Location", "loc", undefined)], $locale._("my location is ${loc}"), ((loc : Ast.LocationValue) : (C.DomainIndependentFilterSlot)|null => C.locationSubquery($loader, loc)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("constant_Location", "loc", undefined)], $locale._("my location is not ${loc}"), ((loc : Ast.LocationValue) : (C.DomainIndependentFilterSlot)|null => C.locationSubquery($loader, loc, true)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("constant_Location", "loc", undefined)], $locale._("i am at ${loc}"), ((loc : Ast.LocationValue) : (C.DomainIndependentFilterSlot)|null => C.locationSubquery($loader, loc)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("constant_Location", "loc", undefined)], $locale._("i am not at ${loc}"), ((loc : Ast.LocationValue) : (C.DomainIndependentFilterSlot)|null => C.locationSubquery($loader, loc, true)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("projection_Any", "proj", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("${proj} {is|is exactly|is equal to} ${x}"), ((proj : Ast.Expression, x : Ast.Value) : (C.DomainIndependentFilterSlot)|null => C.makeExistentialSubquery(proj, '==', x)), undefined, {  });
   $grammar.addRule("get_predicate_filter", [new $runtime.NonTerminal("projection_Any", "proj", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("${proj} {is not|is n't|is different than} ${x}"), ((proj : Ast.Expression, x : Ast.Value) : (C.DomainIndependentFilterSlot)|null => C.makeExistentialSubquery(proj, '==', x, true)), undefined, {  });
   $grammar.declareSymbol("if_filter");
   if ($options.flags.get_predicate) {
       $grammar.addRule("if_filter", [new $runtime.NonTerminal("get_predicate_filter", undefined, undefined)], "${get_predicate_filter}", (($0 : C.DomainIndependentFilterSlot) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => { return $0; }), C.filterKeyFn, { identity: (true) });
   }
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("the ${p} {is|is exactly|is equal to} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '==', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("the ${p} {is|is exactly|is equal to} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '==', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${p} {is not|is n't|is different than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '==', x, true)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("${p} is {greater than|higher than|larger than|more than|at least|not less than} ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("${p} is {smaller than|lower than|less than|at most|not more than} ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("${p} is {more expensive|more costly|more} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("${p} is {less expensive|cheaper|less} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("${p} is {longer than|no shorter than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("${p} is {no longer than|shorter than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("${p} is {larger|more|no smaller|no less} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("${p} is {smaller|less|no larger|no more} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("${p} is {heavier|larger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("${p} is {lighter|smaller} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("${p} is {hotter|higher} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("${p} is {cooler|colder|lower} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("${p} is {farther|more distant|longer} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("${p} is {nearer|closer|shorter|no longer|no farther} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("${p} is {larger|bigger|no smaller} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("${p} is {smaller|no larger|no bigger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("${p} is {larger|bigger|no smaller} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("${p} is {smaller|no larger|no bigger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("${p} is {faster|quicker|speedier} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("${p} is {slower|more slowly} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("${p} is {after|later than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
       $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("${p} is {before|earlier than|sooner than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
       $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("${p} is {after|later than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
       $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("${p} is {before|earlier than|sooner than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("the ${p} {contain|include} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, 'contains', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("the ${p} do not {contain|include} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, 'contains', x, true)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined)], $locale._("the ${p} {contains|includes} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined)], $locale._("the ${p} does not {contain|include} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '=~', x, true)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.RecurrentTimeSpecification)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("the ${p} {contains|includes} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.RecurrentTimeSpecification)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("the ${p} does not {contain|include} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '=~', x, true)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.RecurrentTimeSpecification)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("the ${p} {contains|includes} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.RecurrentTimeSpecification)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("the ${p} does not {contain|include} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '=~', x, true)), C.filterKeyFn, {  });
   $grammar.addRule("if_filter", [new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("the_out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} is in ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       if ($options.flags.range_filters) {
           $grammar.addRule("if_filter", [new $runtime.NonTerminal("range_filter", undefined, undefined)], "${range_filter}", (($0 : C.FilterSlot) : (C.FilterSlot|C.DomainIndependentFilterSlot)|null => { return $0; }), C.filterKeyFn, { identity: (true) });
       }
   }
   $grammar.declareSymbol("edge_filter");
   if (!$options.flags.turking) {
       $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("the ${p} {becomes|becomes equal to} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '==', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("${p} {is now|becomes|goes} {greater than|higher than|larger than|more than|at least|not less than} ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("${p} {is now|becomes|goes} {smaller than|lower than|less than|at most|not more than} ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("${p} {is now|becomes|goes} {more expensive|more costly|more} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("${p} {is now|becomes|goes} {less expensive|cheaper|less} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("${p} {is now|becomes|goes} longer than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("${p} {is now|becomes|goes} shorter than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("${p} {is now|becomes|goes} {larger|more} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("${p} {is now|becomes|goes} {smaller|less} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("${p} {is now|becomes|goes} {heavier|larger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("${p} {is now|becomes|goes} {lighter|smaller} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("${p} {is now|becomes|goes} {hotter|higher} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("${p} {is now|becomes|goes} {cooler|colder|lower} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("${p} {is now|becomes|goes} {farther|more distant|longer} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("${p} {is now|becomes|goes} {nearer|closer|shorter} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("${p} {is now|becomes|goes} {bigger|larger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("${p} {is now|becomes|goes} smaller than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("${p} {is now|becomes|goes} {bigger|larger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("${p} {is now|becomes|goes} smaller than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("${p} {is now|becomes|goes} {faster|quicker|speedier} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("${p} {is now|becomes|goes} {slower|more slowly} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("${p} {is now|becomes|goes} {after|later than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("${p} {is now|becomes|goes} {before|earlier than|sooner than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("${p} {is now|becomes|goes} {after|later than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("edge_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("${p} {is now|becomes|goes} {before|earlier than|sooner than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.declareSymbol("either_filter");
   $grammar.addRule("either_filter", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("constant_or_pairs", "pair", ["type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${param} {is|is equal to|is one of|is either} ${pair}"), ((param : C.ParamSlot, pair : [Ast.Value, Ast.Value]) : (C.FilterSlot)|null => {
        // param is a Value.VarRef
        //console.log('param: ' + param.name);
        const [v1, v2] = pair;
        let vtype = v1.getType();
        if (vtype.isBoolean) // "is equal to true or false" does not make sense
            return null;
        return C.makeFilter($loader, param, 'in_array', new Ast.Value.Array([v1, v2]));
    }), C.filterKeyFn, {  });
   $grammar.addRule("either_filter", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("constant_or_pairs", "pair", ["type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.valueArrayKeyFn>["type"]])], $locale._("the ${param} {is|is equal to|is one of|is either} ${pair}"), ((param : C.ParamSlot, pair : [Ast.Value, Ast.Value]) : (C.FilterSlot)|null => {
        // param is a Value.VarRef
        //console.log('param: ' + param.name);
        const [v1, v2] = pair;
        let vtype = v1.getType();
        if (vtype.isBoolean) // "is equal to true or false" does not make sense
            return null;
        return C.makeFilter($loader, param, 'in_array', new Ast.Value.Array([v1, v2]));
    }), C.filterKeyFn, {  });
   $grammar.addRule("either_filter", [new $runtime.NonTerminal("out_param_Any", "param", undefined), new $runtime.NonTerminal("constant_nor_pairs", "pair", ["type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${param} is {not|neither} ${pair}"), ((param : C.ParamSlot, pair : [Ast.Value, Ast.Value]) : (C.FilterSlot)|null => {
        // param is a Value.VarRef
        //console.log('param: ' + param.name);
        const [v1, v2] = pair;
        let vtype = v1.getType();
        if (vtype.isBoolean) // "is neither true nor false" does not make sense
            return null;
        return C.makeFilter($loader, param, 'in_array', new Ast.Value.Array([v1, v2]), true);
    }), C.filterKeyFn, {  });
   $grammar.declareSymbol("range");
   $grammar.addRule("range", [new $runtime.NonTerminal("constant_Numeric", "v1", undefined), new $runtime.NonTerminal("constant_Numeric", "v2", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void)])], $locale._("between ${v1} and ${v2}"), ((v1 : Ast.Value, v2 : Ast.Value) : ([Ast.Value, Ast.Value])|null => {
        assert(v1.getType().equals(v2.getType()));
        if (v1.equals(v2))
            return null;
        return [v1, v2];
    }), C.valueArrayKeyFn, {  });
   $grammar.addRule("range", [new $runtime.NonTerminal("constant_Numeric", "v1", undefined), new $runtime.NonTerminal("constant_Numeric", "v2", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void)])], $locale._("in the range from ${v1} to ${v2}"), ((v1 : Ast.Value, v2 : Ast.Value) : ([Ast.Value, Ast.Value])|null => {
        assert(v1.getType().equals(v2.getType()));
        if (v1.equals(v2))
            return null;
        return [v1, v2];
    }), C.valueArrayKeyFn, {  });
   $grammar.declareSymbol("range_filter");
   $grammar.addRule("range_filter", [new $runtime.NonTerminal("out_param_Any", "param", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("range", "range", ["type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("the ${param} is ${range}"), ((param : C.ParamSlot, range : [Ast.Value, Ast.Value]) : (C.FilterSlot)|null => {
        const [v1, v2] = range;
        const f1 = C.makeFilter($loader, param, '>=', v1);
        const f2 = C.makeFilter($loader, param, '<=', v2);
        if (!f1 || !f2)
            return null;
        return { schema: f1.schema, ptype: f1.ptype,
            ast: new Ast.BooleanExpression.And(null, [f1.ast, f2.ast]) };
    }), C.filterKeyFn, {  });
   $grammar.declareSymbol("with_filter");
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("the ${p} equal to ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '==', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined)], $locale._("the ${p} {containing|including} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {in the|in its|in their} ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   if ($options.flags.schema_org) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined)], $locale._("the ${p} {being|containing} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   if ($options.flags.schema_org) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {as|in the} ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String_ContextRef", "x", undefined)], $locale._("the ${p} equal to ${x}"), ((p : C.ParamSlot, x : Ast.ContextRefValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String_ContextRef", "x", undefined)], $locale._("the ${p} {containing|including} ${x}"), ((p : C.ParamSlot, x : Ast.ContextRefValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_String_ContextRef", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {in the|in its|in their} ${p}"), ((x : Ast.ContextRefValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   if ($options.flags.schema_org) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String_ContextRef", "x", undefined)], $locale._("the ${p} {being|containing} ${x}"), ((p : C.ParamSlot, x : Ast.ContextRefValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   if ($options.flags.schema_org) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_String_ContextRef", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {as|in the} ${p}"), ((x : Ast.ContextRefValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '=~', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("constant_String", "y", undefined)], $locale._("the ${p} containing both ${x} and ${y}"), ((p : C.ParamSlot, x : Ast.Value, y : Ast.Value) : (C.FilterSlot)|null => C.makeAndFilter($loader, p, '=~', [x, y])), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("constant_String", "y", undefined)], $locale._("the ${p} containing neither ${x} nor ${y}"), ((p : C.ParamSlot, x : Ast.Value, y : Ast.Value) : (C.FilterSlot)|null => C.makeAndFilter($loader, p, '=~', [x, y], true)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("constant_String", "y", undefined), new $runtime.NonTerminal("the_out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("both ${x} and ${y} in ${p}"), ((x : Ast.Value, y : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeAndFilter($loader, p, '=~', [x, y])), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("constant_String", "y", undefined)], $locale._("the ${p} containing either ${x} or ${y}"), ((p : C.ParamSlot, x : Ast.Value, y : Ast.Value) : (C.FilterSlot)|null => C.makeOrFilter($loader, p, '=~', [x, y])), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("constant_String", "y", undefined), new $runtime.NonTerminal("the_out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("either ${x} or ${y} in ${p}"), ((x : Ast.Value, y : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeOrFilter($loader, p, '=~', [x, y])), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.String)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("constant_String", "y", undefined)], $locale._("the ${p} {containing|including} ${x} {but not|without|but no} ${y}"), ((p : C.ParamSlot, x : Ast.Value, y : Ast.Value) : (C.FilterSlot)|null => C.makeButFilter($loader, p, '=~', [x, y])), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("${p} {greater than|higher than|larger than|more than|at least|not less than} ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("${p} {smaller than|lower than|less than|at most|not more than} ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or more|or higher|or greater|or above} the ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or less|or lower|or below} the ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("over ${x} ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("${p} {more expensive|more costly|more} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("${p} {less expensive|cheaper|less} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Currency", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or more|or above} the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Currency", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or less|or cheaper|or below} the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("${p} longer than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("${p} shorter than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Measure_ms", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or longer|or more} the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Measure_ms", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or shorter|or less} the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("${p} {larger|more} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("${p} {smaller|less} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Measure_byte", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or larger|or more} the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Measure_byte", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} {or smaller|or less} the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("${p} {heavier|larger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("${p} {lighter|smaller} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Measure_kg", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} or more the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Measure_kg", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("${x} or less the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Measure_kg", "x", undefined), new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("over ${x} ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("${p} {hotter|higher} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("${p} {cooler|colder|lower} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("${p} {farther|more distant|longer} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("${p} {nearer|closer|shorter} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("${p} {larger|bigger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("${p} smaller than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("${p} {larger|bigger} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("${p} smaller than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("${p} {faster|quicker|speedier} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("${p} {slower|more slowly} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("${p} {after|later than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("${p} {before|earlier than|sooner than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("${p} {after|later than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("${p} {before|earlier than|sooner than} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("{greater|higher|larger|more} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Number", "x", undefined)], $locale._("{smaller|lower|less} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.NumberValue) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("{more expensive|more costly|more} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Currency)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Currency", "x", undefined)], $locale._("{less expensive|cheaper|less} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("longer ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('ms'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_ms", "x", undefined)], $locale._("shorter ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("{larger|more} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('byte'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_byte", "x", undefined)], $locale._("{smaller|less} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("{heavier|larger} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('kg'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_kg", "x", undefined)], $locale._("{lighter|smaller} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("{hotter|higher} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('C'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_C", "x", undefined)], $locale._("{cooler|colder|lower} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("{farther|more distant|longer} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m", "x", undefined)], $locale._("{nearer|closer|shorter} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("{bigger|larger} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m2'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m2", "x", undefined)], $locale._("smaller ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("{bigger|larger} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('m3'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_m3", "x", undefined)], $locale._("smaller ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("{faster|quicker|speedier} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((new Type.Measure('mps'))) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Measure_mps", "x", undefined)], $locale._("{slower|more slowly} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("later ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Date)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Date", "x", undefined)], $locale._("{earlier|sooner} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("later ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Time)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_Time", "x", undefined)], $locale._("{earlier|sooner} ${p} than ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       if ($options.flags.range_filters) {
           $grammar.addRule("with_filter", [new $runtime.NonTerminal("range_with_filter", "f", undefined)], "${f}", ((f : C.FilterSlot) : (C.FilterSlot)|null => f), C.filterKeyFn, {  });
       }
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "param", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("no ${param}"), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, param, '==', new Ast.Value.Number(0))), C.filterKeyFn, {  });
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "param", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Number)) as ReturnType<typeof C.paramKeyFn>["type"]])], $locale._("zero ${param}"), ((param : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, param, '==', new Ast.Value.Number(0))), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("${p} containing ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, 'contains', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("${p} containing no ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, 'contains', x, true)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Any", "x", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", undefined)], $locale._("${x} in the ${p}"), ((x : Ast.Value, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, 'contains', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("both_prefix", undefined, undefined), new $runtime.NonTerminal("constant_pairs", "pair", ["type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${p} containing ${both_prefix} ${pair}"), ((p : C.ParamSlot, $0 : string, pair : [Ast.Value, Ast.Value]) : (C.FilterSlot)|null => C.makeAndFilter($loader, p, 'contains', pair)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("both_prefix", undefined, undefined), new $runtime.NonTerminal("constant_pairs", "pair", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 1, "type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void)])], $locale._("${both_prefix} ${pair} in the ${p}"), (($0 : string, pair : [Ast.Value, Ast.Value], p : C.ParamSlot) : (C.FilterSlot)|null => C.makeAndFilter($loader, p, 'contains', pair)), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("constant_or_pairs", "pair", ["type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${p} containing either ${pair}"), ((p : C.ParamSlot, pair : [Ast.Value, Ast.Value]) : (C.FilterSlot)|null => C.makeOrFilter($loader, p, 'contains', pair)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_or_pairs", "pair", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.valueArrayKeyFn> ? string : void)])], $locale._("either ${pair} in the ${p}"), ((pair : [Ast.Value, Ast.Value], p : C.ParamSlot) : (C.FilterSlot)|null => C.makeOrFilter($loader, p, 'contains', pair)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "p", ["type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), ((Type.Any)) as ReturnType<typeof C.paramKeyFn>["type"]]), new $runtime.NonTerminal("constant_String", "x", undefined), new $runtime.NonTerminal("constant_String", "y", undefined)], $locale._("${p} {containing|including} ${x} {but not|without|but no} ${y}"), ((p : C.ParamSlot, x : Ast.Value, y : Ast.Value) : (C.FilterSlot)|null => C.makeButFilter($loader, p, 'contains', [x, y])), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined)], $locale._("{no|zero} ${p}"), ((p : C.ParamSlot) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'count', '*', '==', new Ast.Value.Number(0))), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", undefined)], $locale._("${x} ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'count', '*', '==', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined)], $locale._("{no|zero} ${p}"), ((p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '==', new Ast.Value.Number(0))), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined)], $locale._("${x} ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '==', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 1, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{no|zero} ${p} {with|having} ${f} {lower than|below} ${x}"), ((p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter =  C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '==', new Ast.Value.Number(0));
    }), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 1, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{no|zero} ${p} {with|having} ${f} {greater than|above} ${x}"), ((p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '==', new Ast.Value.Number(0));
    }), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 1, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${p} {with|having} ${f} {greater than|above} ${x}"), ((p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', new Ast.Value.Number(1));

    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 1, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${p} {with|having} ${f} {lower than|below} ${x}"), ((p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', new Ast.Value.Number(1));
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "f", undefined)], $locale._("${p} {with|having} ${f}"), ((p : C.ParamSlot, f : C.FilterSlot) : (C.FilterSlot)|null => {
        return C.makeAggregateFilterWithFilter(p, f, 'count', '*', '>=', new Ast.Value.Number(1));
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "v", undefined), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 2, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("${v} ${p} {with|having} ${f} {greater than|above} ${x}"), ((v : Ast.NumberValue, p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '==', v);
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", undefined)], $locale._("{more than|at least|no fewer than} ${x} ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'count', '*', '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", undefined)], $locale._("{fewer than|at most|no more than} ${x} ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'count', '*', '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined)], $locale._("{more than|at least|no fewer than} ${x} ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "x", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined)], $locale._("{fewer than|at most|no more than} ${x} ${p}"), ((x : Ast.NumberValue, p : C.ParamSlot) : (C.FilterSlot)|null => C.makeFilter($loader, p, '<=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "v", undefined), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 2, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("no more than ${v} ${p} {with|having} ${f} {lower than|below} ${x}"), ((v : Ast.NumberValue, p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '<=', v);
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "v", undefined), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 2, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("at most ${v} ${p} {with|having} ${f} {lower than|below} ${x}"), ((v : Ast.NumberValue, p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '<=', v);
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "v", undefined), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 2, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("fewer than ${v} ${p} {with|having} ${f} {lower than|below} ${x}"), ((v : Ast.NumberValue, p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '<=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '<=', v);
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "v", undefined), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 2, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("more than ${v} ${p} {with|having} ${f} {greater than|above} ${x}"), ((v : Ast.NumberValue, p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', v);
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("constant_Number", "v", undefined), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 2, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("at least ${v} ${p} {with|having} ${f} {greater than|above} ${x}"), ((v : Ast.NumberValue, p : C.ParamSlot, f : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => {
        const filter = C.makeFilter($loader, f, '>=', x);
        return C.makeAggregateFilterWithFilter(p, filter, 'count', '*', '>=', v);
    }), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{total|sum} ${p} {of|being} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'sum', null, '==', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{total|sum} ${p} {greater than|more than|above} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'sum', null, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{total|sum} ${p} {lower than|less than|below} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'sum', null, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{total|sum} ${f} of ${p} {of|being} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'sum', f, '==', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{total|sum} ${f} of ${p} {greater than|more than|higher than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'sum', f, '>=', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{total|sum} ${f} of ${p} {smaller than|less than|lower than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'sum', f, '>=', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("average ${p} {of|being} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'avg', null, '==', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("average ${p} {greater than|more than|above} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'avg', null, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("average ${p} {lower than|less than|below} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'avg', null, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("average ${f} of ${p} {of|being} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'avg', f, '==', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("average ${f} of ${p} {greater than|more than|higher than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'avg', f, '>=', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("average ${f} of ${p} {smaller than|less than|lower than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'avg', f, '>=', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{maximum|highest} ${p} {of|being} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'max', null, '==', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{maximum|highest} ${p} {greater than|more than|above} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'max', null, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{maximum|highest} ${p} {lower than|less than|below} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'max', null, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{maximum|highest} ${f} of ${p} {of|being} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'max', f, '==', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{maximum|highest} ${f} of ${p} {greater than|more than|higher than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'max', f, '>=', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{maximum|highest} ${f} of ${p} {smaller than|less than|lower than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'max', f, '>=', x)), C.filterKeyFn, {  });
   }
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{minimum|lowest} ${p} {of|being} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'min', null, '==', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{minimum|lowest} ${p} {greater than|more than|above} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'min', null, '>=', x)), C.filterKeyFn, {  });
   $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Array__Any", "p", ["is_numeric_elem" as ("is_numeric_elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric_elem"]]), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "elem" as ("elem" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{minimum|lowest} ${p} {lower than|less than|below} ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'min', null, '<=', x)), C.filterKeyFn, {  });
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{minimum|lowest} ${f} of ${p} {of|being} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'min', f, '==', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{minimum|lowest} ${f} of ${p} {greater than|more than|higher than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'min', f, '>=', x)), C.filterKeyFn, {  });
   }
   if (!$options.flags.turking) {
       $grammar.addRule("with_filter", [new $runtime.NonTerminal("out_param_Any", "f", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("constant_Numeric", "x", ["type" as ("type" extends keyof ReturnType<typeof C.valueKeyFn> ? string : void), 0, "type" as ("type" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void)])], $locale._("{minimum|lowest} ${f} of ${p} {smaller than|less than|lower than} ${x}"), ((f : C.ParamSlot, p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeAggregateFilter(p, 'min', f, '>=', x)), C.filterKeyFn, {  });
   }
   $grammar.declareSymbol("range_with_filter");
   $grammar.addRule("range_with_filter", [new $runtime.NonTerminal("out_param_Any", "param", ["is_numeric" as ("is_numeric" extends keyof ReturnType<typeof C.paramKeyFn> ? string : void), (true) as ReturnType<typeof C.paramKeyFn>["is_numeric"]]), new $runtime.NonTerminal("range", "range", undefined)], $locale._("${param} ${range}"), ((param : C.ParamSlot, range : [Ast.Value, Ast.Value]) : (C.FilterSlot)|null => {
        const [v1, v2] = range;
        const f1 = C.makeFilter($loader, param, '>=', v1);
        const f2 = C.makeFilter($loader, param, '<=', v2);
        if (!f1 || !f2)
            return null;
        return { schema: f1.schema, ptype: f1.ptype,
            ast: new Ast.BooleanExpression.And(null, [f1.ast, f2.ast]) };
    }), C.filterKeyFn, {  });
   $grammar.declareSymbol("both_prefix");
   $grammar.addRule("both_prefix", [], $locale._("both"), (() : (string)|null => "both"), undefined, { identity: (true) });
   $grammar.declareSymbol("nearby_filter");
   $grammar.addRule("nearby_filter", [], $locale._("here"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('geo', '==', HERE)), undefined, {  });
   $grammar.addRule("nearby_filter", [], $locale._("around here"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('geo', '==', HERE)), undefined, {  });
   $grammar.addRule("nearby_filter", [], $locale._("near here"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('geo', '==', HERE)), undefined, {  });
   $grammar.addRule("nearby_filter", [], $locale._("nearby"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('geo', '==', HERE)), undefined, {  });
   $grammar.addRule("nearby_filter", [], $locale._("around me"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('geo', '==', HERE)), undefined, {  });
   $grammar.addRule("nearby_filter", [], $locale._("in this area"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('geo', '==', HERE)), undefined, {  });
   $grammar.addRule("nearby_filter", [new $runtime.NonTerminal("constant_Location", "x", undefined)], $locale._("{in|around|near} ${x}"), ((x : Ast.LocationValue) : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('geo', '==', x)), undefined, {  });
   $grammar.declareSymbol("whose_npp_filter");
   $grammar.addRule("whose_npp_filter", [new $runtime.NonTerminal("out_param_Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("${p} is ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, '==', x)), C.filterKeyFn, {  });
   $grammar.addRule("whose_npp_filter", [new $runtime.NonTerminal("out_param_Any", "p", undefined), new $runtime.NonTerminal("constant_Any", "x", undefined)], $locale._("${p} is ${x}"), ((p : C.ParamSlot, x : Ast.Value) : (C.FilterSlot)|null => C.makeFilter($loader, p, 'contains', x)), C.filterKeyFn, {  });
   $grammar.declareSymbol("quality_filter");
   $grammar.addRule("quality_filter", [], $locale._("good"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('aggregateRating.ratingValue', '>=', new Ast.Value.Number(4))), undefined, {  });
   $grammar.addRule("quality_filter", [], $locale._("great"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('aggregateRating.ratingValue', '>=', new Ast.Value.Number(4))), undefined, {  });
   $grammar.addRule("quality_filter", [], $locale._("nice"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('aggregateRating.ratingValue', '>=', new Ast.Value.Number(4))), undefined, {  });
   $grammar.addRule("quality_filter", [], $locale._("decent"), (() : (C.DomainIndependentFilterSlot)|null => C.makeDomainIndependentFilter('aggregateRating.ratingValue', '>=', new Ast.Value.Number(4))), undefined, {  });
   $grammar.declareSymbol("within_filter");
   $grammar.addRule("within_filter", [new $runtime.NonTerminal("constant_Measure_m", "distance", undefined)], $locale._("within ${distance} {|radius|of here|from here|from me|of me|of this area|of my location|from current location}"), ((distance : Ast.Value) : (({ distance : Ast.Value, place : Ast.Value }))|null => ({ distance, place: HERE })), undefined, {  });
   $grammar.addRule("within_filter", [new $runtime.NonTerminal("constant_Measure_m", "distance", undefined), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("within ${distance} {|radius} {of|from} ${place}"), ((distance : Ast.Value, place : Ast.LocationValue) : (({ distance : Ast.Value, place : Ast.Value }))|null => ({ distance, place })), undefined, {  });
};
