"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Thingpedia
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.initArgparse = void 0;
const fs_1 = require("fs");
const path = __importStar(require("path"));
const util = __importStar(require("util"));
const licejs = __importStar(require("lice-js"));
const process_utils_1 = require("../lib/utils/process-utils");
const argutils_1 = require("./lib/argutils");
const LICENSES = {
    'BSD-3-Clause': 'bsd3',
    'BSD-2-Clause': 'bsd2',
    'MIT': 'mit',
    'CC0': 'cc0',
    'Apache-2.0': 'apache',
    'GPL-3.0': 'gpl3',
    'GPL-2.0': 'gpl2',
    'ISC': 'isc'
};
function initArgparse(subparsers) {
    const parser = subparsers.add_parser('init-project', {
        add_help: true,
        description: "Initialize a repository to develop Thingpedia devices."
    });
    parser.add_argument('--thingpedia-url', {
        required: false,
        default: argutils_1.DEFAULT_THINGPEDIA_URL,
        help: `base URL of Thingpedia server to contact; defaults to '${argutils_1.DEFAULT_THINGPEDIA_URL}'`
    });
    parser.add_argument('--developer-key', {
        required: false,
        default: '',
        help: `developer key to use when contacting Thingpedia`
    });
    parser.add_argument('--description', {
        required: false,
        default: '',
        help: "A description for the repository"
    });
    parser.add_argument('--author', {
        required: false,
        help: "The name and email to use as the author and copyright owner"
    });
    parser.add_argument('--license', {
        required: false,
        default: 'BSD-3-Clause',
        choices: Object.keys(LICENSES),
        help: "The code license to use for the repository, as a SPDX identifier (defaults to BSD-3-Clause)"
    });
    parser.add_argument('output_dir', {});
}
exports.initArgparse = initArgparse;
async function copyTree(from, to) {
    for await (const entry of await fs_1.promises.opendir(from)) {
        if (entry.isDirectory()) {
            await fs_1.promises.mkdir(path.resolve(to, entry.name));
            await copyTree(path.resolve(from, entry.name), path.resolve(to, entry.name));
        }
        else if (entry.isSymbolicLink()) {
            const link = await fs_1.promises.readlink(path.resolve(from, entry.name));
            await fs_1.promises.symlink(path.relative(from, link), path.resolve(to, entry.name));
        }
        else {
            await fs_1.promises.copyFile(path.resolve(from, entry.name), path.resolve(to, entry.name));
        }
    }
}
async function execute(args) {
    try {
        await fs_1.promises.rmdir(args.output_dir);
    }
    catch (e) {
        if (e.code !== 'ENOENT') {
            console.error(`${args.output_dir} already exists and is not an empty directory`);
            return;
        }
    }
    const name = path.basename(args.output_dir);
    if (!args.author)
        args.author = `${await (0, argutils_1.getConfig)('user.name')} <${await (0, argutils_1.getConfig)('user.email')}>`;
    await fs_1.promises.mkdir(args.output_dir, { recursive: true });
    console.log('Initializing Git repository...');
    await (0, process_utils_1.execCommand)(['git', 'init'], { debug: true, cwd: args.output_dir });
    await (0, process_utils_1.execCommand)(['git', 'config', 'thingpedia.url', args.thingpedia_url], { debug: true, cwd: args.output_dir });
    if (args.developer_key)
        await (0, process_utils_1.execCommand)(['git', 'config', 'thingpedia.developer-key', args.developer_key], { debug: true, cwd: args.output_dir });
    console.log('Copying skeleton code...');
    await copyTree(path.resolve(path.dirname(module.filename), '../../starter/custom'), args.output_dir);
    console.log('Writing metadata...');
    const ourPackageJSON = JSON.parse(await fs_1.promises.readFile(path.resolve(path.dirname(module.filename), '../../package.json'), { encoding: 'utf8' }));
    const ourdeps = {};
    for (const dep of ['thingpedia', 'uuid', 'byline', 'seedrandom', 'argparse', 'eslint'])
        ourdeps[dep] = ourPackageJSON.dependencies[dep] || ourPackageJSON.devDependencies[dep];
    const packageJSON = {
        name: name,
        description: args.description,
        version: '0.0.1',
        author: args.author,
        license: args.license,
        devDependencies: {
            'genie-toolkit': '^' + ourPackageJSON.version,
            ...ourdeps
        }
    };
    await fs_1.promises.writeFile(path.resolve(args.output_dir, 'package.json'), JSON.stringify(packageJSON, undefined, 2));
    const license = await util.promisify(licejs.createLicense)(LICENSES[args.license], {
        year: String((new Date).getFullYear()),
        organization: args.author,
        project: name,
        header: false
    });
    await fs_1.promises.writeFile(path.resolve(args.output_dir, 'LICENSE'), license.body);
    console.log('Installing dependencies...');
    await (0, process_utils_1.execCommand)(['npm', 'install'], { debug: true, cwd: args.output_dir });
    console.log('Creating initial commit...');
    await (0, process_utils_1.execCommand)(['git', 'add', '.'], { debug: true, cwd: args.output_dir });
    await (0, process_utils_1.execCommand)(['git', 'commit', '-m', 'Initial commit'], { debug: true, cwd: args.output_dir });
    console.log('Success!');
}
exports.execute = execute;
//# sourceMappingURL=init-project.js.map