"use strict";
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2021 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Jake Wu <jmhw0123@gmail.com>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.initArgparse = exports.generateActionExamples = void 0;
const fs = __importStar(require("fs"));
const Tp = __importStar(require("thingpedia"));
const I18n = __importStar(require("../lib/i18n"));
const utils = __importStar(require("../lib/utils/misc-utils"));
const thingtalk_1 = require("thingtalk");
const canonical_example_constructor_1 = require("./autoqa/lib/canonical-example-constructor");
const constant_file_1 = require("./lib/constant-file");
const utils_1 = require("./autoqa/wikidata/utils");
const sample_utils_1 = require("../lib/dataset-tools/mturk/sample-utils");
const base_canonical_generator_1 = require("./autoqa/lib/base-canonical-generator");
const base_canonical_generator_2 = __importDefault(require("./autoqa/lib/base-canonical-generator"));
const thingtalk_2 = require("../lib/utils/thingtalk");
const lib_1 = require("../lib");
const Path = require("path");
function typeToString(type) {
    const elemType = (0, utils_1.getElementType)(type);
    if (elemType instanceof thingtalk_1.Type.Entity)
        return elemType.type;
    return type.toString();
}
function countArgTypes(schema) {
    const count = {};
    for (const arg of schema.iterateArguments()) {
        const typestr = typeToString(arg.type);
        if (!typestr)
            continue;
        count[typestr] = (count[typestr] || 0) + 1;
    }
    return count;
}
function checkOutputPath(args) {
    if (!args.output) {
        const outputDir = Path.join(Path.dirname(args.thingpedia), "test");
        if (!fs.existsSync(outputDir))
            fs.mkdirSync(outputDir);
        args.output = fs.createWriteStream(Path.join(outputDir, "samples.tsv"));
    }
}
function parseConstantKeys(classDef, sampleMeta, fname, arg) {
    //TODO: also use enum canonicals?
    const keys = (0, sample_utils_1.makeLookupKeys)('@' + classDef.kind + '.' + fname, arg.name, arg.type);
    let sampleConstants = [];
    for (const key of keys) {
        if (sampleMeta[key]) {
            sampleConstants = sampleMeta[key];
            break;
        }
    }
    return sampleConstants;
}
function retrieveSampleValues(classDef, sampleMeta, fname, arg) {
    if (arg.type instanceof thingtalk_1.Type.Enum)
        return arg.type.entries.slice(0, 10).map(utils.clean);
    const sampleConstants = parseConstantKeys(classDef, sampleMeta, fname, arg);
    return sampleConstants.map((v) => {
        if ((arg.type === thingtalk_1.Type.String) ||
            (arg.type instanceof thingtalk_1.Type.Array && (arg.type.elem === thingtalk_1.Type.String)))
            return v.value;
        return v.display;
    });
}
function toThingtalkValue(classDef, sampleMeta, fname, arg, value) {
    value = value.toLowerCase();
    let type = arg.type;
    if (type instanceof thingtalk_1.Type.Entity) {
        const sampleConstants = parseConstantKeys(classDef, sampleMeta, fname, arg);
        const kv = sampleConstants.find((item) => { var _a; return ((_a = item.value.display) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === value; });
        const ttValue = kv === null || kv === void 0 ? void 0 : kv.value.value.toLowerCase();
        const ttDisplay = kv === null || kv === void 0 ? void 0 : kv.value.display.toLowerCase();
        return { value: new thingtalk_1.Ast.Value.Entity(ttValue, type.type, ttDisplay), op: "==" };
    }
    if (type instanceof thingtalk_1.Type.Enum)
        return { value: new thingtalk_1.Ast.Value.Enum(value), op: "==" };
    if (type === thingtalk_1.Type.String)
        return { value: new thingtalk_1.Ast.Value.String(value), op: "=~" };
    if (type === thingtalk_1.Type.Number)
        return { value: new thingtalk_1.Ast.Value.Number(parseFloat(value)), op: "==" };
    if (type instanceof thingtalk_1.Type.Array) {
        type = type.elem;
        if (type instanceof thingtalk_1.Type.Entity) {
            const sampleConstants = parseConstantKeys(classDef, sampleMeta, fname, arg);
            const kv = sampleConstants.find((item) => { var _a; return ((_a = item.value.display) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === value; });
            const ttValue = kv === null || kv === void 0 ? void 0 : kv.value.value.toLowerCase();
            const ttDisplay = kv === null || kv === void 0 ? void 0 : kv.value.display.toLowerCase();
            return { value: new thingtalk_1.Ast.Value.Entity(ttValue, type.type, ttDisplay), op: "contains" };
        }
        else if (type === thingtalk_1.Type.String) {
            return { value: new thingtalk_1.Ast.Value.String(value), op: "contains~" };
        }
        else {
            throw new Error(`Unsupported value type: ${type}`);
        }
    }
    throw new Error(`Unsupported value type: ${type.prettyprint()}`);
}
function toTSV(device, data, useHeading) {
    let headings = '';
    if (useHeading)
        headings = ["id", "utterance", "thingtalk"].join('\t') + '\n';
    const rows = data.reduce((acc, colValue, idx) => {
        const id = `${device}-${idx.toLocaleString('en-US', { minimumIntegerDigits: 3, useGrouping: false })}`;
        const tmp = [
            id,
            colValue["utterance"],
            colValue["thingtalk"]
        ];
        return acc.concat([tmp.join('\t')]);
    }, []).join('\n');
    return `${headings}${rows}`;
}
function generateBaseCanonicalAnnotation(func, arg, typeCounts, queries, remove_existing_canonicals) {
    const canonicalAnnotation = {};
    if (remove_existing_canonicals) {
        (0, base_canonical_generator_2.default)(canonicalAnnotation, arg.name, arg.type);
    }
    else {
        const existingCanonical = arg.getNaturalLanguageAnnotation('canonical') || {};
        if (typeof existingCanonical === 'string')
            canonicalAnnotation.base = [existingCanonical];
        else if (Array.isArray(existingCanonical))
            canonicalAnnotation.base = existingCanonical;
        else if (typeof existingCanonical === 'object')
            Object.assign(canonicalAnnotation, existingCanonical);
    }
    // remove function name in arg name, normally it's repetitive
    for (const [key, value] of Object.entries(canonicalAnnotation)) {
        if (base_canonical_generator_1.PARTS_OF_SPEECH.includes(key)) {
            canonicalAnnotation[key] = value.map((c) => {
                if (c.startsWith(func.name.toLowerCase() + ' '))
                    return c.slice(func.name.toLowerCase().length + 1);
                return c;
            });
        }
    }
    // copy base canonical if property canonical is missing
    if (canonicalAnnotation.base && !canonicalAnnotation.property)
        canonicalAnnotation.property = [...canonicalAnnotation.base];
    const typestr = typeToString(func.getArgType(arg.name));
    if (typestr && typeCounts[typestr] === 1) {
        // if an entity is unique, allow dropping the property name entirely
        // FIXME: consider type hierarchy, or probably drop it entirely
        if (canonicalAnnotation.property && !queries.includes(typestr.substring(typestr.indexOf(':') + 1))) {
            if (!canonicalAnnotation.property.includes('#'))
                canonicalAnnotation.property.push('#');
        }
        // if property is missing, use the type information
        if (!('property' in canonicalAnnotation)) {
            const base = utils.clean(typestr.substring(typestr.indexOf(':') + 1));
            canonicalAnnotation['property'] = [base];
            canonicalAnnotation['base'] = [base];
        }
        // if it's the only people entity, adding adjective form
        // E.g., author for review - bob's review
        //       byArtist for MusicRecording - bob's song
        if (typestr.endsWith(':Person'))
            canonicalAnnotation.adjective = ["# 's", '#'];
        // if it's the only date, adding argmin/argmax/base_projection
        if (typestr === 'Date') {
            canonicalAnnotation.adjective_argmax = ["most recent", "latest", "last", "newest"];
            canonicalAnnotation.adjective_argmin = ["earliest", "first", "oldest"];
            canonicalAnnotation.base_projection = ['date'];
        }
    }
    return canonicalAnnotation;
}
function generateActionExamples(query, arg, baseCanonicalAnnotation, sampleValues) {
    const examples = [];
    const queryCanonical = Array.isArray(query.nl_annotations.canonical) ? query.nl_annotations.canonical[0] : query.nl_annotations.canonical;
    for (const [pos, canonicals] of Object.entries(baseCanonicalAnnotation)) {
        if (!base_canonical_generator_1.PARTS_OF_SPEECH.includes(pos))
            continue;
        for (const canonical of canonicals) {
            if (base_canonical_generator_1.PROJECTION_PARTS_OF_SPEECH.includes(pos)) {
                examples.push(...generateActionExamplesByPOS(query, queryCanonical, arg, canonical, pos));
            }
            else {
                for (const value of sampleValues)
                    examples.push(...generateActionExamplesByPOS(query, queryCanonical, arg, canonical, pos, value));
            }
        }
    }
    return examples;
}
exports.generateActionExamples = generateActionExamples;
// FIXME: Consider renmaing ParaphraseExample's queryCanonical property so we don't cause confusion here.
function generateActionExamplesByPOS(action, queryCanonical, argument, argumentCanonical, pos, value) {
    function example(utterance) {
        return { query: action.name, queryCanonical, argument: argument.name, utterance, value, paraphrases: [] };
    }
    if (!base_canonical_generator_1.PROJECTION_PARTS_OF_SPEECH.includes(pos)) {
        if (!argumentCanonical.includes('#'))
            argumentCanonical = argumentCanonical + ' #';
    }
    const predicate = typeof value === 'string' ? argumentCanonical.replace('#', value) : argumentCanonical;
    switch (pos) {
        case 'base':
            return [
                example(`${queryCanonical}`),
                example(`${queryCanonical} with the ${argumentCanonical}?`),
            ];
        case 'property':
        case 'property_true':
        case 'property_false':
            return [
                example(`${queryCanonical} with ${predicate}.`),
            ];
        case 'verb':
        case 'verb_true':
        case 'verb_false':
            return [
                example(`${queryCanonical} that ${predicate}.`),
            ];
        case 'passive_verb':
        case 'passive_verb_true':
        case 'passive_verb_false':
        case 'preposition':
        case 'preposition_true':
        case 'preposition_false':
            return [
                example(`${queryCanonical} ${predicate}.`),
            ];
        case 'reverse_property':
        case 'reverse_property_true':
        case 'reverse_property_false':
            return [
                example(`${queryCanonical} ${predicate}?`)
            ];
        case 'adjective':
        case 'adjective_true':
        case 'adjective_false':
            return [
                example(`${queryCanonical} ${predicate} .`),
            ];
        case 'reverse_verb':
            return [
                example(`${queryCanonical} ${predicate}`)
            ];
        default:
            return [];
    }
}
function generateFilterAst(device, func, property, operator, value) {
    const invocation = new thingtalk_1.Ast.InvocationExpression(null, new thingtalk_1.Ast.Invocation(null, new thingtalk_1.Ast.DeviceSelector(null, device, null, null), func, [], null), null);
    const filter = new thingtalk_1.Ast.AtomBooleanExpression(null, property, operator, value, // 
    null);
    const filtered = new thingtalk_1.Ast.FilterExpression(null, invocation, filter, null);
    const statement = new thingtalk_1.Ast.ExpressionStatement(null, new thingtalk_1.Ast.ChainExpression(null, [filtered], null));
    return new thingtalk_1.Ast.Program(null, [], [], [statement], {});
}
function generateProjectionAst(device, func, property) {
    const invocation = new thingtalk_1.Ast.InvocationExpression(null, new thingtalk_1.Ast.Invocation(null, new thingtalk_1.Ast.DeviceSelector(null, device, null, null), func, [], null), null);
    const projection = new thingtalk_1.Ast.ProjectionExpression(null, invocation, [property], [], [], null);
    const statement = new thingtalk_1.Ast.ExpressionStatement(null, new thingtalk_1.Ast.ChainExpression(null, [projection], null));
    return new thingtalk_1.Ast.Program(null, [], [], [statement], {});
}
function generateActionAst(func, property, value) {
    const inputParam = new thingtalk_1.Ast.InputParam(null, property, value);
    const action = new thingtalk_1.Ast.FunctionCallExpression(null, func, [inputParam], null);
    const statement = new thingtalk_1.Ast.ExpressionStatement(null, new thingtalk_1.Ast.ChainExpression(null, [action], null));
    return new thingtalk_1.Ast.Program(null, [], [], [statement], {});
}
function initArgparse(subparsers) {
    const parser = subparsers.add_parser('sample-synthetic-data', {
        add_help: true,
        description: "Automatically generate samples from the canonicals"
    });
    parser.add_argument('-o', '--output', {
        required: false,
        type: fs.createWriteStream
    });
    parser.add_argument('-l', '--locale', {
        default: 'en-US',
        help: `BGP 47 locale tag of the natural language being processed (defaults to en-US).`
    });
    parser.add_argument('-c', '--constants', {
        required: false,
        help: 'TSV file containing sampled constant values to be used.'
    });
    parser.add_argument('-t', '--thingpedia', {
        required: true,
        help: 'Path to ThingTalk file containing class definitions.'
    });
    parser.add_argument('-d', '--device', {
        required: true,
        help: `The name of the device to be synthesized.`
    });
    parser.add_argument('-f', '--function', {
        required: false,
        help: `A specific function to be sampled`
    });
}
exports.initArgparse = initArgparse;
async function execute(args) {
    process.stdout.write("Generating samples... ");
    checkOutputPath(args);
    const tpClient = new Tp.FileClient(args);
    const schemaRetriever = new thingtalk_1.SchemaRetriever(tpClient, null, false);
    const deviceClass = await schemaRetriever.getFullSchema(args.device);
    const baseTokenizer = I18n.get(args.locale).getTokenizer();
    const functionNames = Object.keys(deviceClass.queries).concat(Object.keys(deviceClass.actions));
    const sampleMeta = await (0, constant_file_1.parseConstantFile)(args.locale, args.constants);
    const utteranceThingtalkPairs = [];
    const options = { locale: args.locale, timezone: undefined, includeEntityValue: true };
    for (const fname of functionNames) {
        if (args.function && fname !== args.function)
            continue;
        const func = deviceClass.queries[fname] || deviceClass.actions[fname];
        const typeCounts = countArgTypes(func);
        for (const arg of func.iterateArguments()) {
            const sampleValues = retrieveSampleValues(deviceClass, sampleMeta, fname, arg);
            const canonicalAnnotation = generateBaseCanonicalAnnotation(func, arg, typeCounts, functionNames, false);
            let utteranceExamples;
            if (deviceClass.actions[fname])
                utteranceExamples = generateActionExamples(func, arg, canonicalAnnotation, sampleValues);
            else
                utteranceExamples = (0, canonical_example_constructor_1.generateExamples)(func, arg, canonicalAnnotation, sampleValues);
            for (const ex of utteranceExamples) {
                const example = ex;
                const prepUtterance = baseTokenizer.tokenize(example.utterance).tokens.join(' ');
                let program;
                if (deviceClass.actions[fname]) {
                    if (example.value) {
                        const { value, } = toThingtalkValue(deviceClass, sampleMeta, fname, arg, `${example.value}`);
                        program = generateActionAst(fname, example.argument, value);
                    }
                    else {
                        continue;
                    }
                }
                else {
                    if (example.value) {
                        const { value, op } = toThingtalkValue(deviceClass, sampleMeta, fname, arg, `${example.value}`);
                        program = generateFilterAst(args.device, fname, example.argument, op, value);
                    }
                    else {
                        program = generateProjectionAst(args.device, fname, example.argument);
                    }
                }
                try {
                    const entityDummy = lib_1.EntityUtils.makeDummyEntities(prepUtterance);
                    example.thingtalk = (0, thingtalk_2.serializePrediction)(program, prepUtterance, entityDummy, options).join(' ');
                }
                catch (err) {
                    console.log(prepUtterance);
                    console.log(program.prettyprint());
                    throw err;
                }
                example.utterance = prepUtterance;
                utteranceThingtalkPairs.push(example);
            }
        }
    }
    const output = toTSV(args.device, utteranceThingtalkPairs, false);
    // console.log(output);
    args.output.write(output);
    process.stdout.write(`Done!\nFile location: ${args.output.path}\n`);
}
exports.execute = execute;
//# sourceMappingURL=sample-synthetic-data.js.map