"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020-2021 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.initArgparse = void 0;
const fs = __importStar(require("fs"));
const thingtalk_1 = require("thingtalk");
const StreamUtils = __importStar(require("../../../lib/utils/stream-utils"));
const base_canonical_generator_1 = __importDefault(require("../lib/base-canonical-generator"));
const misc_utils_1 = require("../../../lib/utils/misc-utils");
const utils_1 = require("./utils");
const manual_annotations_1 = require("./manual-annotations");
function canonical(domain) {
    if (domain === 'common_name')
        return ['person', 'people'];
    return (0, misc_utils_1.clean)(domain);
}
class SchemaProcessor {
    constructor(options) {
        this._domains = options.domains;
        this._propertiesByDomain = options.properties;
        this._labels = options.labels;
        this._typeSystem = options.typeSystem;
        this._subtypeMap = options.subtypeMap;
        this._output = options.output;
        this._outputEntities = options.outputEntities;
        this._entities = new Map();
        this._manual = options.manual;
        this._useWikidataAltLabels = options.useWikidataAltLabels;
    }
    async _getArgCanonical(property, label, type) {
        if (this._manual && property in manual_annotations_1.MANUAL_PROPERTY_CANONICAL_OVERRIDE)
            return manual_annotations_1.MANUAL_PROPERTY_CANONICAL_OVERRIDE[property];
        const canonical = {};
        (0, base_canonical_generator_1.default)(canonical, label, type);
        if (this._useWikidataAltLabels) {
            const altLabels = await (0, utils_1.getPropertyAltLabels)(property);
            if (altLabels) {
                for (const label of altLabels)
                    (0, base_canonical_generator_1.default)(canonical, label, type);
            }
        }
        return canonical;
    }
    _addPrimEntity(type, subtype_of) {
        if (this._entities.has(type)) {
            const entity = this._entities.get(type);
            if (subtype_of && !entity.subtype_of.includes(subtype_of))
                entity.subtype_of.push(`org.wikidata:` + subtype_of);
        }
        else {
            this._entities.set(type, {
                type: `org.wikidata:` + type,
                name: (0, misc_utils_1.clean)(type),
                is_well_known: false,
                has_ner_support: true,
                subtype_of: subtype_of ? [`org.wikidata:` + subtype_of] : []
            });
        }
    }
    _addSuperEntity(type) {
        const subtypes = this._subtypeMap.get(type);
        if (subtypes) {
            for (const subtype of this._subtypeMap.get(type))
                this._addPrimEntity(subtype, type);
        }
        this._entities.set(type, {
            type: `org.wikidata:` + type,
            name: (0, misc_utils_1.clean)(type.slice('p_'.length)),
            is_well_known: false,
            has_ner_support: false,
            subtype_of: ['org.wikidata:entity']
        });
    }
    async _genFunctionDef(domain) {
        const args = [
            new thingtalk_1.Ast.ArgumentDef(null, thingtalk_1.Ast.ArgDirection.OUT, 'id', new thingtalk_1.Type.Entity(`org.wikidata:${domain}`), {
                nl: { canonical: { base: ['name'], passive_verb: ['named', 'called'] } }
            })
        ];
        this._addPrimEntity(domain);
        for (const property of this._propertiesByDomain.get(domain)) {
            const label = this._labels.get(property);
            const name = (0, utils_1.argnameFromLabel)(label);
            // in case the property has the same name as the domain, drop it
            // it happens for country entities, probably added for the completeness of the kb
            if (name === domain)
                continue;
            let type;
            if (this._typeSystem === 'string') {
                type = new thingtalk_1.Type.Array(thingtalk_1.Type.String);
            }
            else {
                type = new thingtalk_1.Type.Array(new thingtalk_1.Type.Entity(`org.wikidata:p_${name}`));
                if (this._typeSystem === 'entity-plain')
                    this._addPrimEntity(`p_${name}`);
                else if (this._typeSystem === 'entity-hierarchical')
                    this._addSuperEntity(`p_${name}`);
            }
            const annotations = {
                nl: { canonical: await this._getArgCanonical(property, label, type) },
                impl: { wikidata_id: new thingtalk_1.Ast.Value.String(property) }
            };
            if (this._typeSystem === 'string')
                annotations.nl.string_values = 'p_' + name;
            args.push(new thingtalk_1.Ast.ArgumentDef(null, thingtalk_1.Ast.ArgDirection.OUT, name, type, annotations));
        }
        const qualifiers = { is_list: true, is_monitorable: false };
        const annotations = {
            nl: { canonical: [canonical(domain), ...this._domains.getWikidataTypeLabels(domain)] },
            impl: {
                handle_thingtalk: new thingtalk_1.Ast.Value.Boolean(true),
                csqa_type: new thingtalk_1.Ast.Value.String(this._domains.getCSQAType(domain)),
                wikidata_types: new thingtalk_1.Ast.Value.Array(this._domains.getWikidataTypes(domain).map((t) => new thingtalk_1.Ast.Value.String(t))),
                wikidata_subject: new thingtalk_1.Ast.Value.Array(this._domains.getWikidataSubjects(domain).map((t) => new thingtalk_1.Ast.Value.String(t)))
            }
        };
        return new thingtalk_1.Ast.FunctionDef(null, 'query', null, domain, [], qualifiers, args, annotations);
    }
    async run() {
        const queries = {};
        const actions = {};
        for (const domain of this._domains.domains)
            queries[domain] = await this._genFunctionDef(domain);
        const imports = [
            new thingtalk_1.Ast.MixinImportStmt(null, ['loader'], 'org.thingpedia.v2', []),
            new thingtalk_1.Ast.MixinImportStmt(null, ['config'], 'org.thingpedia.config.none', [])
        ];
        // add super entity type that is ancestor of every entity type
        this._entities.set('entity', {
            type: `org.wikidata:entity`,
            name: 'generic wikidata entity',
            is_well_known: false,
            has_ner_support: false,
            subtype_of: []
        });
        const entities = Array.from(this._entities.values()).map((entity) => {
            return new thingtalk_1.Ast.EntityDef(null, entity.type.slice('org.wikidata:'.length), entity.subtype_of.map((e) => e.slice('org.wikidata:'.length)), { impl: { has_ner: new thingtalk_1.Ast.Value.Boolean(!!entity.has_ner_support) } });
        });
        const classdef = new thingtalk_1.Ast.ClassDef(null, 'org.wikidata', null, { imports, queries, actions, entities }, {
            nl: {
                name: `Wikidata QA`,
                description: 'Natural language dialogues over Wikidata knowledge base.'
            },
        }, {
            is_abstract: false
        });
        this._output.end(classdef.prettyprint());
        this._outputEntities.end(JSON.stringify({
            result: 'ok',
            data: Array.from(this._entities.values())
        }, undefined, 2));
        await StreamUtils.waitFinish(this._output);
        await StreamUtils.waitFinish(this._outputEntities);
    }
}
function initArgparse(subparsers) {
    const parser = subparsers.add_parser('wikidata-process-schema', {
        add_help: true,
        description: "Generate schema.tt given a list of domains. "
    });
    parser.add_argument('-o', '--output', {
        required: true,
        type: fs.createWriteStream
    });
    parser.add_argument('--entities', {
        required: true,
        type: fs.createWriteStream
    });
    parser.add_argument('--domains', {
        required: true,
        help: 'the path to the file containing type mapping for each domain'
    });
    parser.add_argument('--properties', {
        required: true,
        help: 'properties by each domain'
    });
    parser.add_argument('--property-labels', {
        required: true,
        help: 'path to the JSON file containing default label for each property'
    });
    parser.add_argument('--type-system', {
        required: true,
        choices: ['entity-plain', 'entity-hierarchical', 'string'],
        help: 'design choices for the type system:\n' +
            'entity-plain: one entity type per property\n' +
            'entity-hierarchical: one entity type for each value, and the property type is the supertype of all types of its values\n' +
            'string: all property has a string type except id',
        default: 'entity-hierarchical'
    });
    parser.add_argument('--subtypes', {
        required: false,
        help: 'path to the JSON file containing subtypes for each property'
    });
    parser.add_argument('--manual', {
        action: 'store_true',
        help: 'Enable manual annotations.',
        default: false
    });
    parser.add_argument('--use-wikidata-alt-labels', {
        action: 'store_true',
        help: 'Enable wikidata alternative labels as annotations.',
        default: false
    });
}
exports.initArgparse = initArgparse;
async function execute(args) {
    const domains = new utils_1.Domains({ path: args.domains });
    await domains.init();
    const properties = await (0, utils_1.readJson)(args.properties);
    const subtypeMap = await (0, utils_1.readJson)(args.subtypes);
    const labels = await (0, utils_1.readJson)(args.property_labels);
    const schemaProcessor = new SchemaProcessor({
        domains,
        properties,
        labels,
        typeSystem: args.type_system,
        subtypeMap,
        output: args.output,
        outputEntities: args.entities,
        manual: args.manual,
        useWikidataAltLabels: args.use_wikidata_alt_labels
    });
    schemaProcessor.run();
}
exports.execute = execute;
//# sourceMappingURL=process-schema.js.map