"use strict";
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
//
/// <reference types="./stemmer" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stemmer_1 = __importDefault(require("stemmer"));
const pos_parser_1 = __importDefault(require("../../../lib/pos-parser"));
const base_canonical_generator_1 = require("./base-canonical-generator");
function stem(str) {
    if (str.endsWith(' #'))
        str = str.slice(0, -2);
    return str.split(' ').map(stemmer_1.default).join(' ');
}
class ConflictResolver {
    constructor(schema, candidates) {
        this.schema = schema;
        this.candidates = candidates;
        this.stemmedBaseCanonicals = {};
        for (const arg of schema.iterateArguments())
            this.stemmedBaseCanonicals[arg.name] = stem(arg.canonical);
    }
    resolve() {
        for (const [arg, candidatesByPos] of Object.entries(this.candidates)) {
            for (const [pos, candidates] of Object.entries(candidatesByPos)) {
                const filteredCandidates = [];
                for (const candidate of candidates) {
                    if (!this._hasConflict(arg, pos, candidate))
                        filteredCandidates.push(candidate);
                }
                this.candidates[arg][pos] = filteredCandidates;
            }
        }
    }
    _hasConflict(argument, pos, candidate) {
        // remove candidates that conflict with the default canonical of other arguments
        for (const [arg, stemmedBaseCanonical] of Object.entries(this.stemmedBaseCanonicals)) {
            if (arg !== argument && stemmedBaseCanonical === stem(candidate))
                return true;
        }
        // remove candidates that conflict with each other
        for (const [arg, candidatesByPos] of Object.entries(this.candidates)) {
            if (arg === argument)
                continue;
            for (const [pos, candidates] of Object.entries(candidatesByPos)) {
                // for non-projection canonical, we only care about the arguments having conflict types
                if (!base_canonical_generator_1.PROJECTION_PARTS_OF_SPEECH.includes(pos) && !this._hasConflictTypes(arg, argument))
                    continue;
                if (candidates.includes(candidate)) {
                    // return true, and remove conflicted ones for the compared argument as well
                    candidatesByPos[pos] = candidates.filter((c) => c === candidate);
                    return true;
                }
            }
        }
        return false;
    }
    _hasConflictTypes(arg1, arg2) {
        // FIXME: consider subtypes
        // if types conflict
        if (this.schema.getArgType(arg1).equals(this.schema.getArgType(arg2)))
            return true;
        // if string set conflict
        const stringSet1 = this.schema.getArgument(arg1).getImplementationAnnotation('string_values');
        const stringSet2 = this.schema.getArgument(arg2).getImplementationAnnotation('string_values');
        if (stringSet1 && stringSet2 && stringSet1 === stringSet2)
            return true;
        // otherwise 
        return false;
    }
}
class Counter {
    constructor() {
        this.counter = {};
    }
    add(item) {
        if (!(item in this.counter))
            this.counter[item] = 0;
        this.counter[item] += 1;
    }
    get(item) {
        return this.counter[item];
    }
    getTop(percent, minimumCount = 0) {
        const total = Object.keys(this.counter).length;
        const size = Math.ceil(total * percent / 100);
        const entries = Object.entries(this.counter).sort(([, c1], [, c2]) => c2 - c1).slice(0, size);
        console.log(entries);
        return entries.filter(([, c]) => c > minimumCount).map(([i,]) => i);
    }
}
class AnnotationExtractor {
    constructor(klass, queries, options, cache) {
        this.class = klass;
        this.queries = queries;
        this.options = options;
        this.parser = new pos_parser_1.default();
        this.cache = cache;
        this.queryCanonicalCandidates = {};
        this.propertyCanonicalCandidates = {};
        for (const qname of this.queries) {
            this.queryCanonicalCandidates[qname] = new Counter();
            this.propertyCanonicalCandidates[qname] = {};
            for (const arg of this.class.getFunction('query', qname).iterateArguments())
                this.propertyCanonicalCandidates[qname][arg.name] = {};
        }
    }
    async run(examples) {
        // extract canonicals from paraphrases;
        examples.forEach((ex) => this._extractCanonical(ex));
        // validate extracted canonicals and add to schema
        for (const qname of this.queries) {
            const query = this.class.getFunction('query', qname);
            // Add query canonical:
            if (this.options.annotate_query_canonical) {
                const queryCanonical = query.getNaturalLanguageAnnotation('canonical');
                if (queryCanonical)
                    queryCanonical.push(...this.queryCanonicalCandidates[qname].getTop(80, 2));
            }
            // Add property canonical:
            if (this.options.annotate_property_canonical) {
                // 1. filter candidates for each argument
                for (const candidates of Object.values(this.propertyCanonicalCandidates[qname]))
                    this._filterPropertyCanonicalCandidates(candidates);
                // 2. remove conflict candidates among arguments
                this._removeConflictedCandidates(qname);
                // 3. add filtered candidates to the canonical annotation
                for (const arg of query.iterateArguments())
                    await this._addPropertyCanonicalCandidates(qname, arg);
            }
        }
    }
    _extractCanonical(example) {
        // FIXME: In case of boolean parameter or projection, values field is empty, skip for now
        if (typeof example.value !== 'string')
            return;
        const canonical = this.propertyCanonicalCandidates[example.query][example.argument];
        for (const paraphrase of example.paraphrases) {
            this._extractQueryCanonical(example.query, example.queryCanonical, example.utterance, paraphrase);
            this._extractPropertyCanonical(canonical, paraphrase, example.value, example.queryCanonical);
        }
    }
    _extractQueryCanonical(query, queryCanonical, original, paraphrase) {
        original = original.toLowerCase().replace(/[ .?!]*$/g, '');
        paraphrase = paraphrase.toLowerCase().replace(/[ .?!]*$/g, '');
        if (original === paraphrase)
            return;
        if (!original.includes(queryCanonical))
            return;
        const [lhs, rhs] = original.split(queryCanonical);
        if (paraphrase.startsWith(lhs) && paraphrase.endsWith(rhs)) {
            const candidate = paraphrase.slice(lhs.length, -rhs.length);
            const tokens = candidate.split(' ');
            if (['you', 'me', 'my', 'your', 'one', 'that', 'those', 'this', 'these'].some((token) => tokens.includes(token)))
                return;
            if (candidate.length > 0)
                this.queryCanonicalCandidates[query].add(candidate);
        }
    }
    _extractPropertyCanonical(canonical, paraphrase, value, queryCanonical) {
        var _a;
        const annotations = this.parser.match('query', paraphrase, [queryCanonical], value);
        if (annotations) {
            for (const annotation of annotations) {
                canonical[annotation.pos] = (_a = canonical[annotation.pos]) !== null && _a !== void 0 ? _a : [];
                canonical[annotation.pos].push(annotation.canonical.replace('$value', '#'));
            }
        }
    }
    _filterPropertyCanonicalCandidates(candidatesByPos) {
        const wordCounter = this._countWords(candidatesByPos);
        for (const [pos, candidates] of Object.entries(candidatesByPos)) {
            const dedupedCandidates = new Set(candidates);
            const filteredCandidates = [];
            for (const candidate of dedupedCandidates) {
                // skip candidate with value directly connected with a word
                if (base_canonical_generator_1.PROJECTION_PARTS_OF_SPEECH.includes(pos) && !/(#\w)|(\w#)/.test(candidate))
                    continue;
                // skip value only candidate for non-adjectives
                if (candidate === '#' && !pos.startsWith('adjective'))
                    continue;
                // skip candidate with rare word in it 
                let includesRareWord = false;
                for (const word of candidate.split(' ')) {
                    if (wordCounter[word] < 2) {
                        includesRareWord = true;
                        break;
                    }
                }
                if (this.options.filtering && includesRareWord)
                    continue;
                filteredCandidates.push(candidate);
            }
            candidatesByPos[pos] = filteredCandidates;
        }
    }
    _countWords(candidates) {
        var _a;
        const counter = {};
        for (const pos in candidates) {
            for (const candidate of candidates[pos]) {
                for (const word of candidate.split(' '))
                    counter[word] = ((_a = counter[word]) !== null && _a !== void 0 ? _a : 0) + 1;
            }
        }
        return counter;
    }
    _removeConflictedCandidates(query) {
        const conflictResolver = new ConflictResolver(this.class.getFunction('query', query), this.propertyCanonicalCandidates[query]);
        conflictResolver.resolve();
    }
    async _addPropertyCanonicalCandidates(qname, argument) {
        console.log(qname, argument.name);
        const canonicalAnnotation = argument.getNaturalLanguageAnnotation('canonical');
        const key = this.options.cache_type === 'by-device' ? `${this.class.name}.${argument.name}` : `${qname}.${argument.name}`;
        const cache = await this.cache.get(key);
        if (cache) {
            console.log(cache);
            Object.assign(canonicalAnnotation, JSON.parse(cache));
        }
        else {
            let candidates;
            if (this.options.cache_type === 'by-device') {
                for (const q in this.propertyCanonicalCandidates) {
                    if (argument.name in this.propertyCanonicalCandidates[q])
                        candidates = this.propertyCanonicalCandidates[q][argument.name];
                }
            }
            else {
                candidates = this.propertyCanonicalCandidates[qname][argument.name];
            }
            if (candidates) {
                for (const [pos, canonicals] of Object.entries(candidates)) {
                    if (canonicals.length === 0)
                        continue;
                    if (!(pos in canonicalAnnotation)) {
                        canonicalAnnotation[pos] = canonicals;
                    }
                    else {
                        for (const canonical of canonicals) {
                            if (canonicalAnnotation[pos].includes(canonical))
                                continue;
                            if (canonical.endsWith(' #') && canonicalAnnotation[pos].includes(canonical.slice(0, -2)))
                                continue;
                            canonicalAnnotation[pos].push(canonical);
                        }
                    }
                }
            }
            await this.cache.set(key, JSON.stringify(canonicalAnnotation));
        }
    }
}
exports.default = AnnotationExtractor;
//# sourceMappingURL=canonical-extractor.js.map