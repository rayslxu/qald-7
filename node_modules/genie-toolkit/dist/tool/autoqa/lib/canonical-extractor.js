"use strict";
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
//
/// <reference types="./stemmer" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stemmer_1 = __importDefault(require("stemmer"));
const pos_parser_1 = __importDefault(require("../../../lib/pos-parser"));
const base_canonical_generator_1 = require("./base-canonical-generator");
function stem(str) {
    if (str.endsWith(' #'))
        str = str.slice(0, -2);
    return str.split(' ').map(stemmer_1.default).join(' ');
}
class ConflictResolver {
    constructor(schema, candidates) {
        this.schema = schema;
        this.candidates = candidates;
        this.stemmedBaseCanonicals = {};
        for (const arg of schema.iterateArguments())
            this.stemmedBaseCanonicals[arg.name] = stem(arg.canonical);
    }
    resolve() {
        for (const [arg, candidatesByPos] of Object.entries(this.candidates)) {
            for (const [pos, candidates] of Object.entries(candidatesByPos)) {
                const filteredCandidates = [];
                for (const candidate of candidates) {
                    if (!this._hasConflict(arg, pos, candidate))
                        filteredCandidates.push(candidate);
                }
                this.candidates[arg][pos] = filteredCandidates;
            }
        }
    }
    _hasConflict(argument, pos, candidate) {
        // remove candidates that conflict with the default canonical of other arguments
        for (const [arg, stemmedBaseCanonical] of Object.entries(this.stemmedBaseCanonicals)) {
            if (arg !== argument && stemmedBaseCanonical === stem(candidate))
                return true;
        }
        // remove candidates that conflict with each other
        for (const [arg, candidatesByPos] of Object.entries(this.candidates)) {
            if (arg === argument)
                continue;
            for (const [pos, candidates] of Object.entries(candidatesByPos)) {
                // for non-projection canonical, we only care about the arguments having conflict types
                if (!base_canonical_generator_1.PROJECTION_PARTS_OF_SPEECH.includes(pos) && !this._hasConflictTypes(arg, argument))
                    continue;
                if (candidates.includes(candidate)) {
                    // return true, and remove conflicted ones for the compared argument as well
                    candidatesByPos[pos] = candidates.filter((c) => c === candidate);
                    return true;
                }
            }
        }
        return false;
    }
    _hasConflictTypes(arg1, arg2) {
        // FIXME: consider subtypes
        // if types conflict
        if (this.schema.getArgType(arg1).equals(this.schema.getArgType(arg2)))
            return true;
        // if string set conflict
        const stringSet1 = this.schema.getArgument(arg1).getImplementationAnnotation('string_values');
        const stringSet2 = this.schema.getArgument(arg2).getImplementationAnnotation('string_values');
        if (stringSet1 && stringSet2 && stringSet1 === stringSet2)
            return true;
        // otherwise 
        return false;
    }
}
class AnnotationExtractor {
    constructor(klass, queries, options) {
        this.class = klass;
        this.queries = queries;
        this.options = options;
        this.parser = new pos_parser_1.default();
        this.candidates = {};
        for (const qname of this.queries) {
            this.candidates[qname] = {};
            for (const arg of this.class.getFunction('query', qname).iterateArguments())
                this.candidates[qname][arg.name] = {};
        }
    }
    async run(examples) {
        // extract canonicals from paraphrases;
        examples.forEach((ex) => this._extractCanonical(ex));
        // validate extracted canonicals and add to schema
        for (const qname of this.queries) {
            const query = this.class.getFunction('query', qname);
            // filter candidates for each argument
            for (const candidates of Object.values(this.candidates[qname]))
                this._filterCandidates(candidates);
            // remove conflict candidates among arguments
            this._removeConflictedCandidates(qname);
            // add filtered candidates to the canonical annotation
            for (const [arg, candidates] of Object.entries(this.candidates[qname]))
                this._addCandidates(query.getArgument(arg), candidates);
        }
    }
    _extractCanonical(example) {
        // FIXME: In case of boolean parameter or projection, values field is empty, skip for now
        if (typeof example.value !== 'string')
            return;
        const canonical = this.candidates[example.query][example.argument];
        for (const paraphrase of example.paraphrases)
            this._extractOneCanonical(canonical, paraphrase, example.value, example.queryCanonical);
    }
    _extractOneCanonical(canonical, paraphrase, value, queryCanonical) {
        var _a;
        const annotations = this.parser.match('query', paraphrase, [queryCanonical], value);
        if (annotations) {
            for (const annotation of annotations) {
                canonical[annotation.pos] = (_a = canonical[annotation.pos]) !== null && _a !== void 0 ? _a : [];
                canonical[annotation.pos].push(annotation.canonical.replace('$value', '#'));
            }
        }
    }
    _filterCandidates(candidatesByPos) {
        const wordCounter = this._countWords(candidatesByPos);
        for (const [pos, candidates] of Object.entries(candidatesByPos)) {
            const dedupedCandidates = new Set(candidates);
            const filteredCandidates = [];
            for (const candidate of dedupedCandidates) {
                // skip candidate with value directly connected with a word
                if (base_canonical_generator_1.PROJECTION_PARTS_OF_SPEECH.includes(pos) && !/(#\w)|(\w#)/.test(candidate))
                    continue;
                // skip value only candidate for non-adjectives
                if (candidate === '#' && !pos.startsWith('adjective'))
                    continue;
                // skip candidate with rare word in it 
                let includesRareWord = false;
                for (const word of candidate.split(' ')) {
                    if (wordCounter[word] < 2) {
                        includesRareWord = true;
                        break;
                    }
                }
                if (this.options.filtering && includesRareWord)
                    continue;
                filteredCandidates.push(candidate);
            }
            candidatesByPos[pos] = filteredCandidates;
        }
    }
    _countWords(candidates) {
        var _a;
        const counter = {};
        for (const pos in candidates) {
            for (const candidate of candidates[pos]) {
                for (const word of candidate.split(' '))
                    counter[word] = ((_a = counter[word]) !== null && _a !== void 0 ? _a : 0) + 1;
            }
        }
        return counter;
    }
    _removeConflictedCandidates(query) {
        const conflictResolver = new ConflictResolver(this.class.getFunction('query', query), this.candidates[query]);
        conflictResolver.resolve();
    }
    _addCandidates(argument, candidates) {
        const canonicalAnnotation = argument.getNaturalLanguageAnnotation('canonical');
        for (const [pos, canonicals] of Object.entries(candidates)) {
            if (canonicals.length === 0)
                continue;
            if (!(pos in canonicalAnnotation)) {
                canonicalAnnotation[pos] = canonicals;
            }
            else {
                for (const canonical of canonicals) {
                    if (canonicalAnnotation[pos].includes(canonical))
                        continue;
                    if (canonical.endsWith(' #') && canonicalAnnotation[pos].includes(canonical.slice(0, -2)))
                        continue;
                    canonicalAnnotation[pos].push(canonical);
                }
            }
        }
    }
}
exports.default = AnnotationExtractor;
//# sourceMappingURL=canonical-extractor.js.map