"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const thingtalk_1 = require("thingtalk");
const utils = __importStar(require("../../../lib/utils/misc-utils"));
const sample_utils_1 = require("../../../lib/dataset-tools/mturk/sample-utils");
const english_1 = __importDefault(require("../../../lib/i18n/english"));
const misc_utils_1 = require("../../../lib/utils/misc-utils");
const canonical_extractor_1 = __importDefault(require("./canonical-extractor"));
const base_canonical_generator_1 = __importDefault(require("./base-canonical-generator"));
const base_canonical_generator_2 = require("./base-canonical-generator");
const canonical_example_constructor_1 = require("./canonical-example-constructor");
const canonical_example_paraphraser_1 = __importDefault(require("./canonical-example-paraphraser"));
function getElemType(type) {
    if (type instanceof thingtalk_1.Type.Array)
        return getElemType(type.elem);
    return type;
}
function typeToString(type) {
    const elemType = getElemType(type);
    if (elemType instanceof thingtalk_1.Type.Entity)
        return elemType.type;
    return type.toString();
}
function countArgTypes(schema) {
    const count = {};
    for (const arg of schema.iterateArguments()) {
        const typestr = typeToString(arg.type);
        if (!typestr)
            continue;
        count[typestr] = (count[typestr] || 0) + 1;
    }
    return count;
}
class AutoCanonicalGenerator {
    constructor(classDef, entities, constants, functions, options) {
        this.class = classDef;
        this.entities = entities;
        this.constants = constants;
        this.functions = functions ? functions : Object.keys(classDef.queries).concat(Object.keys(classDef.actions));
        this.paraphraserModel = options.paraphraser_model;
        this.annotatedProperties = [];
        this.langPack = new english_1.default('en-US');
        this.options = options;
        this.entityNames = {};
        this.childEntities = {};
        for (const entity of this.entities) {
            this.entityNames[entity.type] = entity.name;
            if (entity.subtype_of) {
                for (const parent of entity.subtype_of) {
                    if (parent in this.childEntities)
                        this.childEntities[parent].push(entity.name);
                    else
                        this.childEntities[parent] = [entity.name];
                }
            }
        }
    }
    async generate() {
        await this._loadManualCanonicalOverride();
        const examples = [];
        for (const fname of this.functions) {
            const func = this.class.queries[fname] || this.class.actions[fname];
            const typeCounts = countArgTypes(func);
            for (const arg of func.iterateArguments()) {
                // skip argument with existed annotations
                if (this.annotatedProperties.includes(arg.name) || arg.name === 'id')
                    continue;
                if (arg.name.includes('.') && this.annotatedProperties.includes(arg.name.slice(arg.name.indexOf('.') + 1)))
                    continue;
                // set starting canonical annotation
                const sampleValues = this._retrieveSamples(fname, arg);
                const canonicalAnnotation = this._generateBaseCanonicalAnnotation(func, arg, typeCounts);
                examples.push(...(0, canonical_example_constructor_1.generateExamples)(func, arg, canonicalAnnotation, sampleValues));
            }
        }
        const paraphraser = new canonical_example_paraphraser_1.default(this.paraphraserModel, this.options);
        const startTime = (new Date()).getTime();
        await paraphraser.paraphrase(examples);
        if (this.options.debug) {
            const time = Math.round(((new Date()).getTime() - startTime) / 1000);
            console.log(`Paraphraser took ${time} seconds to run.`);
        }
        const extractor = new canonical_extractor_1.default(this.class, this.functions, this.options);
        await extractor.run(examples);
        this._addProjectionCanonicals();
        this._trimAnnotations();
        return this.class;
    }
    async _loadManualCanonicalOverride() {
        const file = path_1.default.resolve(path_1.default.dirname(module.filename), `../${this.options.dataset}/manual-annotations.js`);
        if (!fs.existsSync(file))
            return;
        const manualAnnotations = await Promise.resolve().then(() => __importStar(require(`../${this.options.dataset}/manual-annotations.js`)));
        if (manualAnnotations.PROPERTY_CANONICAL_OVERRIDE)
            this.annotatedProperties = Object.keys(manualAnnotations.PROPERTY_CANONICAL_OVERRIDE);
    }
    _generateBaseCanonicalAnnotation(func, arg, typeCounts) {
        const canonicalAnnotation = {};
        if (this.options.remove_existing_canonicals) {
            (0, base_canonical_generator_1.default)(canonicalAnnotation, arg.name, arg.type);
        }
        else {
            const existingCanonical = arg.getNaturalLanguageAnnotation('canonical') || {};
            if (typeof existingCanonical === 'string')
                canonicalAnnotation.base = [existingCanonical];
            else if (Array.isArray(existingCanonical))
                canonicalAnnotation.base = existingCanonical;
            else if (typeof existingCanonical === 'object')
                Object.assign(canonicalAnnotation, existingCanonical);
        }
        // remove function name in arg name, normally it's repetitive
        for (const [key, value] of Object.entries(canonicalAnnotation)) {
            if (base_canonical_generator_2.PARTS_OF_SPEECH.includes(key)) {
                canonicalAnnotation[key] = value.map((c) => {
                    if (c.startsWith(func.name.toLowerCase() + ' '))
                        return c.slice(func.name.toLowerCase().length + 1);
                    return c;
                });
            }
        }
        // copy base canonical if property canonical is missing
        if (canonicalAnnotation.base && !canonicalAnnotation.property)
            canonicalAnnotation.property = [...canonicalAnnotation.base];
        const typestr = typeToString(func.getArgType(arg.name));
        if (typestr && typeCounts[typestr] === 1) {
            // if an entity is unique, allow dropping the property name entirely
            // FIXME: consider type hierarchy, or probably drop it entirely
            if (canonicalAnnotation.property && !this.functions.includes(typestr.substring(typestr.indexOf(':') + 1))) {
                if (!canonicalAnnotation.property.includes('#'))
                    canonicalAnnotation.property.push('#');
            }
            // if property is missing, use the type information
            if (!('property' in canonicalAnnotation)) {
                const base = utils.clean(typestr.substring(typestr.indexOf(':') + 1));
                canonicalAnnotation['property'] = [base];
                canonicalAnnotation['base'] = [base];
            }
            // if it's the only people entity, adding adjective form
            // E.g., author for review - bob's review
            //       byArtist for MusicRecording - bob's song
            if (typestr.endsWith(':Person'))
                canonicalAnnotation.adjective = ["# 's", '#'];
            // if it's the only date, adding argmin/argmax/base_projection
            if (typestr === 'Date') {
                canonicalAnnotation.adjective_argmax = ["most recent", "latest", "last", "newest"];
                canonicalAnnotation.adjective_argmin = ["earliest", "first", "oldest"];
                canonicalAnnotation.base_projection = ['date'];
            }
        }
        return canonicalAnnotation;
    }
    _addProjectionCanonicals() {
        for (const fname of this.functions) {
            const func = this.class.queries[fname] || this.class.actions[fname];
            for (const arg of func.iterateArguments()) {
                if (this.annotatedProperties.includes(arg.name) || arg.name === 'id')
                    continue;
                if (arg.type.isBoolean)
                    continue;
                const canonicals = arg.metadata.canonical;
                if (!canonicals)
                    continue;
                if (typeof canonicals === 'string' || Array.isArray(canonicals))
                    continue;
                const elemType = arg.type instanceof thingtalk_1.Type.Array ? arg.type.elem : arg.type;
                (0, assert_1.default)(elemType instanceof thingtalk_1.Type);
                if (elemType instanceof thingtalk_1.Type.Entity && this.options.type_based_projection && !('base_projection' in canonicals)) {
                    const entityType = elemType.type;
                    if (this.entityNames[entityType])
                        canonicals['base_projection'] = [this.entityNames[entityType]];
                    if (this.childEntities[entityType])
                        canonicals['base_projection'].push(...this.childEntities[entityType]);
                }
                for (const cat in canonicals) {
                    if (['default', 'adjective', 'implicit_identity', 'projection_pronoun'].includes(cat))
                        continue;
                    if (cat.endsWith('_projection'))
                        continue;
                    if (cat.endsWith('_argmin') || cat.endsWith('_argmax'))
                        continue;
                    if (`${cat}_projection` in canonicals)
                        continue;
                    if (cat === 'passive_verb' || cat === 'verb') {
                        canonicals[cat + '_projection'] = canonicals[cat].map((canonical) => {
                            return this._processProjectionCanonical(canonical, cat);
                        }).filter(Boolean).map((c) => {
                            const tokens = c.split(' ');
                            if (tokens.length === 1)
                                return c;
                            if (['IN', 'TO', 'PR'].includes(this.langPack.posTag(tokens)[tokens.length - 1]))
                                return [...tokens.slice(0, -1), '//', tokens[tokens.length - 1]].join(' ');
                            return c;
                        }).filter((v, i, self) => self.indexOf(v) === i);
                    }
                    else {
                        canonicals[cat + '_projection'] = canonicals[cat].map((canonical) => {
                            return this._processProjectionCanonical(canonical, cat);
                        }).filter(Boolean).filter((v, i, self) => self.indexOf(v) === i);
                    }
                }
            }
        }
    }
    _processProjectionCanonical(canonical, cat) {
        if (canonical.includes('#') && !canonical.endsWith(' #'))
            return null;
        canonical = canonical.replace(' #', '');
        if (canonical.endsWith(' a') || canonical.endsWith(' an') || canonical.endsWith(' the'))
            canonical = canonical.substring(0, canonical.lastIndexOf(' '));
        if (canonical.split(' ').length > 1 && cat === 'preposition')
            return null;
        return canonical;
    }
    _retrieveSamples(qname, arg) {
        //TODO: also use enum canonicals?
        if (arg.type instanceof thingtalk_1.Type.Enum)
            return arg.type.entries.slice(0, 10).map(misc_utils_1.clean);
        const keys = (0, sample_utils_1.makeLookupKeys)('@' + this.class.kind + '.' + qname, arg.name, arg.type);
        let sampleConstants = [];
        for (const key of keys) {
            if (this.constants[key]) {
                sampleConstants = this.constants[key];
                break;
            }
        }
        return sampleConstants.map((v) => {
            if (arg.type.isString || (arg.type instanceof thingtalk_1.Type.Array && arg.type.elem.isString))
                return v.value;
            return v.display;
        });
    }
    _trimAnnotations() {
        if (!this.options.max_per_pos)
            return;
        for (const fname of this.functions) {
            const func = this.class.queries[fname] || this.class.actions[fname];
            for (const arg of func.iterateArguments()) {
                if (this.annotatedProperties.includes(arg.name) || arg.name === 'id')
                    continue;
                const canonicalAnnotation = arg.metadata.canonical;
                for (const pos in canonicalAnnotation) {
                    if (pos === 'default')
                        continue;
                    canonicalAnnotation[pos] = canonicalAnnotation[pos].slice(0, this.options.max_per_pos);
                }
            }
        }
    }
}
exports.default = AutoCanonicalGenerator;
//# sourceMappingURL=canonical-generator.js.map