import { EntityMap } from '../../utils/entity-utils';
interface DateEntity {
    year: number;
    month: number;
    day: number;
    hour: number;
    minute: number;
    second: number;
    timezone: string | undefined;
}
interface TimeEntity {
    hour: number;
    minute: number;
    second: number;
}
interface MeasureEntity {
    unit: string;
    value: number;
}
export declare type AnyEntity = MeasureEntity | TimeEntity | DateEntity | string | number;
export interface TokenizerResult {
    tokens: string[];
    rawTokens: string[];
    entities: EntityMap;
}
interface Token {
    index: number;
    raw: string;
    normalized: string;
    type: string | null;
    value: AnyEntity | null;
}
interface LexerLike<TokenType> {
    index: number;
    text: string;
    state: string;
    addRule(expr: RegExp, cb?: (self: LexerLike<TokenType>) => TokenType): void;
}
export default class BaseTokenizer {
    private _realLexer;
    protected _lexer: LexerLike<Token>;
    constructor();
    protected _addDefinition(name: string, expansion: RegExp): void;
    protected _initBase(): void;
    protected _initCatchAll(): void;
    protected _initQuotedStrings(): void;
    protected _initAbbrv(): void;
    protected _initSpecialNumbers(): void;
    protected _initZipCodes(): void;
    protected _parseDecimalNumber(text: string): number;
    protected _initNumbers(): void;
    protected _initOrdinals(): void;
    protected _initFilenames(): void;
    protected _initURLs(): void;
    protected _initUsernameHashtags(): void;
    protected _addIntlPrefix(text: string): string;
    protected _initPhoneNumber(): void;
    protected _initEmailAddress(): void;
    protected _normalizeTime(hour: number, minute: number, second: number, strictISO?: boolean): string;
    protected _parse12HrTime(text: string, ampm: 'am' | 'pm' | '24h' | ''): {
        hour: number;
        minute: number;
        second: number;
    };
    protected _parseOClockTime(text: string, ampm: 'am' | 'pm' | '24h' | ''): {
        hour: number;
        minute: number;
        second: number;
    };
    protected _parseMilitaryTime(text: string): {
        hour: number;
        minute: number;
        second: number;
    };
    protected _initTimes(): void;
    protected _normalizeDate(date: DateEntity): string;
    protected _parseNumericDate(text: string, style: 'mdy' | 'dmy' | 'ymd', parseTime?: ((time: string) => TimeEntity) | null): DateEntity;
    protected _initDates(): void;
    tokenize(text: string): TokenizerResult;
}
export {};
