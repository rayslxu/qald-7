/// <reference types="node" />
import * as events from 'events';
import ValueCategory from './value-category';
import { PlatformData, Message, RDL } from './protocol';
import { EntityMap } from '../utils/entity-utils';
import type Engine from '../engine';
import { DialogueSerializer, DialogueTurn } from "../dataset-tools/parsers";
import AppExecutor from '../engine/apps/app_executor';
export interface ConversationOptions {
    nluServerUrl?: string;
    nlgServerUrl?: string;
    anonymous?: boolean;
    debug?: boolean;
    rng?: () => number;
    contextResetTimeout?: number;
    showWelcome?: boolean;
    log?: boolean;
    dialogueFlags?: Record<string, boolean>;
    useConfidence?: boolean;
    faqModels?: Record<string, {
        url: string;
        highConfidence?: number;
        lowConfidence?: number;
    }>;
}
interface Statistics {
    hit(key: string): void;
}
export interface ConversationDelegate {
    setHypothesis(hyp: string): Promise<void>;
    setExpected(expect: string | null, ctx: {
        code: string[];
        entities: EntityMap;
    }): Promise<void>;
    addMessage(msg: Message): Promise<void>;
    destroy(): void;
}
export interface ConversationState {
    dialogueState: Record<string, unknown>;
    lastMessageId: number;
    recording: boolean;
}
/**
 * A single session of conversation in Genie.
 *
 * This object is responsible for maintaining the history of the conversation
 * to support clients reconnecting to the same conversation later, as well
 * as tracking connected clients and inactivity timeouts.
 */
export default class Conversation extends events.EventEmitter {
    private _engine;
    private _conversationId;
    private _locale;
    _: (x: string) => string;
    private _stats;
    private _options;
    private _debug;
    private _dialogueFlags;
    rng: () => number;
    private _loop;
    private _expecting;
    private _context;
    private _started;
    private _delegates;
    private _history;
    private _lastMessageId;
    private _contextResetTimeout;
    private _contextResetTimeoutSec;
    private _recording;
    private _log;
    private readonly _conversationStateDB;
    constructor(engine: Engine, conversationId: string, options?: ConversationOptions);
    get isAnonymous(): boolean;
    get id(): string;
    get engine(): Engine;
    get stats(): Statistics;
    get inRecordingMode(): boolean;
    get dialogueFlags(): Record<string, boolean>;
    startRecording(): Promise<void>;
    endRecording(): Promise<void>;
    notify(app: AppExecutor, outputType: string, outputValue: Record<string, unknown>): void;
    notifyError(app: AppExecutor, error: Error): void;
    setExpected(expecting: ValueCategory | null, context: {
        code: string[];
        entities: EntityMap;
    }): void;
    start(state?: ConversationState): Promise<void>;
    stop(): Promise<void>;
    private _resetInactivityTimeout;
    addOutput(out: ConversationDelegate, replayHistory?: boolean): Promise<void>;
    removeOutput(out: ConversationDelegate): void;
    private _callDelegate;
    private _callDelegates;
    setHypothesis(hypothesis: string): Promise<void>;
    sendAskSpecial(): Promise<void>;
    /**
     * Add a message to the conversation history.
     *
     * This method is exported to inject conversation history from outside.
     */
    addMessage(msg: Message): Promise<void>;
    private _saveState;
    /**
     * Extract the state from the conversation.
     *
     * This method is provided to save and restore the conversation state,
     * and transfer the conversation state between engines.
     */
    getState(): ConversationState;
    handleCommand(command: string, platformData?: PlatformData): Promise<void>;
    handleParsedCommand(root: any, title?: string, platformData?: PlatformData): Promise<void>;
    handleThingTalk(program: string, platformData?: PlatformData): Promise<void>;
    sendReply(message: string, icon: string | null): Promise<void>;
    sendMedia(mediaType: 'picture' | 'audio' | 'video', url: string, alt: string | undefined, icon: string | null): Promise<void>;
    sendRDL(rdl: RDL, icon: string | null): Promise<void>;
    sendSoundEffect(name: string, exclusive: boolean | undefined, icon: string | null): Promise<void>;
    sendChoice(idx: number, title: string): Promise<void>;
    sendButton(title: string, json: string): Promise<void>;
    sendLink(title: string, url: string, state: ConversationState): Promise<void>;
    sendNewProgram(program: {
        uniqueId: string;
        name: string;
        code: string;
        results: Array<Record<string, unknown>>;
        errors: string[];
        icon: string | null;
    }): Promise<void>;
    dialogueFinished(): Promise<void>;
    turnFinished(): Promise<void>;
    voteLast(vote: 'up' | 'down'): Promise<void>;
    commentLast(comment: string): Promise<void>;
    updateLog(field: Exclude<keyof DialogueTurn, 'agent_timestamp' | 'user_timestamp'>, value: string): void;
    readLog(): DialogueSerializer;
}
export {};
