import * as Tp from 'thingpedia';
import type CardFormatter from './card-formatter';
declare type PlainObject = {
    [key: string]: unknown;
};
export declare function isNull(value: unknown): boolean;
/**
 * Namespace for format objects.
 *
 * Classes in this namespace are not accessible directly, but objects
 * of this classes are returned by {@link Formatter} methods.
 *
 * @namespace
 */
/**
 * The base class of all formatting objects.
 *
 * Formatting objects are created from spec objects provided in the `#_[formatted]`
 * function annotation.
 */
export declare abstract class BaseFormattedObject {
    /**
     * A string identifying the type of this formatted object.
     */
    abstract type: string;
    /**
     * Check if this formatted object is valid.
     *
     * A formatted object is valid if the required properties are substituted with
     * valid values (not null, undefined, empty or NaN). Invalid formatted objects
     * are not displayed to the user.
     *
     * @return {boolean} true if this formatted object is valid, false otherwise
     */
    abstract isValid(): boolean;
    /**
     * Convert this formatted object to a localized string.
     *
     * The resulting string is suitable for speech, or for displaying to user in
     * a text-only interface. It is also suitable as a fallback for all formatting
     * objects not recognized by the application.
     *
     * @param {string} locale - the locale to localize any message into
     * @return {string} a string representation of this formatted object
     */
    abstract toLocaleString(locale: string): string;
    /**
     * Replace all placeholders in this object, using the provided structured result.
     *
     * @param {Formatter} formatter - the formatter to use for replacement
     * @param {Object.<string,any>} argMap - the structured ThingTalk result with the values to substitute
     */
    replaceParameters(formatter: CardFormatter, argMap: PlainObject): void;
}
/**
 * A rich deep link (also known as a card).
 *
 * An RDL is expected to be displayed as a clickable card with optional
 * description and picture.
 *
 */
declare class RDL extends BaseFormattedObject implements Tp.FormatObjects.RDL {
    type: 'rdl';
    callback: string | undefined;
    webCallback: string;
    displayTitle: string;
    displayText: string | undefined;
    pictureUrl: string | undefined;
    /**
     * Construct a new RDL
     *
     * If displayTitle is unspecified but displayText is, displayText is moved to displayTitle.
     * If callback is not specified, it is set to the same value as webCallback.
     *
     * @param {Object} spec
     * @param {string} spec.displayTitle - the title of the link
     * @param {string} [spec.displayText] - the description associated with the link
     * @param {string} spec.webCallback - the link target
     * @param {string} [spec.callback] - a different link target, to use on plaforms where deep-linking is allowed (e.g. Android)
     * @param {string} [spec.pictureUrl] - a picture associated with this link
     */
    constructor(spec: Tp.FormatObjects.RDL);
    replaceParameters(formatter: CardFormatter, argMap: PlainObject): void;
    isValid(): boolean;
    toLocaleString(locale: string): string;
}
/**
 * A short notification sound from a predefined library.
 *
*/
declare class SoundEffect extends BaseFormattedObject implements Tp.FormatObjects.SoundEffect {
    type: 'sound';
    name: string;
    exclusive: boolean;
    before: boolean;
    /**
     * Construct a new sound effect object.
     *
     * @param {Object} spec
     * @param {string} spec.name - the name of the sound, from the {@link http://0pointer.de/public/sound-theme-spec.html|Freedesktop Sound Theme Spec}
     *                             (with a couple Genie-specific extensions)
     */
    constructor(spec: Tp.FormatObjects.SoundEffect & {
        before?: boolean;
    });
    isValid(): boolean;
    toLocaleString(locale: string): string;
}
/**
 * Picture, or audio/video display with controls
 *
*/
declare class Media extends BaseFormattedObject implements Tp.FormatObjects.Media {
    type: 'picture' | 'audio' | 'video';
    url: string;
    alt: string | undefined;
    /**
     * Construct a new media object.
     *
     * @param {Object} spec
     * @param {string} spec.url - the URL of the music/video to display
     */
    constructor(spec: Tp.FormatObjects.Media);
    isValid(): boolean;
    toLocaleString(locale: string): string;
}
/**
 * A plain text message.
 */
declare class Text extends BaseFormattedObject implements Tp.FormatObjects.Text {
    type: 'text';
    text: string;
    /**
     * Construct a new text object.
     *
     * @param {Object} spec
     * @param {string} spec.text - the text to display
     */
    constructor(spec: Tp.FormatObjects.Text);
    isValid(): boolean;
    toLocaleString(locale: string): string;
}
/**
 * A button that triggers a pre-parsed command.
 */
export declare class Button extends BaseFormattedObject implements Tp.FormatObjects.Button {
    type: 'button';
    title: string;
    json: string;
    /**
     * Construct a new text object.
     *
     * @param {Object} spec
     * @param {string} spec.text - the text to display
     */
    constructor(spec: Tp.FormatObjects.Button);
    isValid(): boolean;
    toLocaleString(locale: string): string;
}
export interface FormattedObjectClass {
    new (obj: Tp.FormatObjects.FormattedObject): BaseFormattedObject & Tp.FormatObjects.FormattedObject;
}
export declare const FORMAT_TYPES: {
    rdl: typeof RDL;
    sound: typeof SoundEffect;
    picture: typeof Media;
    audio: typeof Media;
    video: typeof Media;
    text: typeof Text;
    button: typeof Button;
};
export {};
