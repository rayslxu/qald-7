/// <reference types="node" />
import * as Tp from 'thingpedia';
import * as events from 'events';
import Conversation, { ConversationOptions, ConversationState } from './conversation';
import { PlatformData, Message } from './protocol';
import { NotificationConfig, NotificationDelegate } from './notifications';
import AppExecutor from '../engine/apps/app_executor';
import type Engine from '../engine';
export interface CommandInput {
    type: 'command';
    text: string;
}
export interface ParsedInput {
    type: 'parsed';
    json: any;
    title?: string;
}
export interface ThingTalkInput {
    type: 'tt';
    code: string;
}
export declare type ConverseInput = (CommandInput | ParsedInput | ThingTalkInput) & PlatformData;
/**
 * The main controller class for interaction with the user.
 *
 * This class manages multiple conversations (independent sessions of the
 * agent with their own state), it dispatches notifications, and it
 * handles connections from API clients.
 */
export default class AssistantDispatcher extends events.EventEmitter {
    private _engine;
    private _notificationFormatter;
    private _nluModelUrl;
    private _notificationOutputs;
    private _staticNotificationBackends;
    private _dynamicNotificationBackends;
    private _conversations;
    private _conversationStateDB;
    constructor(engine: Engine, nluModelUrl: string | undefined, notificationConfig: NotificationConfig);
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Dispatch one single command to an existing conversation.
     *
     * This is an alternative to getting the conversation and adding a
     * ConversationDelegate to it.
     * It exists for the convenience of REST API clients which do not keep
     * an open web socket.
     */
    converse(command: ConverseInput, conversationId: string): Promise<{
        conversationId: string;
        messages: Message[];
        askSpecial: string | null;
    }>;
    /**
     * Add an API client that wishes to listen for notifications.
     *
     * The delegate methods will be invoked for every notification
     * and asynchronous error emitted by the engine.
     */
    addNotificationOutput(output: NotificationDelegate): void;
    /**
     * Remove a previously registered notification API client.
     */
    removeNotificationOutput(output: NotificationDelegate): void;
    /**
     * Get the list of notification backends that can be used.
     */
    getAvailableNotificationBackends(): Tp.Capabilities.NotificationBackend[];
    /**
     * Dispatch a notification (a single new result from a stream) from a
     * ThingTalk program.
     *
     * @param app - the running ThingTalk program that generated the notification
     * @param outputType - a string identifying the type of result to display
     * @param outputValue - the new value to display
     */
    notify(app: AppExecutor, outputType: string, outputValue: Record<string, unknown>): Promise<void>;
    notifyError(app: AppExecutor, error: Error): Promise<void>;
    private _getConversationRef;
    private getConversationState;
    getOrOpenConversation(id: string, options: ConversationOptions, state?: ConversationState): Promise<Conversation>;
    protected openConversation(id: string, options: ConversationOptions): Promise<Conversation>;
    closeConversation(id: string): void;
}
