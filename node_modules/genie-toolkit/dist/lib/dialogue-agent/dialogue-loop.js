"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pickHandler = exports.DialogueLoop = exports.CommandAnalysisType = void 0;
const assert_1 = __importDefault(require("assert"));
const consumer_queue_1 = __importDefault(require("consumer-queue"));
const template_string_1 = require("../utils/template-string");
const ParserClient = __importStar(require("../prediction/parserclient"));
const I18n = __importStar(require("../i18n"));
const value_category_1 = __importDefault(require("./value-category"));
const dialogue_queue_1 = __importDefault(require("./dialogue_queue"));
const errors_1 = require("./errors");
const device_interface_mapper_1 = __importDefault(require("../engine/devices/device_interface_mapper"));
const execution_dialogue_agent_1 = __importDefault(require("./execution_dialogue_agent"));
const thingtalk_1 = __importDefault(require("./handlers/thingtalk"));
const faq_1 = __importDefault(require("./handlers/faq"));
const _3rdparty_1 = __importDefault(require("./handlers/3rdparty"));
const device_view_1 = __importDefault(require("../engine/devices/device_view"));
var CommandAnalysisType;
(function (CommandAnalysisType) {
    // special commands - these are generated by the exact matcher, or
    // by UI buttons like the "X" button
    CommandAnalysisType[CommandAnalysisType["STOP"] = 0] = "STOP";
    CommandAnalysisType[CommandAnalysisType["NEVERMIND"] = 1] = "NEVERMIND";
    CommandAnalysisType[CommandAnalysisType["WAKEUP"] = 2] = "WAKEUP";
    CommandAnalysisType[CommandAnalysisType["DEBUG"] = 3] = "DEBUG";
    // some sort of command
    CommandAnalysisType[CommandAnalysisType["EXACT_IN_DOMAIN_COMMAND"] = 4] = "EXACT_IN_DOMAIN_COMMAND";
    CommandAnalysisType[CommandAnalysisType["STRONGLY_CONFIDENT_IN_DOMAIN_COMMAND"] = 5] = "STRONGLY_CONFIDENT_IN_DOMAIN_COMMAND";
    CommandAnalysisType[CommandAnalysisType["CONFIDENT_IN_DOMAIN_COMMAND"] = 6] = "CONFIDENT_IN_DOMAIN_COMMAND";
    CommandAnalysisType[CommandAnalysisType["NONCONFIDENT_IN_DOMAIN_COMMAND"] = 7] = "NONCONFIDENT_IN_DOMAIN_COMMAND";
    CommandAnalysisType[CommandAnalysisType["EXACT_IN_DOMAIN_FOLLOWUP"] = 8] = "EXACT_IN_DOMAIN_FOLLOWUP";
    CommandAnalysisType[CommandAnalysisType["STRONGLY_CONFIDENT_IN_DOMAIN_FOLLOWUP"] = 9] = "STRONGLY_CONFIDENT_IN_DOMAIN_FOLLOWUP";
    CommandAnalysisType[CommandAnalysisType["CONFIDENT_IN_DOMAIN_FOLLOWUP"] = 10] = "CONFIDENT_IN_DOMAIN_FOLLOWUP";
    CommandAnalysisType[CommandAnalysisType["NONCONFIDENT_IN_DOMAIN_FOLLOWUP"] = 11] = "NONCONFIDENT_IN_DOMAIN_FOLLOWUP";
    CommandAnalysisType[CommandAnalysisType["OUT_OF_DOMAIN_COMMAND"] = 12] = "OUT_OF_DOMAIN_COMMAND";
})(CommandAnalysisType = exports.CommandAnalysisType || (exports.CommandAnalysisType = {}));
class DialogueLoop {
    constructor(conversation, engine, options) {
        this.raw = false;
        this._stopped = false;
        this._userInputQueue = new consumer_queue_1.default();
        this._notifyQueue = new consumer_queue_1.default();
        this._debug = options.debug;
        this.conversation = conversation;
        this.engine = engine;
        this._langPack = I18n.get(engine.platform.locale);
        this._agent = new execution_dialogue_agent_1.default(engine, this, options.debug);
        this._nlu = ParserClient.get(options.nluServerUrl || undefined, engine.platform.locale, engine.platform, undefined, engine.thingpedia);
        this._nlg = ParserClient.get(options.nlgServerUrl || undefined, engine.platform.locale, engine.platform);
        this._thingtalkHandler = new thingtalk_1.default(engine, this, this._agent, this._nlu, this._nlg, options);
        this._faqHandlers = {};
        for (const faq in options.faqModels)
            this._faqHandlers[faq] = new faq_1.default(this, faq, options.faqModels[faq], { locale: engine.platform.locale });
        this._dynamicHandlers = new device_interface_mapper_1.default(new device_view_1.default(engine.devices, 'org.thingpedia.dialogue-handler', {}), (device) => new _3rdparty_1.default(device));
        this._currentHandler = null;
        this.icon = null;
        this.expecting = null;
        this.choices = [];
        this.platformData = {};
        this._mgrResolve = null;
        this._mgrPromise = null;
    }
    get _() {
        return this.conversation._;
    }
    get isAnonymous() {
        return this.conversation.isAnonymous;
    }
    get hasDebug() {
        return this._debug;
    }
    getState() {
        const state = {};
        for (const handler of this._iterateDialogueHandlers())
            state[handler.uniqueId] = handler.getState();
        return state;
    }
    debug(...args) {
        if (!this._debug)
            return;
        console.log(...args);
    }
    interpolate(msg, args) {
        const replacements = [];
        const names = [];
        for (const key in args) {
            names.push(key);
            const value = args[key];
            if (value !== null && value !== undefined) {
                replacements.push({
                    text: value instanceof template_string_1.ReplacedResult ? value : new template_string_1.ReplacedConcatenation([String(value)], {}, {}),
                    value,
                });
            }
            else {
                replacements.push(undefined);
            }
        }
        const tmpl = template_string_1.Replaceable.get(msg, this._langPack, names);
        return this._langPack.postprocessNLG(tmpl.replace({ replacements, constraints: {} }).chooseBest(), {}, this._agent);
    }
    _formatError(error) {
        if (typeof error === 'string')
            return error;
        else if (error.name === 'SyntaxError')
            return this.interpolate(this._("Syntax error {at ${error.fileName}|} {line ${error.lineNumber}|}: ${error.message}"), { error });
        else if (error.message)
            return error.message;
        else
            return String(error);
    }
    async nextCommand() {
        await this.conversation.sendAskSpecial();
        this._mgrPromise = null;
        this._mgrResolve();
        const intent = await this._userInputQueue.pop();
        this.platformData = intent.platformData;
        return intent;
    }
    *_iterateDialogueHandlers() {
        yield this._thingtalkHandler;
        for (const key in this._faqHandlers)
            yield this._faqHandlers[key];
        yield* this._dynamicHandlers.values();
    }
    async _analyzeCommand(command) {
        try {
            const handlers = [...this._iterateDialogueHandlers()];
            const handlerCandidates = await Promise.all(handlers.map(async (handler) => {
                const analysis = await handler.analyzeCommand(command);
                return { handler: handler, analysis: analysis };
            }));
            return pickHandler(this._currentHandler, this.expecting, handlerCandidates, command, this._debug);
        }
        catch (e) {
            if (e.code === 'EHOSTUNREACH' || e.code === 'ETIMEDOUT') {
                await this.reply(this._("Sorry, I cannot contact the Genie service. Please check your Internet connection and try again later."), null);
                throw new errors_1.CancellationError();
            }
            else if (typeof e.code === 'number' && (e.code === 404 || e.code >= 500)) {
                await this.reply(this._("Sorry, there seems to be a problem with the Genie service at the moment. Please try again later."), null);
                throw new errors_1.CancellationError();
            }
            else {
                throw e;
            }
        }
    }
    async _handleUICommand(type) {
        switch (type) {
            case CommandAnalysisType.STOP:
                // stop means cancel, but without a failure message + stopping audio
                if (this.engine.audio)
                    await this.engine.audio.stopAudio(this.conversation.id);
                throw new errors_1.CancellationError();
            case CommandAnalysisType.NEVERMIND:
                await this.reply(this._("Sorry I couldn't help on that."));
                throw new errors_1.CancellationError();
            case CommandAnalysisType.DEBUG:
                await this.reply("Current State:\n");
                for (const handler of this._iterateDialogueHandlers())
                    await this.reply(handler.uniqueId + ': ' + handler.getState());
                break;
        }
    }
    async _handleAPICall(call) {
        if (call instanceof dialogue_queue_1.default.Notification)
            await this._sendAgentReply(await this._thingtalkHandler.showNotification(call.app, call.outputType, call.outputValue));
        else if (call instanceof dialogue_queue_1.default.Error)
            await this._sendAgentReply(await this._thingtalkHandler.showAsyncError(call.app, call.error));
    }
    async _sendAgentReply(reply) {
        this.conversation.updateLog('context', reply.context);
        this.conversation.updateLog('agent_target', reply.agent_target);
        for (const msg of reply.messages)
            await this.replyGeneric(msg);
        await this.setExpected(reply.expecting);
    }
    async _handleUserInput(command) {
        for (;;) {
            const [handler, analysis] = await this._analyzeCommand(command);
            // save the utterance and complete the turn
            // skip the log if the command was ignored
            this.conversation.updateLog('user', analysis.utterance);
            this.conversation.updateLog('user_target', analysis.user_target);
            await this.conversation.turnFinished();
            if (!handler) {
                await this.fail();
                return;
            }
            if (analysis.type === CommandAnalysisType.STOP ||
                analysis.type === CommandAnalysisType.DEBUG) {
                await this._handleUICommand(analysis.type);
                command = await this.nextCommand();
                continue;
            }
            // reset the state of the handler when we switch to a different one
            if (this._currentHandler && handler !== this._currentHandler)
                await this._currentHandler.reset();
            this._currentHandler = handler;
            const reply = await handler.getReply(analysis);
            this.icon = handler.icon;
            await this._sendAgentReply(reply);
            while (this.expecting === null) {
                const followUp = await handler.getFollowUp();
                if (followUp === null)
                    break;
                this.icon = handler.icon;
                await this._sendAgentReply(followUp);
            }
            // if we're not expecting any more answer from the user,
            // exit this loop
            // note: this does not mean the dialogue is terminated!
            // state is preserved until we call reset() due to context reset
            // timeout, or some command causes a CancellationError
            // (typically, "never mind", or a "no" in sys_anything_else)
            //
            // exiting this loop means that we close the microphone
            // (requiring a wakeword again to continue) and start
            // processing notifications again
            if (this.expecting === null)
                return;
            command = await this.nextCommand();
        }
    }
    async _initialize(showWelcome, initialState) {
        let bestreply, bestpriority = -1;
        for (const handler of this._iterateDialogueHandlers()) {
            const reply = await handler.initialize(initialState ? initialState[handler.uniqueId] : undefined, showWelcome);
            if (reply !== null && handler.priority > bestpriority) {
                bestpriority = handler.priority;
                bestreply = reply;
            }
        }
        if (bestreply)
            await this._sendAgentReply(bestreply);
        else
            await this.setExpected(null);
    }
    async _loop(showWelcome, initialState) {
        await this._initialize(showWelcome, initialState);
        while (!this._stopped) {
            let item;
            try {
                item = await this.nextQueueItem();
                if (item instanceof dialogue_queue_1.default.UserInput)
                    await this._handleUserInput(item.command);
                else
                    await this._handleAPICall(item);
            }
            catch (e) {
                if (e.code === 'ECANCELLED') {
                    for (const handler of this._iterateDialogueHandlers())
                        handler.reset();
                    this._currentHandler = null;
                    this.icon = null;
                    await this.setExpected(null);
                    // if the dialogue terminated, save the last utterance from the agent
                    // in a new turn with an empty utterance from the user
                    await this.conversation.dialogueFinished();
                }
                else {
                    console.error(`Error processing queue item`, item);
                    console.error(e);
                    if (item instanceof dialogue_queue_1.default.UserInput) {
                        await this.replyInterp(this._("Sorry, I had an error processing your command: ${error}."), {
                            error: this._formatError(e)
                        });
                    }
                    else {
                        await this.replyInterp(this._("Sorry, that did not work: ${error}."), {
                            error: this._formatError(e)
                        });
                    }
                    for (const handler of this._iterateDialogueHandlers())
                        handler.reset();
                }
            }
        }
    }
    async nextQueueItem() {
        await this.conversation.sendAskSpecial();
        this._mgrPromise = null;
        this._mgrResolve();
        const queueItem = await this._notifyQueue.pop();
        if (queueItem instanceof dialogue_queue_1.default.UserInput)
            this.platformData = queueItem.command.platformData;
        else
            this.platformData = {};
        return queueItem;
    }
    async lookingFor() {
        if (this.expecting === value_category_1.default.YesNo) {
            await this.reply(this._("Please answer yes or no."));
        }
        else if (this.expecting === value_category_1.default.MultipleChoice) {
            await this.reply(this._("Could you choose one of the following?"));
            await this._resendChoices();
        }
        else if (this.expecting === value_category_1.default.Measure) {
            await this.reply(this._("Could you give me a measurement?"));
        }
        else if (this.expecting === value_category_1.default.Number) {
            await this.reply(this._("Could you give me a number?"));
        }
        else if (this.expecting === value_category_1.default.Date) {
            await this.reply(this._("Could you give me a date?"));
        }
        else if (this.expecting === value_category_1.default.Time) {
            await this.reply(this._("Could you give me a time of day?"));
        }
        else if (this.expecting === value_category_1.default.Picture) {
            await this.reply(this._("Could you upload a picture?"));
        }
        else if (this.expecting === value_category_1.default.Location) {
            await this.reply(this._("Could you give me a place?"));
        }
        else if (this.expecting === value_category_1.default.PhoneNumber) {
            await this.reply(this._("Could you give me a phone number?"));
        }
        else if (this.expecting === value_category_1.default.EmailAddress) {
            await this.reply(this._("Could you give me an email address?"));
        }
        else if (this.expecting === value_category_1.default.RawString || this.expecting === value_category_1.default.Password) {
            // ValueCategory.RawString puts us in raw mode,
            // so we accept almost everything
            // but this will happen if the user clicks a button
            // or upload a picture
            await this.reply(this._("Which is interesting, because I'll take anything at all. Just type your mind!"));
        }
    }
    async fail(msg) {
        if (this.expecting === null) {
            if (msg) {
                await this.replyInterp(this._("Sorry, I did not understand that: ${error}. Can you rephrase it?"), {
                    error: msg
                });
            }
            else {
                await this.reply(this._("Sorry, I did not understand that. Can you rephrase it?"));
            }
        }
        else {
            if (msg)
                await this.replyInterp(this._("Sorry, I did not understand that: ${error}."), { error: msg });
            else
                await this.reply(this._("Sorry, I did not understand that."));
        }
        throw new errors_1.CancellationError();
    }
    setExpected(expected, raw = (expected === value_category_1.default.RawString || expected === value_category_1.default.Password)) {
        if (expected === undefined)
            throw new TypeError();
        this.expecting = expected;
        this.raw = raw;
        const [contextCode, contextEntities] = this._thingtalkHandler.prepareContextForPrediction();
        this.conversation.setExpected(expected, { code: contextCode, entities: contextEntities });
    }
    /**
     * Ask a question to the user.
     *
     * This is a legacy method used for certain scripted interactions.
     */
    async ask(expected, question, args) {
        await this.replyInterp(question, args);
        // force the question to occur in raw mode for locations
        // because otherwise we send it to the parser and the parser will
        // likely misbehave as it's a state that we've never seen in training
        await this.setExpected(expected, expected === value_category_1.default.Location);
        // ignore the OOD logic here because we're bypassing the state machine
        let analyzed = await this._thingtalkHandler.analyzeCommand(await this.nextCommand());
        while (analyzed.answer === null || typeof analyzed.answer === 'number' ||
            value_category_1.default.fromType(analyzed.answer.getType()) !== expected) {
            switch (analyzed.type) {
                case CommandAnalysisType.STOP:
                case CommandAnalysisType.NEVERMIND:
                case CommandAnalysisType.DEBUG:
                    await this._handleUICommand(analyzed.type);
                    break;
                default:
                    await this.fail();
                    await this.lookingFor();
            }
            analyzed = await this._thingtalkHandler.analyzeCommand(await this.nextCommand());
        }
        return analyzed.answer;
    }
    async askChoices(question, choices) {
        await this.reply(question);
        this.setExpected(value_category_1.default.MultipleChoice);
        this.choices = choices;
        for (let i = 0; i < choices.length; i++)
            await this.conversation.sendChoice(i, choices[i]);
        // ignore the OOD logic here because we're bypassing the state machine
        let analyzed = await this._thingtalkHandler.analyzeCommand(await this.nextCommand());
        while (analyzed.answer === null || typeof analyzed.answer !== 'number'
            || analyzed.answer < 0 || analyzed.answer >= choices.length) {
            switch (analyzed.type) {
                case CommandAnalysisType.STOP:
                case CommandAnalysisType.NEVERMIND:
                case CommandAnalysisType.DEBUG:
                    await this._handleUICommand(analyzed.type);
                    break;
                default:
                    await this.fail();
                    await this.lookingFor();
            }
            analyzed = await this._thingtalkHandler.analyzeCommand(await this.nextCommand());
        }
        return analyzed.answer;
    }
    async _resendChoices() {
        if (this.expecting !== value_category_1.default.MultipleChoice)
            console.log('UNEXPECTED: sendChoice while not expecting a MultipleChoice');
        for (let idx = 0; idx < this.choices.length; idx++)
            await this.conversation.sendChoice(idx, this.choices[idx]);
    }
    async replyInterp(msg, args, icon = null) {
        if (args === undefined)
            return this.reply(msg, icon);
        else
            return this.reply(this.interpolate(msg, args), icon);
    }
    async reply(msg, icon) {
        this.conversation.updateLog('agent', msg);
        await this.conversation.sendReply(msg, icon || this.icon);
    }
    async replyGeneric(message, icon) {
        if (typeof message === 'string')
            await this.reply(message, icon);
        else if (message.type === 'text')
            await this.reply(message.text, icon);
        else if (message.type === 'picture' || message.type === 'audio' || message.type === 'video')
            await this.conversation.sendMedia(message.type, message.url, message.alt, icon || this.icon);
        else if (message.type === 'rdl')
            await this.conversation.sendRDL(message, icon || this.icon);
        else if (message.type === 'sound')
            await this.conversation.sendSoundEffect(message.name, message.exclusive, icon || this.icon);
        else if (message.type === 'button')
            await this.conversation.sendButton(message.title, message.json);
    }
    async replyButton(text, json) {
        await this.conversation.sendButton(text, json);
    }
    async replyLink(title, url, state = this.conversation.getState()) {
        await this.conversation.sendLink(title, url, state);
    }
    _isInDefaultState() {
        return this._notifyQueue.hasWaiter();
    }
    dispatchNotify(app, outputType, outputValue) {
        const item = new dialogue_queue_1.default.Notification(app, outputType, outputValue);
        this._pushQueueItem(item);
    }
    dispatchNotifyError(app, error) {
        const item = new dialogue_queue_1.default.Error(app, error);
        this._pushQueueItem(item);
    }
    async _tryLoop(showWelcome, initialState) {
        while (!this._stopped) {
            try {
                await this._loop(showWelcome, initialState);
            }
            catch (e) {
                console.error('Uncaught error in dialog loop', e);
                // loop
            }
            showWelcome = false;
            initialState = null;
        }
    }
    async start(showWelcome, initialState) {
        await this._nlu.start();
        await this._nlg.start();
        this._dynamicHandlers.start();
        const promise = this._waitNextCommand();
        this._tryLoop(showWelcome, initialState);
        return promise;
    }
    async stop() {
        this._stopped = true;
        // wait until the dialog is ready to accept commands, then inject
        // a cancellation error
        await this._mgrPromise;
        (0, assert_1.default)(this._mgrPromise === null);
        if (this._isInDefaultState())
            this._notifyQueue.cancelWait(new errors_1.CancellationError());
        else
            this._userInputQueue.cancelWait(new errors_1.CancellationError());
        this._dynamicHandlers.stop();
        await this._nlu.stop();
        await this._nlg.stop();
    }
    async reset() {
        // wait until the dialog is ready to accept commands
        await this._mgrPromise;
        (0, assert_1.default)(this._mgrPromise === null);
        if (this._isInDefaultState())
            this._notifyQueue.cancelWait(new errors_1.CancellationError());
        else
            this._userInputQueue.cancelWait(new errors_1.CancellationError());
    }
    _pushQueueItem(item) {
        // ensure that we have something to wait on before the next
        // command is handled
        if (!this._mgrPromise)
            this._waitNextCommand();
        this._notifyQueue.push(item);
    }
    /**
     * Returns a promise that will resolve when the dialogue loop is
     * ready to accept the next command from the user.
     */
    _waitNextCommand() {
        const promise = new Promise((callback, errback) => {
            this._mgrResolve = callback;
        });
        this._mgrPromise = promise;
        return promise;
    }
    pushCommand(command) {
        this._pushQueueItem(new dialogue_queue_1.default.UserInput(command));
    }
    async handleCommand(command) {
        // wait until the dialog is ready to accept commands
        await this._mgrPromise;
        (0, assert_1.default)(this._mgrPromise === null);
        const promise = this._waitNextCommand();
        if (this._isInDefaultState())
            this.pushCommand(command);
        else
            this._userInputQueue.push(command);
        return promise;
    }
}
exports.DialogueLoop = DialogueLoop;
function pickHandler(currentHandler, expecting, handlerCandidates, command, debug = false) {
    let best = undefined;
    let bestanalysis = undefined;
    let bestconfidence = 0 /* NO */;
    // If "expecting === null",
    //   this algorithm will choose the dialogue handlers that reports:
    //   - the highest confidence
    //   - if a tie, the highest priority
    //   - if a tie, the current handler
    //   - if a tie, the first handler that reports any confidence at all
    //
    // If "expecting !== null",
    //   this algorithm will choose the current handler, unless one of the following
    //   is true:
    //   - some other handler returns exact_in_domain_command (or similar exact level type)
    //     and it's either higher priority or higher confidence than the current handler
    //   - the current handler returns out_of_domain
    if (debug) {
        for (const handlerItem of handlerCandidates) {
            const handler = handlerItem.handler;
            const analysis = handlerItem.analysis;
            console.log(`Handler ${handler.uniqueId} reports ${CommandAnalysisType[analysis.type]}`);
        }
    }
    if (expecting !== null && currentHandler !== null) {
        const currentAnalysis = handlerCandidates.find((cand) => cand.handler === currentHandler).analysis;
        if (currentAnalysis.type !== CommandAnalysisType.OUT_OF_DOMAIN_COMMAND) {
            let best = undefined;
            let bestanalysis = undefined;
            for (const handlerItem of handlerCandidates) {
                const handler = handlerItem.handler;
                const analysis = handlerItem.analysis;
                switch (analysis.type) {
                    case CommandAnalysisType.STOP:
                    case CommandAnalysisType.DEBUG:
                    case CommandAnalysisType.NEVERMIND:
                    case CommandAnalysisType.WAKEUP:
                    case CommandAnalysisType.EXACT_IN_DOMAIN_COMMAND:
                        if (best === undefined ||
                            (handler.priority > best.priority ||
                                (currentHandler === handler && handler.priority >= best.priority))) {
                            best = handler;
                            bestanalysis = analysis;
                        }
                        break;
                    default:
                    // ignore this handler
                }
            }
            if (best)
                return [best, bestanalysis];
            return [currentHandler, currentAnalysis];
        }
        // fallthrough to the expecting === null case
    }
    for (const handlerItem of handlerCandidates) {
        const handler = handlerItem.handler;
        const analysis = handlerItem.analysis;
        switch (analysis.type) {
            case CommandAnalysisType.STOP:
            case CommandAnalysisType.DEBUG:
            case CommandAnalysisType.NEVERMIND:
            case CommandAnalysisType.WAKEUP:
            case CommandAnalysisType.EXACT_IN_DOMAIN_COMMAND:
                // choose if either
                // - we're higher priority
                // - we're more confident
                if (best === undefined ||
                    (bestconfidence < 4 /* ABSOLUTE */ ||
                        handler.priority > best.priority ||
                        (currentHandler === handler && handler.priority >= best.priority))) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 4 /* ABSOLUTE */;
                }
                break;
            case CommandAnalysisType.STRONGLY_CONFIDENT_IN_DOMAIN_COMMAND:
                // choose if either
                // - we're higher priority
                // - we're more confident
                // - we're the current dialogue and we have the same priority
                if (best === undefined ||
                    (bestconfidence < 3 /* HIGH */ ||
                        (bestconfidence <= 3 /* HIGH */ && handler.priority > best.priority) ||
                        (bestconfidence <= 3 /* HIGH */ && handler.priority >= best.priority && currentHandler === handler))) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 3 /* HIGH */;
                }
                break;
            case CommandAnalysisType.CONFIDENT_IN_DOMAIN_COMMAND:
                // choose if either
                // - we're higher priority
                // - we're more confident
                // - we're the current dialogue and we have the same priority
                if (best === undefined ||
                    (bestconfidence < 2 /* NORMAL */ ||
                        (bestconfidence <= 2 /* NORMAL */ && handler.priority > best.priority) ||
                        (bestconfidence <= 2 /* NORMAL */ && handler.priority >= best.priority && currentHandler === handler))) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 2 /* NORMAL */;
                }
                break;
            case CommandAnalysisType.NONCONFIDENT_IN_DOMAIN_COMMAND:
                // choose if both:
                // - we're higher priority (same if we're the current dialogue)
                // - we're as confident
                if (best === undefined ||
                    ((handler.priority > best.priority ||
                        (currentHandler === handler &&
                            handler.priority >= best.priority)) &&
                        bestconfidence <= 1 /* LOW */)) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 1 /* LOW */;
                }
                break;
            case CommandAnalysisType.EXACT_IN_DOMAIN_FOLLOWUP:
                if (currentHandler === handler &&
                    (best === undefined ||
                        bestconfidence < 4 /* ABSOLUTE */ ||
                        handler.priority > best.priority)) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 4 /* ABSOLUTE */;
                }
                break;
            case CommandAnalysisType.STRONGLY_CONFIDENT_IN_DOMAIN_FOLLOWUP:
                // choose if handler is the current handler and either
                // - we're same priority
                // - we're more confident
                if (currentHandler === handler &&
                    (best === undefined ||
                        handler.priority >= best.priority ||
                        bestconfidence < 3 /* HIGH */)) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 3 /* HIGH */;
                }
                break;
            case CommandAnalysisType.CONFIDENT_IN_DOMAIN_FOLLOWUP:
                // choose if handler is the current handler and either
                // - we're same priority
                // - we're more confident
                if (currentHandler === handler &&
                    (best === undefined ||
                        handler.priority >= best.priority ||
                        bestconfidence < 2 /* NORMAL */)) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 2 /* NORMAL */;
                }
                break;
            case CommandAnalysisType.NONCONFIDENT_IN_DOMAIN_FOLLOWUP:
                // choose if handler is the current handler and either
                // - we're same priority
                // - we're as confident
                if (currentHandler === handler &&
                    (best === undefined ||
                        (handler.priority >= best.priority && bestconfidence <= 1 /* LOW */))) {
                    best = handler;
                    bestanalysis = analysis;
                    bestconfidence = 1 /* LOW */;
                }
                break;
            default:
            // ignore this handler, which decided the command is out of domain
        }
    }
    return [best,
        bestanalysis ||
            { type: CommandAnalysisType.OUT_OF_DOMAIN_COMMAND,
                utterance: command.type === 'command' ? command.utterance : command.parsed.prettyprint(),
                user_target: '$failed;' }];
}
exports.pickHandler = pickHandler;
//# sourceMappingURL=dialogue-loop.js.map