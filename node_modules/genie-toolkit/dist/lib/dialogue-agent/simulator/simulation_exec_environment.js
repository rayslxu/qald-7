"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimulatedError = exports.SimulationExecEnvironment = exports.ResultGenerator = void 0;
const polyfill_1 = require("@js-temporal/polyfill");
const assert_1 = __importDefault(require("assert"));
const ThingTalk = __importStar(require("thingtalk"));
const thingtalk_1 = require("thingtalk");
const random_1 = require("../../utils/random");
const helpers_1 = require("./helpers");
function makeJSDate(timezone, day) {
    // emulate the behavior of JS date where passed a very large day number
    // (which we do in the result generator when creating random dates)
    const datetz = polyfill_1.Temporal.ZonedDateTime.from({
        timeZone: timezone,
        year: 2018, month: 1, day: 1
    }).add({ days: day - 1 });
    return new Date(datetz.epochMilliseconds);
}
class ResultGenerator {
    constructor(rng, timezone, overrides) {
        this._rng = rng;
        this._timezone = timezone;
        this._overrides = overrides;
        this._candidates = new Map;
        this._constants = new Map;
    }
    _doAddCandidate(key, jsValue) {
        let candidates = this._candidates.get(key);
        if (candidates === undefined) {
            candidates = [];
            this._candidates.set(key, candidates);
        }
        candidates.push(jsValue);
    }
    addCandidate(value) {
        if (value instanceof thingtalk_1.Ast.ArrayValue || !value.isConstant())
            return;
        if (value.isBoolean || value.isEnum)
            return;
        if (value instanceof thingtalk_1.Ast.DateValue || value instanceof thingtalk_1.Ast.RecurrentTimeSpecificationValue)
            value = value.normalize(this._timezone);
        const jsValue = value.toJS();
        if (value.isString) {
            this._doAddCandidate('QUOTED_STRING', jsValue);
        }
        else if (value.isNumber) {
            this._doAddCandidate('NUMBER', jsValue);
        }
        else if (value.isCurrency) {
            this._doAddCandidate('CURRENCY', jsValue.value);
        }
        else if (value.isMeasure) {
            const type = value.getType();
            (0, assert_1.default)(type instanceof thingtalk_1.Type.Measure);
            this._doAddCandidate('MEASURE_' + type.unit, jsValue);
        }
        else if (value.isTime) {
            this._doAddCandidate('TIME', jsValue);
        }
        else if (value.isDate) {
            this._doAddCandidate('DATE', jsValue);
        }
        else if (value.isLocation) {
            this._doAddCandidate('LOCATION', jsValue);
        }
        else if (value instanceof thingtalk_1.Ast.EntityValue) {
            this._doAddCandidate('ENTITY_' + value.type, String(jsValue));
        }
    }
    generate(schema, params, index) {
        const result = {};
        Object.assign(result, params);
        for (const arg of schema.iterateArguments()) {
            if (arg.direction !== thingtalk_1.Ast.ArgDirection.OUT)
                continue;
            if (arg.name.indexOf('.') >= 0)
                continue;
            if (this._overrides.has(arg.name))
                result[arg.name] = this._overrides.get(arg.name);
            else if (arg.name === 'id' && arg.type instanceof thingtalk_1.Type.Entity)
                result[arg.name] = new ThingTalk.Builtin.Entity(`str:ENTITY_${arg.type.type}::${index}:`, null);
            else
                result[arg.name] = this._generateValue(arg.type, arg.name !== 'id', arg);
        }
        return result;
    }
    _generateValue(type, repeatable = true, arg) {
        if (type instanceof thingtalk_1.Type.Compound) {
            const result = {};
            for (const field in type.fields) {
                const arg = type.fields[field];
                (0, assert_1.default)(arg instanceof thingtalk_1.Ast.ArgumentDef);
                result[field] = this._generateValue(arg.type, true, arg);
            }
            return result;
        }
        if (type instanceof thingtalk_1.Type.Array) {
            const length = (0, random_1.randint)(1, 3, this._rng);
            const buffer = [];
            // do not repeat values inside the array
            for (let i = 0; i < length; i++)
                buffer.push(this._generateValue(type.elem, false, arg));
            return buffer;
        }
        if (type.isBoolean)
            return !!(0, random_1.coin)(0.5, this._rng);
        if (type.isString)
            return this._generateString(`QUOTED_STRING`, repeatable);
        if (type.isNumber)
            return this._generateNumber(`NUMBER`, repeatable, arg);
        if (type instanceof thingtalk_1.Type.Measure)
            return this._generateNumber(`MEASURE_` + type.unit, repeatable, arg);
        if (type.isCurrency)
            return new ThingTalk.Builtin.Currency(this._generateNumber(`CURRENCY`, repeatable), 'usd');
        if (type.isTime)
            return this._generateTime(repeatable);
        if (type.isDate)
            return this._generateDate(repeatable);
        if (type.isLocation)
            return this._generateLocation(repeatable);
        if (type instanceof thingtalk_1.Type.Enum)
            return (0, random_1.uniform)(type.entries, this._rng);
        if (type instanceof thingtalk_1.Type.Entity)
            return new ThingTalk.Builtin.Entity(this._generateString('ENTITY_' + type.type, repeatable), null);
        if (type === thingtalk_1.Type.RecurrentTimeSpecification) {
            // TODO
            return [new ThingTalk.Builtin.RecurrentTimeRule({
                    beginTime: new ThingTalk.Builtin.Time(0, 0),
                    endTime: new ThingTalk.Builtin.Time(24, 0),
                    interval: 86400000,
                    frequency: 1,
                    dayOfWeek: null,
                    beginDate: null,
                    endDate: null,
                    subtract: false
                })];
        }
        throw new TypeError(`Invalid constant of type ${type}`);
    }
    _generateTime(repeatable) {
        const reused = this._reuseConstant('TIME', repeatable);
        if (reused !== undefined)
            return reused;
        const newTime = new ThingTalk.Builtin.Time((0, random_1.randint)(0, 23, this._rng), (0, random_1.randint)(0, 59, this._rng), 0);
        this._constants.get('TIME').push(newTime);
        return newTime;
    }
    _generateDate(repeatable) {
        const reused = this._reuseConstant('DATE', repeatable);
        if (reused !== undefined)
            return reused;
        const num = this._generateNumber('DATE::number', repeatable);
        (0, assert_1.default)(Number.isFinite(num));
        const date = makeJSDate(this._timezone, num);
        (0, assert_1.default)(Number.isFinite(date.getTime()));
        return date;
    }
    _generateLocation(repeatable) {
        const reused = this._reuseConstant('LOCATION', repeatable);
        if (reused !== undefined)
            return reused;
        const lat = (0, random_1.randint)(-90, 90, this._rng);
        const lon = (0, random_1.randint)(-180, 180, this._rng);
        const newLocation = new ThingTalk.Builtin.Location(lat, lon, null);
        this._constants.get('LOCATION').push(newLocation);
        return newLocation;
    }
    _generateNumber(key, repeatable, arg) {
        const reused = this._reuseConstant(key, repeatable);
        if (reused !== undefined)
            return reused;
        let min, max;
        min = 20;
        max = 1000;
        if (arg) {
            const minArg = arg.getImplementationAnnotation('min_number');
            if (minArg !== undefined) {
                min = minArg;
                max = Math.max(max, minArg + 20);
            }
            const maxArg = arg.getImplementationAnnotation('max_number');
            if (maxArg !== undefined)
                max = maxArg;
        }
        // with 50% probability, generate a "small" number
        if ((0, random_1.coin)(0.5, this._rng)) {
            min = Math.max(min, 1);
            max = Math.min(max, 20);
        }
        if (max <= min)
            max = min;
        const newNumber = (0, random_1.randint)(min, max, this._rng);
        (0, assert_1.default)(Number.isFinite(newNumber));
        this._constants.get(key).push(newNumber);
        return newNumber;
    }
    _generateString(key, repeatable) {
        const reused = this._reuseConstant(key, repeatable);
        if (reused !== undefined)
            return reused;
        const newString = `str:${key}::${Math.floor(this._rng() * 50)}:`;
        this._constants.get(key).push(newString);
        return newString;
    }
    generateString() {
        return this._generateString('QUOTED_STRING', false);
    }
    _reuseConstant(key, repeatable) {
        // first check if we have something in the program already
        const candidates = this._candidates.get(key);
        if (repeatable && candidates && candidates.length > 0 && (0, random_1.coin)(0.5, this._rng))
            return (0, random_1.uniform)(candidates, this._rng);
        // then try to reuse one of the constants we already generated
        let previous = this._constants.get(key);
        if (previous === undefined) {
            previous = [];
            this._constants.set(key, previous);
        }
        if (repeatable && previous.length > 0 && (0, random_1.coin)(0.1, this._rng))
            return (0, random_1.uniform)(previous, this._rng);
        return undefined;
    }
}
exports.ResultGenerator = ResultGenerator;
class SimulatedError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
exports.SimulatedError = SimulatedError;
function parseTime(v) {
    if (typeof v === 'string') {
        const [hourstr, minutestr, secondstr] = v.split(':');
        const hour = parseInt(hourstr);
        const minute = parseInt(minutestr);
        let second;
        if (secondstr === undefined)
            second = 0;
        else
            second = parseInt(secondstr);
        return new ThingTalk.Time(hour, minute, second);
    }
    else {
        const time = v;
        return new ThingTalk.Time(time.hour, time.minute, time.second);
    }
}
function loadRecurrentTimeSpec(value) {
    (0, assert_1.default)(Array.isArray(value));
    return value.map((v) => {
        var _a, _b, _c, _d;
        return new ThingTalk.Builtin.RecurrentTimeRule({
            beginTime: parseTime(v.beginTime),
            endTime: parseTime(v.endTime),
            interval: (_a = v.interval) !== null && _a !== void 0 ? _a : 86400000,
            frequency: (_b = v.frequency) !== null && _b !== void 0 ? _b : 1,
            dayOfWeek: (_c = v.dayOfWeek) !== null && _c !== void 0 ? _c : null,
            beginDate: v.beginDate ? new Date(v.beginDate) : null,
            endDate: v.endDate ? new Date(v.endDate) : null,
            subtract: (_d = v.subtract) !== null && _d !== void 0 ? _d : false
        });
    });
}
function loadSimulationValue(schema, type, value, keyPrefix) {
    if (value === null || value === undefined)
        return undefined;
    if (type instanceof thingtalk_1.Type.Array)
        return value.map((v) => loadSimulationValue(schema, type.elem, v, keyPrefix));
    if (type instanceof thingtalk_1.Type.Compound) {
        const mapped = {};
        for (const key in value) {
            const inner = value[key];
            const arg = schema.getArgument(keyPrefix + key);
            mapped[key] = loadSimulationValue(schema, arg.type, inner, keyPrefix + key + '.');
        }
        return mapped;
    }
    if (type instanceof thingtalk_1.Type.Entity) {
        if (typeof value === 'object') {
            const entity = value;
            return new ThingTalk.Entity(entity.value, entity.display);
        }
        else {
            return new ThingTalk.Entity(value, null);
        }
    }
    if (type.isLocation) {
        const loc = value;
        return new ThingTalk.Location(loc[0], loc[1], loc[2]);
    }
    if (type.isTime)
        return parseTime(value);
    if (type.isDate)
        return new Date(value);
    if (type === thingtalk_1.Type.RecurrentTimeSpecification)
        return loadRecurrentTimeSpec(value);
    return value;
}
function recursivelyComputeOutputType(kind, expr) {
    if (expr instanceof thingtalk_1.Ast.InvocationExpression)
        return kind + ':' + expr.invocation.channel;
    if (expr instanceof thingtalk_1.Ast.ChainExpression)
        return expr.expressions.map((exp) => recursivelyComputeOutputType(kind, exp)).join('+');
    if (expr instanceof thingtalk_1.Ast.AggregationExpression)
        return expr.operator + '(' + recursivelyComputeOutputType(kind, expr.expression) + ')';
    if ('expression' in expr) // projection, index, slice
        return recursivelyComputeOutputType(kind, expr.expression);
    throw new TypeError('Invalid query expression ' + expr);
}
function genFakeData(size, fill) {
    if (size > 10000)
        throw new SimulatedError('too big');
    return String(Buffer.alloc(size, fill));
}
class SimpleTestDevice {
    constructor() {
        this._sequenceNumber = 0;
    }
    next_sequence() {
        return [{ number: this._sequenceNumber++ }];
    }
    async *get_data({ size, count }) {
        if (!(count >= 0))
            count = 1;
        for (let i = 0; i < count; i++)
            yield ({ data: genFakeData(size, '!'.charCodeAt(0) + i) });
    }
    async *get_data2({ size, count }) {
        if (!(count >= 0))
            count = 1;
        for (let i = 0; i < count; i++)
            yield ({ data: genFakeData(size, 'A'.charCodeAt(0) + i) });
    }
    dup_data({ data_in }) {
        return [{ data_out: data_in + data_in }];
    }
}
class SimulationExecEnvironment extends thingtalk_1.ExecEnvironment {
    constructor(locale, timezone, schemas, database, { rng, simulateErrors = true }) {
        super();
        this._testDevice = new SimpleTestDevice();
        this._execCache = [];
        this._schemas = schemas;
        this._database = database;
        this._rng = rng;
        this._simulateErrors = simulateErrors;
        this._locale = locale;
        this._timezone = timezone !== null && timezone !== void 0 ? timezone : polyfill_1.Temporal.Now.timeZone().id;
        this.generator = null;
    }
    setOutputDelegate(delegate) {
        this._delegate = delegate;
    }
    get program_id() {
        return new ThingTalk.Entity('uuid-simulation', null);
    }
    get locale() {
        return this._locale;
    }
    get timezone() {
        return this._timezone;
    }
    clearGetCache() {
        // do not actually clear the get cache
        // all queries are expected to return consistent results
    }
    async reportError(message, error) {
        await this._delegate.error(error);
    }
    async output(outputType, outputValues) {
        await this._delegate.output(outputType, outputValues);
    }
    _findInCache(functionKey, attrs, params) {
        for (const cached of this._execCache) {
            const [_function, cachedattrs, cachedparams, result] = cached;
            if (_function === functionKey &&
                ThingTalk.Builtin.equality(cachedattrs, attrs) &&
                ThingTalk.Builtin.equality(cachedparams, params))
                return result;
        }
        return null;
    }
    _failAction(schema) {
        const errors = Object.keys(schema.metadata.on_error || {});
        if (errors.length === 0)
            throw new SimulatedError(this.generator.generateString());
        else
            throw new SimulatedError(this.generator.generateString(), (0, random_1.uniform)(errors, this._rng));
    }
    async _getDevices(kind, attrs) {
        if (attrs.id) {
            if (attrs.id.startsWith('str:ENTITY_tt:device_id::')) {
                const index = attrs.id.substring('str:ENTITY_tt:device_id::'.length, attrs.id.length - 1);
                return [{
                        kind, name: `Simulated Device ${kind} ${index}`, uniqueId: attrs.id
                    }];
            }
            else {
                return [{
                        kind, name: attrs.name || 'Unknown device', uniqueId: attrs.id
                    }];
            }
        }
        else {
            return (0, helpers_1.getAllDevicesOfKind)(this._schemas, kind);
        }
    }
    async *invokeAction(kind, attrs, fname, params) {
        const outputType = kind + ':action/' + fname;
        const schema = await this._schemas.getMeta(kind, 'action', fname);
        const fromDB = await this._tryFromSimulationDatabase(schema, 'action', kind, fname, params, null);
        if (fromDB) {
            for (const el of fromDB)
                yield el;
            return;
        }
        // with some probability, fail the action
        if (this._simulateErrors && (0, random_1.coin)(0.1, this._rng)) {
            await this._failAction(schema);
            return;
        }
        let index = 0;
        for (const d of await this._getDevices(kind, attrs)) {
            const generated = this.generator.generate(schema, params, index++);
            if (d.kind !== d.uniqueId)
                generated.__device = new ThingTalk.Builtin.Entity(d.uniqueId, d.name);
            yield [outputType, generated];
        }
    }
    async _tryFromSimulationDatabase(schema, ftype, kind, fname, params, hints) {
        let outputType, dbKey;
        if (ftype === 'action') {
            outputType = kind + ':action/' + fname;
            dbKey = kind + ':' + fname;
        }
        else {
            outputType = dbKey = kind + ':' + fname;
        }
        if (!this._database || !this._database.has(dbKey))
            return null;
        const data = this._database.get(dbKey);
        if (hints) {
            // HACK: sort multiwoz train search results so that the context is correct already
            // if the user is searching by arrive_by, sort by arrive_by desc
            if (hints.filter && hints.filter.some(([pname,]) => pname === 'arrive_by')) {
                data.sort((one, two) => {
                    if (one.arrive_by < two.arrive_by)
                        return 1;
                    if (two.arrive_by < one.arrive_by)
                        return -1;
                    return 0;
                });
            }
            // if the user is searching by leave_at, sort by leave_at asc
            if (hints.filter && hints.filter.some(([pname,]) => pname === 'leave_at')) {
                data.sort((one, two) => {
                    if (one.leave_at < two.leave_at)
                        return -1;
                    if (two.leave_at < one.leave_at)
                        return 1;
                    return 0;
                });
            }
        }
        const mapped = data.map((item) => {
            const mapped = {};
            for (const key in item) {
                if (key === '$error') {
                    mapped[key] = item[key];
                    continue;
                }
                const value = item[key];
                const arg = schema.getArgument(key);
                if (!arg)
                    continue;
                mapped[key] = loadSimulationValue(schema, arg.type, value, '');
            }
            return [outputType, mapped];
        }).filter(([outputType, data]) => {
            for (const key in params) {
                const pvalue = params[key];
                const dvalue = data[key];
                if (!dvalue)
                    continue;
                if (!ThingTalk.Builtin.equality(pvalue, dvalue))
                    return false;
            }
            return true;
        });
        if (mapped.length === 0)
            return schema.is_list ? [[], false] : null;
        if (ftype === 'action') {
            const choice = (0, random_1.uniform)(mapped, this._rng);
            if (choice[1].$error) {
                const err = choice[1].$error;
                throw new SimulatedError(err.message, err.code);
            }
            return [choice];
        }
        else {
            // note: if the query is a list, we return everything, and the query response is not
            // cached between successive statements, so we can change the sort order depending on
            // what the user is filtering for
            // if the query is a single result, the result is cached if the query is monitorable
            // so we return consistent results to later projection questions
            if (schema.is_list)
                return [mapped, false];
            const choice = (0, random_1.uniform)(mapped, this._rng);
            if (choice[1].$error) {
                const err = choice[1].$error;
                throw new SimulatedError(err.message, err.code);
            }
            return [[choice], schema.is_monitorable];
        }
    }
    async _doInvokeQuery(kind, attrs, fname, params, hints) {
        const outputType = kind + ':' + fname;
        const schema = await this._schemas.getMeta(kind, 'query', fname);
        const fromDB = await this._tryFromSimulationDatabase(schema, 'query', kind, fname, params, hints);
        if (fromDB)
            return fromDB;
        if (kind === 'org.thingpedia.builtin.test') {
            const results = [];
            for await (const result of (this._testDevice[fname](params))) {
                Object.assign(result, params);
                results.push([outputType, result]);
            }
            return [results, false];
        }
        // with some probability, fail the query
        if (this._simulateErrors && (0, random_1.coin)(0.1, this._rng)) {
            await this._failAction(schema);
            return [[], false];
        }
        let numResults, cacheable;
        if (schema.is_list) {
            // with some probability, return no results, so we hit the search error path
            if ((0, random_1.coin)(0.1, this._rng)) {
                numResults = 0;
                cacheable = false;
            }
            else {
                numResults = (0, random_1.randint)(50, 100, this._rng);
                cacheable = true;
            }
        }
        else {
            numResults = 1;
            cacheable = true;
        }
        const results = [];
        const devices = await this._getDevices(kind, attrs);
        let index = 0;
        for (const d of devices) {
            for (let i = 0; i < numResults; i++) {
                const generated = this.generator.generate(schema, params, index++);
                if (d.uniqueId !== d.kind)
                    generated.__device = new ThingTalk.Builtin.Entity(d.uniqueId, d.name);
                results.push([outputType, generated]);
            }
        }
        return [results, cacheable];
    }
    async *invokeQuery(kind, attrs, fname, params, hints) {
        const functionKey = kind + ':' + fname;
        const cached = this._findInCache(functionKey, attrs, params);
        if (cached) {
            for (const el of cached)
                yield el;
            return;
        }
        const [list, cacheable] = await this._doInvokeQuery(kind, attrs, fname, params, hints);
        if (cacheable)
            this._execCache.push([functionKey, attrs, params, list]);
        for (const el of list)
            yield el;
    }
    async *invokeDBQuery(kind, attrs, query) {
        assert_1.default.strictEqual(query.statements.length, 1);
        const command = query.statements[0];
        (0, assert_1.default)(command instanceof thingtalk_1.Ast.ExpressionStatement);
        const schema = command.expression.schema;
        (0, assert_1.default)(schema);
        const numResults = (0, random_1.randint)(50, 100, this._rng);
        const outputType = recursivelyComputeOutputType(kind, command.expression);
        for (let i = 0; i < numResults; i++)
            yield [outputType, this.generator.generate(schema, {}, i)];
    }
    async formatEvent(outputType, output, hint) {
        return this.generator.generateString();
    }
}
exports.SimulationExecEnvironment = SimulationExecEnvironment;
//# sourceMappingURL=simulation_exec_environment.js.map