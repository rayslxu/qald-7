"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events = __importStar(require("events"));
const ThingTalk = __importStar(require("thingtalk"));
const Stream = __importStar(require("stream"));
const I18n = __importStar(require("../i18n"));
const value_category_1 = __importDefault(require("./value-category"));
const dialogue_loop_1 = require("./dialogue-loop");
const protocol_1 = require("./protocol");
const ThingTalkUtils = __importStar(require("../utils/thingtalk"));
const parsers_1 = require("../dataset-tools/parsers");
const logging_1 = __importDefault(require("./logging"));
const conversation_history_1 = __importDefault(require("./conversation_history"));
const DummyStatistics = {
    hit() {
    }
};
const DEFAULT_CONVERSATION_TTL = 600000; // 10 minutes
/**
 * A single session of conversation in Genie.
 *
 * This object is responsible for maintaining the history of the conversation
 * to support clients reconnecting to the same conversation later, as well
 * as tracking connected clients and inactivity timeouts.
 */
class Conversation extends events.EventEmitter {
    constructor(engine, conversationId, options = {}) {
        var _a, _b;
        super();
        this._engine = engine;
        this._conversationStateDB = this._engine.db.getLocalTable('conversation_state');
        this._conversationId = conversationId;
        this._locale = this._engine.platform.locale;
        this._ = I18n.get(this._locale).gettext;
        const stats = this._engine.platform.getCapability('statistics');
        if (stats === null)
            this._stats = DummyStatistics;
        else
            this._stats = stats;
        this._options = options;
        this._debug = !!this._options.debug;
        this._dialogueFlags = options.dialogueFlags || {};
        this._recording = (_a = options.log) !== null && _a !== void 0 ? _a : false;
        this.rng = options.rng || Math.random;
        this._loop = new dialogue_loop_1.DialogueLoop(this, this._engine, {
            nluServerUrl: options.nluServerUrl,
            nlgServerUrl: options.nlgServerUrl,
            faqModels: options.faqModels || {},
            useConfidence: (_b = options.useConfidence) !== null && _b !== void 0 ? _b : true,
            debug: this._debug,
            rng: this.rng,
        });
        this._expecting = null;
        this._context = { code: ['null'], entities: {} };
        this._delegates = new Set;
        this._history = new conversation_history_1.default(engine, conversationId);
        this._lastMessageId = -1;
        this._started = false;
        this._contextResetTimeout = null;
        this._contextResetTimeoutSec = options.contextResetTimeout || DEFAULT_CONVERSATION_TTL;
        this._log = new logging_1.default(engine.db.getLocalTable('conversation'), this._conversationId);
    }
    get isAnonymous() {
        return !!this._options.anonymous;
    }
    get id() {
        return this._conversationId;
    }
    get engine() {
        return this._engine;
    }
    get stats() {
        return this._stats;
    }
    get inRecordingMode() {
        return this._recording;
    }
    get dialogueFlags() {
        return this._dialogueFlags;
    }
    async startRecording() {
        this._recording = true;
        await this._saveState();
    }
    async endRecording() {
        await this._log.dialogueFinished();
        this._recording = false;
        await this._saveState();
    }
    notify(app, outputType, outputValue) {
        return this._loop.dispatchNotify(app, outputType, outputValue);
    }
    notifyError(app, error) {
        return this._loop.dispatchNotifyError(app, error);
    }
    setExpected(expecting, context) {
        this._expecting = expecting;
        this._context = context;
    }
    async start(state) {
        await this._history.init();
        this._resetInactivityTimeout();
        if (state) {
            this._lastMessageId = state.lastMessageId;
            this._recording = state.recording;
        }
        this._started = true;
        return this._loop.start(!!this._options.showWelcome, state ? state.dialogueState : null);
    }
    async stop() {
        return this._loop.stop();
    }
    _resetInactivityTimeout() {
        // after "options.contextResetTimeout", we reset the context, forgetting the state of the
        // conversation
        if (this._contextResetTimeout)
            clearTimeout(this._contextResetTimeout);
        if (this._contextResetTimeoutSec > 0) {
            this._contextResetTimeout = setTimeout(() => {
                this._loop.reset();
            }, this._contextResetTimeoutSec);
        }
    }
    async addOutput(out, replayHistory = true) {
        this._delegates.add(out);
        if (replayHistory) {
            for (const msg of this._history.getCached()) {
                if (!await this._callDelegate(out, (out) => out.addMessage(msg)))
                    return;
            }
        }
        if (this._started) {
            const what = value_category_1.default.toString(this._expecting);
            await this._callDelegate(out, (out) => out.setExpected(what, this._context));
        }
    }
    removeOutput(out) {
        this._delegates.delete(out);
    }
    async _callDelegate(out, fn) {
        try {
            await fn(out);
            return true;
        }
        catch (e) {
            // delegate disappeared (likely a disconnected websocket)
            out.destroy();
            return false;
        }
    }
    _callDelegates(fn) {
        return Promise.all(Array.from(this._delegates).map((out) => this._callDelegate(out, fn)));
    }
    async setHypothesis(hypothesis) {
        await this._callDelegates((out) => out.setHypothesis(hypothesis));
    }
    async sendAskSpecial() {
        const what = value_category_1.default.toString(this._expecting);
        if (this._debug) {
            if (what !== null && what !== 'generic')
                console.log('Genie sends a special request');
            else if (what !== null)
                console.log('Genie expects an answer');
        }
        await this._callDelegates((out) => out.setExpected(what, this._context));
    }
    /**
     * Add a message to the conversation history.
     *
     * This method is exported to inject conversation history from outside.
     */
    async addMessage(msg) {
        if (msg.id !== undefined)
            this._lastMessageId = Math.max(this._lastMessageId, msg.id);
        else
            msg.id = (this._lastMessageId++) + 1;
        await this._history.addMessage(msg);
        await this._callDelegates((out) => out.addMessage(msg));
        await this._saveState();
    }
    async _saveState() {
        const serializedDialogueState = JSON.stringify(this._loop.getState());
        console.log(`Saving conversation state for ${this._conversationId} (${serializedDialogueState.length} characters)`);
        await this._conversationStateDB.insertOne(this._conversationId, {
            dialogueState: serializedDialogueState,
            lastMessageId: this._lastMessageId,
            recording: this._recording,
        });
    }
    /**
     * Extract the state from the conversation.
     *
     * This method is provided to save and restore the conversation state,
     * and transfer the conversation state between engines.
     */
    getState() {
        return {
            dialogueState: this._loop.getState(),
            lastMessageId: this._lastMessageId,
            recording: this._recording,
        };
    }
    async handleCommand(command, platformData = {}) {
        this._engine.updateActivity();
        // if the command is just whitespace, ignore it without even adding it to the history
        if (!command.trim())
            return;
        this.stats.hit('sabrina-command');
        this.emit('active');
        this._resetInactivityTimeout();
        await this.addMessage({ type: protocol_1.MessageType.COMMAND, command });
        if (this._debug)
            console.log('Received assistant command ' + command);
        await this._loop.handleCommand({ type: 'command', utterance: command, platformData });
    }
    async handleParsedCommand(root, title, platformData = {}) {
        this._engine.updateActivity();
        const command = `\\r ${typeof root === 'string' ? root : JSON.stringify(root)}`;
        this.stats.hit('sabrina-parsed-command');
        this.emit('active');
        this._resetInactivityTimeout();
        if (typeof root === 'string')
            root = JSON.parse(root);
        await this.addMessage({ type: protocol_1.MessageType.COMMAND, command: title || command, json: root });
        if (this._debug)
            console.log('Received pre-parsed assistant command');
        if (root.example_id) {
            this._engine.thingpedia.clickExample(root.example_id).catch((e) => {
                console.error('Failed to record example click: ' + e.message);
            });
        }
        if ('program' in root)
            return this.handleThingTalk(root.program, platformData);
        const { code, entities } = root;
        for (const name in entities) {
            if (name.startsWith('SLOT_')) {
                const slotname = root.slots[parseInt(name.substring('SLOT_'.length))];
                const slotType = ThingTalk.Type.fromString(root.slotTypes[slotname]);
                const value = ThingTalk.Ast.Value.fromJSON(slotType, entities[name]);
                entities[name] = value;
            }
        }
        const parsed = await ThingTalkUtils.parsePrediction(code, entities, {
            timezone: this._engine.platform.timezone,
            thingpediaClient: this._engine.thingpedia,
            schemaRetriever: this._engine.schemas,
            loadMetadata: true
        }, true);
        return this._loop.handleCommand({ type: 'thingtalk', parsed, platformData });
    }
    async handleThingTalk(program, platformData = {}) {
        this._engine.updateActivity();
        const command = `\\t ${program}`;
        this.stats.hit('sabrina-thingtalk-command');
        this.emit('active');
        this._resetInactivityTimeout();
        await this.addMessage({ type: protocol_1.MessageType.COMMAND, command });
        if (this._debug)
            console.log('Received ThingTalk program');
        const parsed = await ThingTalkUtils.parse(program, {
            timezone: this._engine.platform.timezone,
            thingpediaClient: this._engine.thingpedia,
            schemaRetriever: this._engine.schemas,
            loadMetadata: true
        });
        return this._loop.handleCommand({ type: 'thingtalk', parsed, platformData });
    }
    sendReply(message, icon) {
        if (this._debug)
            console.log('Genie says: ' + message);
        return this.addMessage({ type: protocol_1.MessageType.TEXT, text: message, icon });
    }
    sendMedia(mediaType, url, alt, icon) {
        if (this._debug)
            console.log('Genie sends ' + mediaType + ': ' + url);
        return this.addMessage({ type: mediaType, url, alt, icon });
    }
    sendRDL(rdl, icon) {
        if (this._debug)
            console.log('Genie sends RDL: ' + rdl.callback);
        return this.addMessage({ type: protocol_1.MessageType.RDL, rdl, icon });
    }
    sendSoundEffect(name, exclusive = false, icon) {
        if (this._debug)
            console.log('Genie sends sound effect: ' + name);
        return this.addMessage({ type: protocol_1.MessageType.SOUND_EFFECT, name, exclusive, icon });
    }
    sendChoice(idx, title) {
        if (this._expecting !== value_category_1.default.MultipleChoice)
            console.log('UNEXPECTED: sendChoice while not expecting a MultipleChoice');
        if (this._debug)
            console.log('Genie sends multiple choice button: ' + title);
        return this.addMessage({ type: protocol_1.MessageType.CHOICE, idx, title });
    }
    sendButton(title, json) {
        if (this._debug)
            console.log('Genie sends generic button: ' + title);
        return this.addMessage({ type: protocol_1.MessageType.BUTTON, json, title });
    }
    sendLink(title, url, state) {
        if (this._debug)
            console.log('Genie sends link: ' + url);
        return this.addMessage({ type: protocol_1.MessageType.LINK, url, title, state });
    }
    sendNewProgram(program) {
        if (this._debug)
            console.log('Genie executed new program: ' + program.uniqueId);
        return this.addMessage({ type: protocol_1.MessageType.NEW_PROGRAM, ...program });
    }
    async dialogueFinished() {
        if (!this.inRecordingMode)
            return;
        await this._log.dialogueFinished();
    }
    async turnFinished() {
        if (!this.inRecordingMode)
            return;
        await this._log.turnFinished();
    }
    async voteLast(vote) {
        if (!this.inRecordingMode)
            return;
        await this._log.voteLast(vote);
    }
    async commentLast(comment) {
        if (!this.inRecordingMode)
            return;
        await this._log.commentLast(comment);
    }
    updateLog(field, value) {
        if (!this.inRecordingMode)
            return;
        this._log.updateLog(field, value);
    }
    readLog() {
        const readable = Stream.Readable.from(this._log.read());
        const serializer = new parsers_1.DialogueSerializer({ annotations: true });
        return readable.pipe(serializer);
    }
}
exports.default = Conversation;
//# sourceMappingURL=conversation.js.map