import AssistantEngine from '../../engine';
import { EntityMap } from '../../utils/entity-utils';
import Conversation, { ConversationDelegate } from "../conversation";
import { ServerProtocolMessage, ClientProtocolMessage, Message } from ".";
export interface SubprotocolImplementation {
    destroy(): void;
    handle(msg: any): Promise<void>;
}
/**
 * A single connection from a conversation API client.
 *
 * This class implements the websocket-based protocol used by the server
 * and cloud platforms. It extends the conversation protocol with options
 * related to synchronizing devices, controlling audio, accessing the
 * user's location, and more.
 */
export default class ConversationWebSocketConnection implements ConversationDelegate {
    readonly send: (msg: ServerProtocolMessage) => Promise<void>;
    private _syncDevices;
    private _replayHistory;
    private _pingListener;
    private _deviceAddedListener;
    private _conversation;
    private _engine;
    private _subprotocols;
    constructor(conversation: Conversation, sendCallback: (msg: ServerProtocolMessage) => Promise<void>, options?: {
        replayHistory?: boolean;
        syncDevices?: boolean;
    });
    get conversationId(): string;
    get engine(): AssistantEngine;
    start(): Promise<void>;
    destroy(): void;
    private _requestSubprotocol;
    private _dispatchSubprotocol;
    handle(msg: ClientProtocolMessage): Promise<void>;
    setHypothesis(hypothesis: string): Promise<void>;
    setExpected(what: string | null, context: {
        code: string[];
        entities: EntityMap;
    }): Promise<void>;
    addMessage(msg: Message): Promise<void>;
    private _sendNewDevice;
}
