"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
//         Kevin Tang
//         Giovanni Campagna <gcampagn@cs.stanford.edu>
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
class DialogueTurnLog {
    constructor(conversationDB, conversationId, dialogueId, previousId) {
        this._conversationDB = conversationDB;
        this._turn = {
            context: null,
            agent: null,
            agent_target: null,
            intermediate_context: null,
            user: '',
            user_target: ''
        };
        this._conversationId = conversationId;
        this._dialogueId = dialogueId;
        this._uniqueId = (0, uuid_1.v4)();
        this._previousId = previousId;
        this._anyData = false;
    }
    get uniqueId() {
        return this._uniqueId;
    }
    async save() {
        var _a, _b;
        // a fully empty turn occurs at the end of the dialogue if the user says
        // $stop, because we terminate the turn after the user speech, then the
        // agent speaks exactly nothing, and then we terminate the whole dialogue
        // we don't want to save the empty turn in that case
        if (!this._anyData)
            return;
        const agentTimestamp = this._turn.agent_timestamp ?
            this._turn.agent_timestamp.toISOString() :
            null;
        const userTimestamp = this._turn.user_timestamp ?
            this._turn.user_timestamp.toISOString() :
            null;
        const vote = (_a = this._turn.vote) !== null && _a !== void 0 ? _a : null;
        const comment = (_b = this._turn.comment) !== null && _b !== void 0 ? _b : null;
        const row = {
            conversationId: this._conversationId,
            previousId: this._previousId,
            dialogueId: this._dialogueId,
            context: this._turn.context,
            agent: this._turn.agent,
            agentTimestamp: agentTimestamp,
            agentTarget: this._turn.agent_target,
            intermediateContext: this._turn.intermediate_context,
            user: this._turn.user,
            userTimestamp: userTimestamp,
            userTarget: this._turn.user_target,
            vote: vote,
            comment: comment
        };
        await this._conversationDB.insertOne(this._uniqueId, row);
    }
    update(field, value) {
        this._turn[field] = this._turn[field] ? this._turn[field] + '\n' + value : value;
        if (field === 'user')
            this._turn.user_timestamp = new Date;
        else if (field === 'agent')
            this._turn.agent_timestamp = new Date;
        this._anyData = true;
    }
}
function* reorderTurns(rows) {
    var _a, _b;
    const turns = new Map();
    for (const row of rows) {
        turns.set(row.uniqueId, {
            turn: {
                context: row.context,
                agent: row.agent,
                agent_target: row.agentTarget,
                agent_timestamp: row.agentTimestamp ? new Date(row.agentTimestamp) : undefined,
                intermediate_context: row.intermediateContext,
                user: row.user,
                user_target: row.userTarget,
                user_timestamp: row.userTimestamp ? new Date(row.userTimestamp) : undefined,
                vote: (_a = row.vote) !== null && _a !== void 0 ? _a : undefined,
                comment: (_b = row.comment) !== null && _b !== void 0 ? _b : undefined
            },
            next: null
        });
    }
    let first = null;
    for (const row of rows) {
        if (row.previousId === null)
            first = turns.get(row.uniqueId);
        else
            turns.get(row.previousId).next = turns.get(row.uniqueId);
    }
    let turn = first;
    while (turn !== null) {
        yield turn.turn;
        turn = turn.next;
    }
}
function reconstructDialogues(rows) {
    if (rows.length === 0)
        return [];
    const conversationId = rows[0].conversationId;
    const dialogues = new Map();
    for (const row of rows) {
        const existing = dialogues.get(row.dialogueId);
        if (existing)
            existing.push(row);
        else
            dialogues.set(row.dialogueId, [row]);
    }
    const sorted = [];
    for (const [dialogueId, rows] of dialogues) {
        const turns = Array.from(reorderTurns(rows));
        sorted.push({
            id: conversationId + '/' + dialogueId,
            timestamp: turns[0].user_timestamp || turns[0].agent_timestamp,
            turns: turns,
        });
    }
    sorted.sort((one, two) => one.timestamp.getTime() - two.timestamp.getTime());
    return sorted;
}
class ConversationLogger {
    constructor(conversationDB, conversationId) {
        this._conversationDB = conversationDB;
        this._conversationId = conversationId;
        this._dialogueUniqueId = (0, uuid_1.v4)();
        this._currentTurn = new DialogueTurnLog(this._conversationDB, this._conversationId, this._dialogueUniqueId, null);
        this._lastTurn = this._currentTurn;
    }
    async dialogueFinished() {
        await this._currentTurn.save();
        this._dialogueUniqueId = (0, uuid_1.v4)();
        this._currentTurn = new DialogueTurnLog(this._conversationDB, this._conversationId, this._dialogueUniqueId, null);
        // do not update lastTurn here, it should continue to point to the previous turn so we can update the votes
        // for the agent speech right at the end of the dialogue
    }
    async turnFinished() {
        await this._currentTurn.save();
        const previousId = this._currentTurn.uniqueId;
        this._currentTurn = new DialogueTurnLog(this._conversationDB, this._conversationId, this._dialogueUniqueId, previousId);
        this._lastTurn = this._currentTurn;
    }
    async voteLast(vote) {
        this._lastTurn.update('vote', vote);
        await this._lastTurn.save();
    }
    async commentLast(comment) {
        this._lastTurn.update('comment', comment);
        await this._lastTurn.save();
    }
    updateLog(field, value) {
        this._currentTurn.update(field, value);
    }
    async *read() {
        const rows = await this._conversationDB.getBy('conversationId', this._conversationId);
        yield* reconstructDialogues(rows);
    }
}
exports.default = ConversationLogger;
//# sourceMappingURL=logging.js.map