export declare class NodeVisitor {
    visitImport(stmt: Import): void;
    visitContextStmt(stmt: ContextStmt): void;
    visitNonTerminalStmt(stmt: NonTerminalStmt): void;
    visitKeyFunctionDeclaration(stmt: KeyFunctionDeclarationStmt): void;
    visitOldStyleExpansionRule(stmt: OldStyleExpansion): void;
    visitNewStyleExpansionRule(stmt: NewStyleExpansion): void;
    visitConstantsRule(stmt: Constants): void;
    visitConditionRule(stmt: Condition): void;
    visitNonTerminalRuleHead(node: RuleHeadPart): void;
}
export declare class Grammar {
    comment: string;
    statements: Statement[];
    constructor(comment: string, statements: Statement[]);
    visit(visitor: NodeVisitor): void;
    codegen(filename: string): string;
}
export declare abstract class Statement {
    static CodeBlock: typeof CodeBlock;
    static JSImportStmt: typeof JSImportStmt;
    static NonTerminal: typeof NonTerminalStmt;
    static Context: typeof ContextStmt;
    static ForLoop: typeof ForLoop;
    static If: typeof IfStmt;
    static Import: typeof Import;
    static KeyFunctionDeclaration: typeof KeyFunctionDeclarationStmt;
    abstract codegen(prefix?: string): string;
    abstract visit(visitor: NodeVisitor): void;
}
export declare class CodeBlock extends Statement {
    code: string;
    constructor(code: string);
    codegen(): string;
    visit(visitor: NodeVisitor): void;
}
export declare class JSImportStmt extends Statement {
    code: string;
    constructor(code: string);
    codegen(): string;
    visit(visitor: NodeVisitor): void;
}
export declare class KeyFunctionDeclarationStmt extends Statement {
    decls: Array<[string, string]>;
    constructor(decls: Array<[string, string]>);
    codegen(): string;
    visit(visitor: NodeVisitor): void;
}
export declare class NonTerminalStmt extends Statement {
    name: string;
    type: string | undefined;
    rules: Rule[];
    doc: string;
    keyfn: string;
    constructor(name: string, type: string | undefined, rules: Rule[], doc: string);
    visit(visitor: NodeVisitor): void;
    codegen(prefix?: string): string;
}
export declare class ContextStmt extends Statement {
    names: string[];
    type: string | undefined;
    constructor(names: string[], type: string | undefined);
    visit(visitor: NodeVisitor): void;
    codegen(prefix?: string): string;
}
export declare class ForLoop extends Statement {
    head: string;
    statements: Statement[];
    constructor(head: string, statements: Statement[]);
    visit(visitor: NodeVisitor): void;
    codegen(prefix?: string): string;
}
export declare class IfStmt extends Statement {
    cond: string;
    iftrue: Statement[];
    iffalse: Statement[];
    constructor(cond: string, iftrue: Statement[], iffalse: Statement[]);
    visit(visitor: NodeVisitor): void;
    codegen(prefix?: string): string;
}
export declare class Import extends Statement {
    what: string;
    name: string;
    names: string[];
    constructor(what: string);
    visit(visitor: NodeVisitor): void;
    codegen(prefix?: string): string;
}
interface RuleAttribute {
    name: string;
    code: string;
}
export declare class RuleAttributes {
    attributes: RuleAttribute[];
    constructor(attributes?: RuleAttribute[]);
    codegen(): string;
}
export declare abstract class Rule {
    static Constants: typeof Constants;
    static Condition: typeof Condition;
    static OldStyleExpansion: typeof OldStyleExpansion;
    static NewStyleExpansion: typeof NewStyleExpansion;
    abstract codegen(nonTerminal: string, prefix: string, type: string, keyfn: string): string;
    abstract visit(visitor: NodeVisitor): void;
}
export declare class Constants extends Rule {
    token: string;
    typeCode: string;
    attrs: RuleAttributes;
    constructor(token: string, typeCode: string, attrs: RuleAttributes);
    visit(visitor: NodeVisitor): void;
    codegen(nonTerminal: string, prefix: string | undefined, type: string, keyfn: string): string;
}
export declare class OldStyleExpansion extends Rule {
    head: RuleHeadPart[];
    bodyCode: string;
    attrs: RuleAttributes;
    constructor(head: RuleHeadPart[], bodyCode: string, attrs: RuleAttributes);
    visit(visitor: NodeVisitor): void;
    codegen(nonTerminal: string, prefix: string | undefined, type: string, keyfn: string): string;
}
export declare class NewStyleExpansion extends Rule {
    nonTerminals: NonTerminalRuleHead[];
    sentenceTemplate: string;
    bodyCode: string;
    attrs: RuleAttributes;
    constructor(nonTerminals: NonTerminalRuleHead[], sentenceTemplate: string, bodyCode: string, attrs: RuleAttributes);
    visit(visitor: NodeVisitor): void;
    codegen(nonTerminal: string, prefix: string | undefined, type: string, keyfn: string): string;
}
export declare class Condition extends Rule {
    flag: string;
    rules: Rule[];
    constructor(flag: string, rules: Rule[]);
    visit(visitor: NodeVisitor): void;
    codegen(nonTerminal: string, prefix: string, type: string, keyfn: string): string;
}
export declare abstract class NonTerminalConstraint {
    static Constant: typeof ConstantNonTerminalConstraint;
    static Equality: typeof EqualityNonTerminalConstraint;
    abstract codegen(allNonTerminals: NonTerminalRuleHead[], ourKeyFn: string, ourIndex: number): string;
}
export declare class EqualityNonTerminalConstraint extends NonTerminalConstraint {
    ourIndexName: string;
    nonTermRef: string;
    theirIndexName: string;
    constructor(ourIndexName: string, nonTermRef: string, theirIndexName: string);
    codegen(allNonTerminals: NonTerminalRuleHead[], ourKeyFn: string, ourIndex: number): string;
}
export declare class ConstantNonTerminalConstraint extends NonTerminalConstraint {
    indexName: string;
    valueCode: string;
    constructor(indexName: string, valueCode: string);
    codegen(allNonTerminals: NonTerminalRuleHead[], ourKeyFn: string): string;
}
export declare abstract class RuleHeadPart {
    static NonTerminal: typeof NonTerminalRuleHead;
    static StringLiteral: typeof StringLiteralRuleHead;
    static ComputedStringLiteral: typeof ComputedStringLiteralRuleHead;
    static Choice: typeof ChoiceRuleHead;
    abstract visit(visitor: NodeVisitor): void;
    abstract getTemplate(): string;
}
export declare class NonTerminalRuleHead extends RuleHeadPart {
    name: string | null;
    symbol: string;
    constraint: NonTerminalConstraint | null;
    type: string;
    keyfn: string;
    constructor(name: string | null, symbol: string, constraint: NonTerminalConstraint | null);
    toString(): string;
    visit(visitor: NodeVisitor): void;
    getTemplate(): string;
    codegen(allNonTerminals: NonTerminalRuleHead[], index: number): string;
}
export declare class StringLiteralRuleHead extends RuleHeadPart {
    value: string;
    constructor(value: string);
    visit(visitor: NodeVisitor): void;
    getTemplate(): string;
}
export declare class ComputedStringLiteralRuleHead extends RuleHeadPart {
    code: string;
    constructor(code: string);
    getTemplate(): string;
    visit(visitor: NodeVisitor): void;
}
export declare class ChoiceRuleHead extends RuleHeadPart {
    values: string[];
    constructor(values: string[]);
    getTemplate(): string;
    visit(visitor: NodeVisitor): void;
}
export {};
