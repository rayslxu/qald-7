"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoiceRuleHead = exports.ComputedStringLiteralRuleHead = exports.StringLiteralRuleHead = exports.NonTerminalRuleHead = exports.RuleHeadPart = exports.ConstantNonTerminalConstraint = exports.EqualityNonTerminalConstraint = exports.NonTerminalConstraint = exports.Condition = exports.NewStyleExpansion = exports.OldStyleExpansion = exports.Constants = exports.Rule = exports.RuleAttributes = exports.Import = exports.IfStmt = exports.ForLoop = exports.ContextStmt = exports.NonTerminalStmt = exports.KeyFunctionDeclarationStmt = exports.JSImportStmt = exports.CodeBlock = exports.Statement = exports.Grammar = exports.NodeVisitor = void 0;
const path = __importStar(require("path"));
const assert_1 = __importDefault(require("assert"));
const escaping_1 = require("../../utils/escaping");
const TemplateGrammar = __importStar(require("../../utils/template-string/grammar"));
const I18n = __importStar(require("../../i18n"));
class NodeVisitor {
    visitImport(stmt) { }
    visitContextStmt(stmt) { }
    visitNonTerminalStmt(stmt) { }
    visitKeyFunctionDeclaration(stmt) { }
    visitOldStyleExpansionRule(stmt) { }
    visitNewStyleExpansionRule(stmt) { }
    visitConstantsRule(stmt) { }
    visitConditionRule(stmt) { }
    visitNonTerminalRuleHead(node) { }
}
exports.NodeVisitor = NodeVisitor;
class Grammar {
    constructor(comment, statements) {
        this.comment = comment;
        this.statements = statements;
    }
    visit(visitor) {
        for (const stmt of this.statements)
            stmt.visit(visitor);
    }
    codegen(filename) {
        let buffer = '';
        buffer += (this.comment);
        let runtimepath = path.relative(path.dirname(filename), require.resolve('../runtime'));
        if (runtimepath.endsWith('.ts'))
            runtimepath = runtimepath.substring(0, runtimepath.length - 3);
        let generatorpath = path.relative(path.dirname(filename), require.resolve('../generator'));
        if (generatorpath.endsWith('.ts'))
            generatorpath = generatorpath.substring(0, generatorpath.length - 3);
        let typespath = path.relative(path.dirname(filename), require.resolve('../types'));
        if (typespath.endsWith('.ts'))
            typespath = typespath.substring(0, typespath.length - 3);
        let i18npath = path.relative(path.dirname(filename), require.resolve('../../i18n'));
        if (i18npath.endsWith('.ts'))
            i18npath = i18npath.substring(0, i18npath.length - 3);
        buffer += `import * as $runtime from ${(0, escaping_1.stringEscape)(runtimepath)};\n`;
        buffer += `import type $SentenceGenerator from ${(0, escaping_1.stringEscape)(generatorpath)};\n`;
        buffer += `import * as $SentenceGeneratorTypes from ${(0, escaping_1.stringEscape)(typespath)};\n`;
        buffer += `import * as $I18n from ${(0, escaping_1.stringEscape)(i18npath)};\n`;
        const declaredNames = new Set();
        for (const stmt of this.statements) {
            if (stmt instanceof JSImportStmt) {
                buffer += stmt.codegen();
            }
            else if (stmt instanceof Import) {
                const names = stmt.names.filter((n) => !declaredNames.has(n));
                buffer += `import { $load as $load_${stmt.name},${names.join(', ')} } from ${(0, escaping_1.stringEscape)(stmt.what + '.out')};\n`;
                buffer += `export { ${names.join(', ')} };\n`;
                for (const name of names)
                    declaredNames.add(name);
            }
            else if (stmt instanceof NonTerminalStmt) {
                if (declaredNames.has(stmt.name))
                    continue;
                if (stmt.doc) {
                    buffer += stmt.doc;
                    buffer += '\n';
                }
                buffer += `export const ${stmt.name} : $SentenceGeneratorTypes.NonTerminal<${stmt.type}> = ${(0, escaping_1.stringEscape)(stmt.name)};\n`;
                declaredNames.add(stmt.name);
            }
        }
        buffer += `/**\n`;
        buffer += ` * Load the templates in this file.\n`;
        buffer += ` *\n`;
        buffer += ` * This is an autogenerated method that will be called by the {@link SentenceGenerator}\n`;
        buffer += ` * when the templates are imported.\n`;
        buffer += ` */\n`;
        buffer += `export async function $load($options : $SentenceGeneratorTypes.GrammarOptions, $locale : $I18n.LanguagePack, $grammar : $SentenceGenerator, $loader : ThingpediaLoader) : Promise<void> {\n`;
        for (const stmt of this.statements) {
            if (stmt instanceof JSImportStmt)
                continue;
            buffer += stmt.codegen('   ');
        }
        buffer += '};\n';
        return buffer;
    }
}
exports.Grammar = Grammar;
class Statement {
}
exports.Statement = Statement;
class CodeBlock extends Statement {
    constructor(code) {
        super();
        this.code = code;
    }
    codegen() {
        return this.code;
    }
    visit(visitor) { }
}
exports.CodeBlock = CodeBlock;
Statement.CodeBlock = CodeBlock;
class JSImportStmt extends Statement {
    constructor(code) {
        super();
        this.code = code;
    }
    codegen() {
        return `import ${this.code};\n`;
    }
    visit(visitor) { }
}
exports.JSImportStmt = JSImportStmt;
Statement.JSImportStmt = JSImportStmt;
class KeyFunctionDeclarationStmt extends Statement {
    constructor(decls) {
        super();
        this.decls = decls;
    }
    codegen() {
        return ''; // this is a type declaration processed by the compiler,
        // it generates no code
    }
    visit(visitor) {
        visitor.visitKeyFunctionDeclaration(this);
    }
}
exports.KeyFunctionDeclarationStmt = KeyFunctionDeclarationStmt;
Statement.KeyFunctionDeclaration = KeyFunctionDeclarationStmt;
class NonTerminalStmt extends Statement {
    constructor(name, type, rules, doc) {
        super();
        this.name = name;
        this.type = type;
        this.rules = rules;
        this.doc = doc;
        this.keyfn = 'undefined';
    }
    visit(visitor) {
        visitor.visitNonTerminalStmt(this);
        for (const rule of this.rules)
            rule.visit(visitor);
    }
    codegen(prefix = '') {
        let buffer = '';
        buffer += (`${prefix}$grammar.declareSymbol(${(0, escaping_1.stringEscape)(this.name)});\n`);
        for (const rule of this.rules)
            buffer += rule.codegen(this.name, prefix, this.type || 'any', this.keyfn);
        return buffer;
    }
}
exports.NonTerminalStmt = NonTerminalStmt;
Statement.NonTerminal = NonTerminalStmt;
class ContextStmt extends Statement {
    constructor(names, type) {
        super();
        this.names = names;
        this.type = type;
    }
    visit(visitor) {
        visitor.visitContextStmt(this);
    }
    codegen(prefix = '') {
        return this.names.map((name) => `${prefix}$grammar.declareContext(${(0, escaping_1.stringEscape)(name)});\n`).join('');
    }
}
exports.ContextStmt = ContextStmt;
Statement.Context = ContextStmt;
class ForLoop extends Statement {
    constructor(head, statements) {
        super();
        this.head = head;
        this.statements = statements;
    }
    visit(visitor) {
        for (const stmt of this.statements)
            stmt.visit(visitor);
    }
    codegen(prefix = '') {
        let buffer = '';
        buffer += (`${prefix}for (${this.head}) {\n`);
        for (const stmt of this.statements)
            buffer += stmt.codegen(prefix + '    ');
        buffer += (`${prefix}}\n`);
        return buffer;
    }
}
exports.ForLoop = ForLoop;
Statement.ForLoop = ForLoop;
class IfStmt extends Statement {
    constructor(cond, iftrue, iffalse) {
        super();
        this.cond = cond;
        this.iftrue = iftrue;
        this.iffalse = iffalse;
    }
    visit(visitor) {
        for (const stmt of this.iftrue)
            stmt.visit(visitor);
        for (const stmt of this.iffalse)
            stmt.visit(visitor);
    }
    codegen(prefix = '') {
        let buffer = '';
        buffer += (`${prefix}if (${this.cond}) {\n`);
        for (const stmt of this.iftrue)
            buffer += stmt.codegen(prefix + '    ');
        if (this.iffalse.length > 0) {
            buffer += (`${prefix}} else {\n`);
            for (const stmt of this.iffalse)
                buffer += stmt.codegen(prefix + '    ');
        }
        buffer += (`${prefix}}\n`);
        return buffer;
    }
}
exports.IfStmt = IfStmt;
Statement.If = IfStmt;
class Import extends Statement {
    constructor(what) {
        super();
        this.what = what;
        this.names = [];
        this.name = what.replace('.genie', '').replace(/[^a-zA-Z0-9_]/g, '_');
    }
    visit(visitor) {
        visitor.visitImport(this);
    }
    codegen(prefix = '') {
        return `${prefix}await $load_${this.name}($options, $locale, $grammar, $loader);\n`;
    }
}
exports.Import = Import;
Statement.Import = Import;
class RuleAttributes {
    constructor(attributes = []) {
        this.attributes = attributes;
    }
    codegen() {
        let buf = '{ ';
        buf += this.attributes.map((attr) => `${attr.name}: (${attr.code})`).join(', ');
        buf += ' }';
        return buf;
    }
}
exports.RuleAttributes = RuleAttributes;
class Rule {
}
exports.Rule = Rule;
class Constants extends Rule {
    constructor(token, typeCode, attrs) {
        super();
        this.token = token;
        this.typeCode = typeCode;
        this.attrs = attrs;
    }
    visit(visitor) {
        visitor.visitConstantsRule(this);
    }
    codegen(nonTerminal, prefix = '', type, keyfn) {
        return `${prefix}$grammar.addConstants(${(0, escaping_1.stringEscape)(nonTerminal)}, ${(0, escaping_1.stringEscape)(this.token)}, ${this.typeCode}, ${keyfn}, ${this.attrs.codegen()});\n`;
    }
}
exports.Constants = Constants;
Rule.Constants = Constants;
function makeBodyLambda(head, body, type = 'any') {
    const bodyArgs = [];
    let i = 0;
    for (const headPart of head) {
        if (headPart instanceof NonTerminalRuleHead && headPart.name)
            bodyArgs.push(headPart.name + ' : ' + headPart.type);
        else
            bodyArgs.push(`$${i++}` + ' : ' + headPart.type);
    }
    return `(${bodyArgs.join(', ')}) : (${type})|null => ${body}`;
}
class OldStyleExpansion extends Rule {
    constructor(head, bodyCode, attrs) {
        super();
        this.head = head;
        this.bodyCode = bodyCode;
        this.attrs = attrs;
        (0, assert_1.default)(Array.isArray(head));
    }
    visit(visitor) {
        visitor.visitOldStyleExpansionRule(this);
        for (const head of this.head)
            head.visit(visitor);
    }
    codegen(nonTerminal, prefix = '', type, keyfn) {
        const nonTerminalChildren = this.head.filter((h) => h instanceof NonTerminalRuleHead);
        const expanderCode = makeBodyLambda(nonTerminalChildren, this.bodyCode, type);
        let template = '"' + this.head.map((h) => h.getTemplate()).join(' ') + '"';
        // generate code to lookup the translation of the template if meaningful
        // (skip if this template has only one component and that component is a non-terminal)
        if ((this.head.length > 1 || this.head.length > nonTerminalChildren.length) && template !== '""')
            template = `$locale._(${template})`;
        return `${prefix}$grammar.addRule(${(0, escaping_1.stringEscape)(nonTerminal)}, [${nonTerminalChildren.map((h, i) => h.codegen(nonTerminalChildren, i)).join(', ')}], ${template}, (${expanderCode}), ${keyfn}, ${this.attrs.codegen()});\n`;
    }
}
exports.OldStyleExpansion = OldStyleExpansion;
Rule.OldStyleExpansion = OldStyleExpansion;
class NewStyleExpansion extends Rule {
    constructor(nonTerminals, sentenceTemplate, bodyCode, attrs) {
        super();
        this.nonTerminals = nonTerminals;
        this.sentenceTemplate = sentenceTemplate;
        this.bodyCode = bodyCode;
        this.attrs = attrs;
    }
    visit(visitor) {
        visitor.visitNewStyleExpansionRule(this);
        for (const nt of this.nonTerminals)
            nt.visit(visitor);
    }
    codegen(nonTerminal, prefix = '', type, keyfn) {
        const expanderCode = makeBodyLambda(this.nonTerminals, this.bodyCode, type);
        // try parsing the template and preprocessing, so we catch errors eagerly
        try {
            TemplateGrammar.parse(this.sentenceTemplate).preprocess(I18n.get('en-US'), this.nonTerminals.map((e) => { var _a; return (_a = e.name) !== null && _a !== void 0 ? _a : e.symbol; }));
        }
        catch (e) {
            throw new Error(`Failed to parse template string for ${nonTerminal} = ${this.sentenceTemplate} (${this.nonTerminals.join(', ')}): ${e.message}`);
        }
        let gettext;
        if (this.sentenceTemplate)
            gettext = `$locale._(${(0, escaping_1.stringEscape)(this.sentenceTemplate)})`;
        else
            gettext = "''";
        return `${prefix}$grammar.addRule(${(0, escaping_1.stringEscape)(nonTerminal)}, [${this.nonTerminals.map((h, i) => h.codegen(this.nonTerminals, i)).join(', ')}], ${gettext}, (${expanderCode}), ${keyfn}, ${this.attrs.codegen()});\n`;
    }
}
exports.NewStyleExpansion = NewStyleExpansion;
Rule.NewStyleExpansion = NewStyleExpansion;
class Condition extends Rule {
    constructor(flag, rules) {
        super();
        this.flag = flag;
        this.rules = rules;
    }
    visit(visitor) {
        visitor.visitConditionRule(this);
        for (const rule of this.rules)
            rule.visit(visitor);
    }
    codegen(nonTerminal, prefix, type, keyfn) {
        const flag = this.flag.startsWith('?') ?
            `$options.flags.${this.flag.substring(1)}` :
            `!$options.flags.${this.flag.substring(1)}`;
        let buffer = '';
        buffer += (`${prefix}if (${flag}) {\n`);
        for (const rule of this.rules)
            buffer += rule.codegen(nonTerminal, prefix + '    ', type, keyfn);
        buffer += (`${prefix}}\n`);
        return buffer;
    }
}
exports.Condition = Condition;
Rule.Condition = Condition;
class NonTerminalConstraint {
}
exports.NonTerminalConstraint = NonTerminalConstraint;
class EqualityNonTerminalConstraint extends NonTerminalConstraint {
    constructor(ourIndexName, nonTermRef, theirIndexName) {
        super();
        this.ourIndexName = ourIndexName;
        this.nonTermRef = nonTermRef;
        this.theirIndexName = theirIndexName;
    }
    codegen(allNonTerminals, ourKeyFn, ourIndex) {
        if (ourKeyFn === 'undefined')
            console.error(`WARNING: key function is not set in constraint {${this.ourIndexName} = ${this.nonTermRef}.${this.theirIndexName}}, cannot check correctness statically`);
        const ourTypeConstraint = ourKeyFn === 'undefined' ? '' :
            ` as (${(0, escaping_1.stringEscape)(this.ourIndexName)} extends keyof ReturnType<typeof ${ourKeyFn}> ? string : void)`;
        let nonTermIndex, theirKeyFn;
        if (/^[0-9]+/.test(this.nonTermRef)) {
            nonTermIndex = parseInt(this.nonTermRef, 10);
            (0, assert_1.default)(allNonTerminals[nonTermIndex]);
            theirKeyFn = allNonTerminals[nonTermIndex];
        }
        else {
            for (let i = 0; i < allNonTerminals.length; i++) {
                const part = allNonTerminals[i];
                if (part.name === this.nonTermRef) {
                    nonTermIndex = i;
                    theirKeyFn = part.keyfn;
                    break;
                }
            }
            if (nonTermIndex === undefined)
                throw new Error(`Invalid non-terminal backreference to ${this.nonTermRef} for equality constraint of ${allNonTerminals[ourIndex]} (alias not found)`);
            if (nonTermIndex >= ourIndex)
                throw new Error(`Invalid non-terminal backreference to ${this.nonTermRef} for equality constraint of ${allNonTerminals[ourIndex]} (alias must precede usage)`);
        }
        if (theirKeyFn === 'undefined')
            console.error(`WARNING: key function is not set in constraint {${this.ourIndexName} = ${this.nonTermRef}.${this.theirIndexName}}, cannot check correctness statically`);
        const theirTypeConstraint = theirKeyFn === 'undefined' ? '' :
            ` as (${(0, escaping_1.stringEscape)(this.theirIndexName)} extends keyof ReturnType<typeof ${theirKeyFn}> ? string : void)`;
        return `[${(0, escaping_1.stringEscape)(this.ourIndexName)}${ourTypeConstraint}, ${nonTermIndex}, ${(0, escaping_1.stringEscape)(this.theirIndexName)}${theirTypeConstraint}]`;
    }
}
exports.EqualityNonTerminalConstraint = EqualityNonTerminalConstraint;
NonTerminalConstraint.Equality = EqualityNonTerminalConstraint;
class ConstantNonTerminalConstraint extends NonTerminalConstraint {
    constructor(indexName, valueCode) {
        super();
        this.indexName = indexName;
        this.valueCode = valueCode;
    }
    codegen(allNonTerminals, ourKeyFn) {
        if (ourKeyFn === 'undefined')
            console.error(`WARNING: key function is not set in constraint {${this.indexName} = ${this.valueCode}}, cannot check correctness statically`);
        const ourTypeConstraint = ourKeyFn === 'undefined' ? '' :
            ` as (${(0, escaping_1.stringEscape)(this.indexName)} extends keyof ReturnType<typeof ${ourKeyFn}> ? string : void)`;
        const constantTypeConstraint = ourKeyFn === 'undefined' ? '' :
            ` as ReturnType<typeof ${ourKeyFn}>[${(0, escaping_1.stringEscape)(this.indexName)}]`;
        return `[${(0, escaping_1.stringEscape)(this.indexName)}${ourTypeConstraint}, (${this.valueCode})${constantTypeConstraint}]`;
    }
}
exports.ConstantNonTerminalConstraint = ConstantNonTerminalConstraint;
NonTerminalConstraint.Constant = ConstantNonTerminalConstraint;
class RuleHeadPart {
}
exports.RuleHeadPart = RuleHeadPart;
class NonTerminalRuleHead extends RuleHeadPart {
    constructor(name, symbol, constraint) {
        super();
        this.name = name;
        this.symbol = symbol;
        this.constraint = constraint;
        this.type = 'any';
        this.keyfn = 'undefined';
    }
    toString() {
        return `${this.name} : NT[${this.symbol}]`;
    }
    visit(visitor) {
        visitor.visitNonTerminalRuleHead(this);
    }
    getTemplate() {
        var _a;
        return `\${${(_a = this.name) !== null && _a !== void 0 ? _a : this.symbol}}`;
    }
    codegen(allNonTerminals, index) {
        return `new $runtime.NonTerminal(${(0, escaping_1.stringEscape)(this.symbol)}, ${this.name !== null ? (0, escaping_1.stringEscape)(this.name) : 'undefined'}, ${this.constraint ? this.constraint.codegen(allNonTerminals, this.keyfn, index) : 'undefined'})`;
    }
}
exports.NonTerminalRuleHead = NonTerminalRuleHead;
RuleHeadPart.NonTerminal = NonTerminalRuleHead;
function templateEscape(str) {
    return str.replace(/[${}|[\]\\]/g, '\\$0');
}
class StringLiteralRuleHead extends RuleHeadPart {
    constructor(value) {
        super();
        this.value = value;
    }
    visit(visitor) { }
    getTemplate() {
        // note the double escaping here:
        // getTemplate() will escape any special character that have meaning to the template
        // language (so $, {, }, |, etc.)
        // but we also escape any special character that have meaning in JS, so the resulting
        // string can be output as a double-quoted JS string
        return templateEscape(this.value).replace(/(["\\])/g, '\\$1').replace(/\n/g, '\\n');
    }
}
exports.StringLiteralRuleHead = StringLiteralRuleHead;
RuleHeadPart.StringLiteral = StringLiteralRuleHead;
class ComputedStringLiteralRuleHead extends RuleHeadPart {
    constructor(code) {
        super();
        this.code = code;
    }
    getTemplate() {
        // hack: we need to close the template string, add some piece dynamically, and then reopen it
        return `" + (${this.code}) + "`;
    }
    visit(visitor) { }
}
exports.ComputedStringLiteralRuleHead = ComputedStringLiteralRuleHead;
RuleHeadPart.ComputedStringLiteral = ComputedStringLiteralRuleHead;
class ChoiceRuleHead extends RuleHeadPart {
    constructor(values) {
        super();
        this.values = values;
    }
    getTemplate() {
        return '{' + this.values.map((v) => templateEscape(v).replace(/(["\\])/g, '\\$1').replace(/\n/g, '\\n')).join('|') + '}';
    }
    visit(visitor) { }
}
exports.ChoiceRuleHead = ChoiceRuleHead;
RuleHeadPart.Choice = ChoiceRuleHead;
//# sourceMappingURL=meta_ast.js.map