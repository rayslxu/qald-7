import { Phrase, Concatenation, Placeholder, ValueSelect, FlagSelect, Plural, Replaceable, PlaceholderReplacement, ReplacedResult, ReplacedConcatenation, ReplacedChoice, ReplacedList } from '../utils/template-string';
export { Phrase, Concatenation, Placeholder, ValueSelect, FlagSelect, Plural, PlaceholderReplacement, Replaceable, ReplacedResult, ReplacedConcatenation, ReplacedChoice, ReplacedList, };
import { DerivationKeyValue, DerivationKey, SemanticAction, KeyFunction } from './types';
declare const LogLevel: {
    NONE: number;
    INFO: number;
    GENERATION: number;
    VERBOSE_GENERATION: number;
    DUMP_TEMPLATES: number;
    DUMP_DERIVED: number;
    EVERYTHING: number;
};
/**
 * A reference to a context.
 *
 * A context is an object that is passed as extra input to a semantic function
 * to affect its behavior. Grammar rules are only applied between identical (===) contexts.
 *
 * The "context" in this definition roughly corresponds to a dialogue context
 * (either a C: state, or a more general notion) but it need not be.
 *
 * "value" is a value associated with the context that is only meaningful to the API caller
 * (DialogueGenerator).
 */
declare class Context {
    value: unknown;
    private static _nextId;
    private _id;
    constructor(value: unknown);
    toString(): string;
    hash(): number;
    equals(other: Context): boolean;
    static compatible(c1: Context | null, c2: Context | null): boolean;
    static meet(c1: Context | null, c2: Context | null): Context | null;
}
export declare type DerivationChildTuple<ArgTypes extends unknown[]> = {
    [K in keyof ArgTypes]: Derivation<ArgTypes[K]>;
};
/**
 * A Derivation represents a sentence fragment and an intermediate value
 * that were computed at some point during the generation process.
 */
declare class Derivation<ValueType> {
    readonly key: DerivationKey;
    readonly value: ValueType;
    readonly context: Context | null;
    sentence: ReplacedResult;
    priority: number;
    depth: number;
    constructor(key: DerivationKey, value: ValueType, sentence: ReplacedResult, context: Context | null | undefined, depth: number, priority: number);
    chooseBestSentence(): string;
    sampleSentence(rng: () => number): string;
    clone(): Derivation<ValueType>;
    static combine<ArgTypes extends unknown[], ResultType>(children: DerivationChildTuple<ArgTypes>, template: Replaceable, semanticAction: SemanticAction<ArgTypes, ResultType>, keyFunction: KeyFunction<ResultType>, atDepth: number, rulePriority: number): Derivation<ResultType> | null;
}
/**
 * Equality of key compared to another non-terminal.
 *
 * The values are [our index name, the 0-based position of the other non-terminal, the other index name].
 */
declare type RelativeKeyConstraint = [string, number, string];
/**
 * Equality of key compared to a constant value.
 *
 * The constraint store [our index name, the comparison value].
 */
declare type ConstantKeyConstraint = [string, DerivationKeyValue];
declare class NonTerminal {
    symbol: string;
    name: string | undefined;
    index: number;
    relativeKeyConstraint: RelativeKeyConstraint | undefined;
    constantKeyConstraint: ConstantKeyConstraint | undefined;
    constructor(symbol: string, name?: string, constraint?: RelativeKeyConstraint | ConstantKeyConstraint);
    toString(): string;
}
export { LogLevel, Derivation, Context, NonTerminal, };
