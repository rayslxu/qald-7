"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonTerminal = exports.Context = exports.Derivation = exports.LogLevel = exports.ReplacedList = exports.ReplacedChoice = exports.ReplacedConcatenation = exports.ReplacedResult = exports.Replaceable = exports.Plural = exports.FlagSelect = exports.ValueSelect = exports.Placeholder = exports.Concatenation = exports.Phrase = void 0;
const assert_1 = __importDefault(require("assert"));
const template_string_1 = require("../utils/template-string");
Object.defineProperty(exports, "Phrase", { enumerable: true, get: function () { return template_string_1.Phrase; } });
Object.defineProperty(exports, "Concatenation", { enumerable: true, get: function () { return template_string_1.Concatenation; } });
Object.defineProperty(exports, "Placeholder", { enumerable: true, get: function () { return template_string_1.Placeholder; } });
Object.defineProperty(exports, "ValueSelect", { enumerable: true, get: function () { return template_string_1.ValueSelect; } });
Object.defineProperty(exports, "FlagSelect", { enumerable: true, get: function () { return template_string_1.FlagSelect; } });
Object.defineProperty(exports, "Plural", { enumerable: true, get: function () { return template_string_1.Plural; } });
Object.defineProperty(exports, "Replaceable", { enumerable: true, get: function () { return template_string_1.Replaceable; } });
Object.defineProperty(exports, "ReplacedResult", { enumerable: true, get: function () { return template_string_1.ReplacedResult; } });
Object.defineProperty(exports, "ReplacedConcatenation", { enumerable: true, get: function () { return template_string_1.ReplacedConcatenation; } });
Object.defineProperty(exports, "ReplacedChoice", { enumerable: true, get: function () { return template_string_1.ReplacedChoice; } });
Object.defineProperty(exports, "ReplacedList", { enumerable: true, get: function () { return template_string_1.ReplacedList; } });
const LogLevel = {
    NONE: 0,
    // log notable events such as particularly slow templates
    INFO: 1,
    // log each non-empty non terminal
    GENERATION: 2,
    // log each non-empty non terminal, and additional verbose information
    VERBOSE_GENERATION: 3,
    // log all templates before generation
    DUMP_TEMPLATES: 4,
    // log information derived from the templates (such as the distance from the root)
    DUMP_DERIVED: 5,
    // log a lot of very redundant information during generation (can cause slowdowns)
    EVERYTHING: 6
};
exports.LogLevel = LogLevel;
/**
 * A reference to a context.
 *
 * A context is an object that is passed as extra input to a semantic function
 * to affect its behavior. Grammar rules are only applied between identical (===) contexts.
 *
 * The "context" in this definition roughly corresponds to a dialogue context
 * (either a C: state, or a more general notion) but it need not be.
 *
 * "value" is a value associated with the context that is only meaningful to the API caller
 * (DialogueGenerator).
 */
class Context {
    constructor(value) {
        this.value = value;
        // NOTE: this assumes that no more than ~4B contexts exists, otherwise
        // this will overflow
        this._id = Context._nextId++;
    }
    toString() {
        return `CTX[${this.value}]`;
    }
    hash() {
        return this._id;
    }
    equals(other) {
        return this === other;
    }
    static compatible(c1, c2) {
        return c1 === null || c2 === null || c1 === c2;
    }
    static meet(c1, c2) {
        if (c1 === null)
            return c2;
        else
            return c1;
    }
}
exports.Context = Context;
Context._nextId = 0;
/**
 * A Derivation represents a sentence fragment and an intermediate value
 * that were computed at some point during the generation process.
 */
class Derivation {
    constructor(key, value, sentence, context = null, depth, priority) {
        this.key = key;
        this.value = value;
        if (value === undefined)
            throw new TypeError('Invalid value');
        this.context = context;
        (0, assert_1.default)(typeof this.context === 'object'); // incl. null
        this.sentence = sentence;
        this.priority = priority;
        this.depth = depth;
        (0, assert_1.default)(Number.isFinite(this.priority));
    }
    chooseBestSentence() {
        return this.sentence.chooseBest();
    }
    sampleSentence(rng) {
        return this.sentence.chooseSample(rng);
    }
    clone() {
        return new Derivation(this.key, this.value, this.sentence, this.context, this.depth, this.priority);
    }
    static combine(children, template, semanticAction, keyFunction, atDepth, rulePriority) {
        const phrases = [];
        const values = [];
        let newContext = null;
        let newPriority = rulePriority;
        for (const child of children) {
            (0, assert_1.default)(Context.compatible(newContext, child.context));
            newContext = Context.meet(newContext, child.context);
            newPriority += child.priority;
            values.push(child.value);
            phrases.push({ text: child.sentence, value: child.key });
        }
        const newValue = semanticAction(...values);
        (0, assert_1.default)(newValue !== undefined);
        if (newValue === null)
            return null;
        const newSentence = template.replace({ replacements: phrases, constraints: {} });
        if (newSentence === null)
            return null;
        const newKey = keyFunction(newValue);
        return new Derivation(newKey, newValue, newSentence, newContext, atDepth, newPriority);
    }
}
exports.Derivation = Derivation;
class NonTerminal {
    constructor(symbol, name, constraint) {
        this.relativeKeyConstraint = undefined;
        this.constantKeyConstraint = undefined;
        this.symbol = symbol;
        this.name = name;
        this.index = -1;
        if (constraint) {
            if (constraint.length === 3)
                this.relativeKeyConstraint = constraint;
            else
                this.constantKeyConstraint = constraint;
        }
    }
    toString() {
        if (this.name !== undefined)
            return `NT[${this.name} : ${this.symbol}]`;
        else
            return `NT[${this.symbol}]`;
    }
}
exports.NonTerminal = NonTerminal;
//# sourceMappingURL=runtime.js.map