"use strict";
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//         Silei Xu <silei@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$load = exports.placeholder = exports.stream_projection_Any = exports.verb_projection_Any = exports.projection_Any = exports.boolean_projection = exports.where_question = exports.pair_projection = exports.the_out_param_triple = exports.the_out_param_pair = exports.the_out_param_Any = exports.action_replace_param_with_stream = exports.action_replace_param_with_table = exports.table_join_replace_placeholder = void 0;
const $runtime = __importStar(require("../sentence-generator/runtime"));
const assert_1 = __importDefault(require("assert"));
const thingtalk_1 = require("thingtalk");
const C = __importStar(require("./ast_manip"));
exports.table_join_replace_placeholder = "table_join_replace_placeholder";
exports.action_replace_param_with_table = "action_replace_param_with_table";
exports.action_replace_param_with_stream = "action_replace_param_with_stream";
exports.the_out_param_Any = "the_out_param_Any";
exports.the_out_param_pair = "the_out_param_pair";
exports.the_out_param_triple = "the_out_param_triple";
exports.pair_projection = "pair_projection";
exports.where_question = "where_question";
exports.boolean_projection = "boolean_projection";
exports.projection_Any = "projection_Any";
exports.verb_projection_Any = "verb_projection_Any";
exports.stream_projection_Any = "stream_projection_Any";
exports.placeholder = "placeholder";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
async function $load($options, $locale, $grammar, $loader) {
    $grammar.declareSymbol("table_join_replace_placeholder");
    $grammar.declareSymbol("action_replace_param_with_table");
    $grammar.declareSymbol("action_replace_param_with_stream");
    $grammar.declareSymbol("the_out_param_Any");
    $grammar.addRule("the_out_param_Any", [new $runtime.NonTerminal("out_param_Any", "p", undefined)], $locale._("the ${p}"), ((p) => p), C.paramKeyFn, {});
    if (!$options.flags.inference) {
        if (!$options.flags.turking) {
            $grammar.addRule("the_out_param_Any", [new $runtime.NonTerminal("out_param_Any", "p", undefined)], $locale._("its ${p}"), ((p) => p), C.paramKeyFn, {});
            $grammar.addRule("the_out_param_Any", [new $runtime.NonTerminal("out_param_Any", "p", undefined)], $locale._("their ${p}"), ((p) => p), C.paramKeyFn, {});
        }
    }
    $grammar.declareSymbol("the_out_param_pair");
    $grammar.addRule("the_out_param_pair", [new $runtime.NonTerminal("out_param_Any", "p1", undefined), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName", 0, "functionName"])], $locale._("the ${p1} and ${p2}"), ((p1, p2) => {
        (0, assert_1.default)(C.isSameFunction(p1.schema, p2.schema));
        if (p1.name === p2.name)
            return null;
        return [p1, p2];
    }), C.paramArrayKeyFn, {});
    $grammar.declareSymbol("the_out_param_triple");
    $grammar.addRule("the_out_param_triple", [new $runtime.NonTerminal("out_param_Any", "p1", undefined), new $runtime.NonTerminal("out_param_Any", "p2", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("out_param_Any", "p3", ["functionName", 0, "functionName"])], $locale._("the ${p1} , ${p2} {,|} and ${p3}"), ((p1, p2, p3) => {
        (0, assert_1.default)(C.isSameFunction(p1.schema, p2.schema));
        (0, assert_1.default)(C.isSameFunction(p1.schema, p3.schema));
        if (p1.name === p2.name || p1.name === p3.name || p2.name === p3.name)
            return null;
        return [p1, p2, p3];
    }), C.paramArrayKeyFn, {});
    $grammar.declareSymbol("pair_projection");
    $grammar.addRule("pair_projection", [new $runtime.NonTerminal("the_out_param_pair", "outParams", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("{both|} ${outParams} of ${table}"), ((outParams, table) => C.makeMultiFieldProjection($loader, 'table', table, outParams)), C.expressionKeyFn, {});
    $grammar.addRule("pair_projection", [new $runtime.NonTerminal("the_out_param_triple", "outParams", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("${outParams} of the ${table}"), ((outParams, table) => C.makeMultiFieldProjection($loader, 'table', table, outParams)), C.expressionKeyFn, {});
    $grammar.declareSymbol("where_question");
    $grammar.addRule("where_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("where is the ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Location, table, 'geo')), C.expressionKeyFn, {});
    $grammar.addRule("where_question", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)])], $locale._("where is the ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Location, table, 'geo')), C.expressionKeyFn, {});
    $grammar.declareSymbol("boolean_projection");
    $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("npp_boolean_projection", "p", ["functionName", 0, "functionName"])], $locale._("does {the||any} ${table} have ${p}"), ((table, p) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Boolean, table, p)), C.expressionKeyFn, {});
    $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("avp_boolean_projection", "p", ["functionName", 0, "functionName"])], $locale._("does {the||any} ${table} ${p}"), ((table, p) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Boolean, table, p)), C.expressionKeyFn, {});
    $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("pvp_boolean_projection", "p", ["functionName", 0, "functionName"])], $locale._("is {the|} ${table} ${p}"), ((table, p) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Boolean, table, p)), C.expressionKeyFn, {});
    $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("preposition_boolean_projection", "p", ["functionName", 0, "functionName"])], $locale._("is {the|} ${table} ${p}"), ((table, p) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Boolean, table, p)), C.expressionKeyFn, {});
    $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("npi_boolean_projection", "p", ["functionName", 0, "functionName"])], $locale._("is {the|} ${table} ${p}"), ((table, p) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Boolean, table, p)), C.expressionKeyFn, {});
    $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("npv_boolean_projection", "p", ["functionName", 0, "functionName"])], $locale._("is {the|} ${table} ${p}"), ((table, p) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Boolean, table, p)), C.expressionKeyFn, {});
    $grammar.addRule("boolean_projection", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("apv_boolean_projection", "p", ["functionName", 0, "functionName"])], $locale._("is {the|} ${table} ${p}"), ((table, p) => C.makeSingleFieldProjection($loader, 'table', thingtalk_1.Type.Boolean, table, p)), C.expressionKeyFn, {});
    for (const proj of $loader.projections) {
        if (proj.category === 'pvp' || proj.category === 'passive_verb' || proj.category === 'preposition') {
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} ${table} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} ${table} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            if (proj.base) {
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            }
        }
        if (proj.category === 'avp' || proj.category === 'verb') {
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {do|does|did} {the|} ${table} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {do|does|did} {the|} ${table} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            if (proj.base) {
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} {the|} ${table} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            }
        }
        if (proj.category === 'reverse_verb') {
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            if (proj.base) {
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            }
        }
        if (proj.category === 'reverse_passive_verb') {
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            if (proj.base) {
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " " + (proj.canonical) + " {the|} ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            }
        }
        if (proj.category === 'property') {
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            if (proj.base) {
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} {the|} " + (proj.canonical) + " of ${table}"), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which} {is|was|are|were} ${table} 's " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            }
        }
        if (proj.category === 'reverse_property') {
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} {a|an|the|} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {is|was|are|were} ${table} {a|an|the|} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            if (proj.base) {
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} ${table} {is|was|are|were} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            }
        }
        if (proj.category === 'reverse_base') {
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            $grammar.declareSymbol("question_projection_table");
            $grammar.addRule("question_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.pronoun) + " " + (proj.base) + " {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            if (proj.base) {
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
                $grammar.declareSymbol("command_projection_table");
                $grammar.addRule("command_projection_table", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", ((proj.pslot.schema.qualifiedName))])], $locale._("" + (proj.base) + " {that|which|} {has|have} ${table} as {its|their|the} " + (proj.canonical) + ""), ((table) => C.makeSingleFieldProjection($loader, 'table', null, table, proj.pslot)), C.expressionKeyFn, {});
            }
        }
    }
    $grammar.declareSymbol("projection_Any");
    $grammar.addRule("projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("the ${outParam} of ${table}"), ((outParam, table) => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {});
    $grammar.addRule("projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("the ${outParam} of the ${table}"), ((outParam, table) => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {});
    $grammar.declareSymbol("verb_projection_Any");
    $grammar.addRule("verb_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("${outParam} {do|does} {the|} ${table} have"), ((outParam, table) => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {});
    $grammar.addRule("verb_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("${outParam} {do|does} {the|} ${table} have"), ((outParam, table) => C.makeSingleFieldProjection($loader, 'table', null, table, outParam)), C.expressionKeyFn, {});
    $grammar.declareSymbol("stream_projection_Any");
    if (!$options.flags.nostream) {
        $grammar.addRule("stream_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("the ${outParam} of new ${table}"), ((outParam, table) => C.makeSingleFieldProjection($loader, 'stream', null, table, outParam)), C.expressionKeyFn, {});
        $grammar.addRule("stream_projection_Any", [new $runtime.NonTerminal("out_param_Any", "outParam", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("the ${outParam} of the new ${table}"), ((outParam, table) => C.makeSingleFieldProjection($loader, 'stream', null, table, outParam)), C.expressionKeyFn, {});
        $grammar.addRule("stream_projection_Any", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_monitorable", (true)])], $locale._("new ${table}"), ((table) => C.makeTypeBasedStreamProjection(table)), C.expressionKeyFn, {});
    }
    $grammar.declareSymbol("placeholder");
    $grammar.addRule("placeholder", [], $locale._("some number"), (() => ({ type: thingtalk_1.Type.Number })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some value"), (() => ({ type: thingtalk_1.Type.Number })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("something"), (() => ({ type: thingtalk_1.Type.String })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some value"), (() => ({ type: thingtalk_1.Type.Currency })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some amount"), (() => ({ type: thingtalk_1.Type.Currency })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some time"), (() => ({ type: thingtalk_1.Type.Time })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain time"), (() => ({ type: thingtalk_1.Type.Time })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some date"), (() => ({ type: thingtalk_1.Type.Date })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain date"), (() => ({ type: thingtalk_1.Type.Date })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some time"), (() => ({ type: thingtalk_1.Type.Date })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain time"), (() => ({ type: thingtalk_1.Type.Date })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some location"), (() => ({ type: thingtalk_1.Type.Location })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a location"), (() => ({ type: thingtalk_1.Type.Location })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some place"), (() => ({ type: thingtalk_1.Type.Location })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a place"), (() => ({ type: thingtalk_1.Type.Location })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain place"), (() => ({ type: thingtalk_1.Type.Location })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("somewhere"), (() => ({ type: thingtalk_1.Type.Location })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some duration"), (() => ({ type: new thingtalk_1.Type.Measure('ms') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some amount of time"), (() => ({ type: new thingtalk_1.Type.Measure('ms') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some size"), (() => ({ type: new thingtalk_1.Type.Measure('byte') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain size"), (() => ({ type: new thingtalk_1.Type.Measure('byte') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain weight"), (() => ({ type: new thingtalk_1.Type.Measure('kg') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain temperature"), (() => ({ type: new thingtalk_1.Type.Measure('C') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some distance"), (() => ({ type: new thingtalk_1.Type.Measure('m') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some length"), (() => ({ type: new thingtalk_1.Type.Measure('m') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some size"), (() => ({ type: new thingtalk_1.Type.Measure('m2') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain size"), (() => ({ type: new thingtalk_1.Type.Measure('m2') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some volume"), (() => ({ type: new thingtalk_1.Type.Measure('m3') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain volume"), (() => ({ type: new thingtalk_1.Type.Measure('m3') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some speed"), (() => ({ type: new thingtalk_1.Type.Measure('mps') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("a certain speed"), (() => ({ type: new thingtalk_1.Type.Measure('mps') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some image"), (() => ({ type: new thingtalk_1.Type.Entity('tt:picture') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some picture"), (() => ({ type: new thingtalk_1.Type.Entity('tt:picture') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some photo"), (() => ({ type: new thingtalk_1.Type.Entity('tt:picture') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("somebody"), (() => ({ type: new thingtalk_1.Type.Entity('tt:username') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("someone"), (() => ({ type: new thingtalk_1.Type.Entity('tt:username') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some one"), (() => ({ type: new thingtalk_1.Type.Entity('tt:username') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some person"), (() => ({ type: new thingtalk_1.Type.Entity('tt:username') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("somebody"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("someone"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some one"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some person"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some number"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some phone number"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("somebody"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("someone"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some one"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some person"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some email address"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some file"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some directory"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some folder"), (() => ({ type: new thingtalk_1.Type.Entity('tt:phone_number') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some url"), (() => ({ type: new thingtalk_1.Type.Entity('tt:url') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some website"), (() => ({ type: new thingtalk_1.Type.Entity('tt:url') })), C.placeholderKeyFn, {});
    $grammar.addRule("placeholder", [], $locale._("some link"), (() => ({ type: new thingtalk_1.Type.Entity('tt:url') })), C.placeholderKeyFn, {});
}
exports.$load = $load;
;
//# sourceMappingURL=projections.genie.out.js.map