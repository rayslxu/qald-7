"use strict";
// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$load = exports.projection_Number = exports.with_arg_min_max_table = exports.compute_question = exports.projection_Measure_m = void 0;
const $runtime = __importStar(require("../sentence-generator/runtime"));
const assert_1 = __importDefault(require("assert"));
const thingtalk_1 = require("thingtalk");
const C = __importStar(require("./ast_manip"));
exports.projection_Measure_m = "projection_Measure_m";
exports.compute_question = "compute_question";
exports.with_arg_min_max_table = "with_arg_min_max_table";
exports.projection_Number = "projection_Number";
/**
 * Load the templates in this file.
 *
 * This is an autogenerated method that will be called by the {@link SentenceGenerator}
 * when the templates are imported.
 */
async function $load($options, $locale, $grammar, $loader) {
    const HERE = new thingtalk_1.Ast.Value.Location(new thingtalk_1.Ast.Location.Relative('current_location'));
    function hasGeoLocationOutput(schema) {
        const arg = schema.getArgument('geo');
        return arg && !arg.is_input && arg.type === thingtalk_1.Type.Location;
    }
    $grammar.declareSymbol("projection_Measure_m");
    $grammar.declareSymbol("compute_question");
    $grammar.declareSymbol("with_arg_min_max_table");
    $grammar.declareSymbol("projection_Measure_m");
    if (!$options.flags.turking) {
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("the distance {of|to} ${table} {from here|}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)])], $locale._("the distance {of|to} the ${table} {from here|}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("how {far|near|close} ${table} is {from here|}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)])], $locale._("how {far|near|close} the ${table} is {from here|}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("the distance {of|to} ${table} from ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("the distance from ${place} {of|to} ${table}"), ((place, table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("the distance {of|to} the ${table} from ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)])], $locale._("the distance from ${place} {of|to} the ${table}"), ((place, table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("how {far|near|close} from ${place} ${table} is"), ((place, table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} ${table} is from ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("constant_Location", "place", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)])], $locale._("how {far|near|close} from ${place} the ${table} is"), ((place, table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Measure_m", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} the ${table} is from ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
    }
    $grammar.declareSymbol("projection_Number");
    if (!$options.flags.turking) {
        $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("the number of ${p} {of|in|in the} ${table}"), ((p, table) => {
            const arg = table.schema.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("the number of ${p} {of|in} the ${table}"), ((p, table) => {
            const arg = table.schema.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("the number of ${p} with ${filter} {of|in|in the} ${table}"), ((p, filter, table) => {
            const ptype = table.schema.getArgType(p.name);
            if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem;
            if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("the number of ${p} with ${filter} {of|in} the ${table}"), ((p, filter, table) => {
            const ptype = table.schema.getArgType(p.name);
            if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                return null;
            const elementType = ptype.elem;
            if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                return null;
            const list = C.makeListExpression(p, filter);
            if (!list)
                return null;
            return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("the number of ${p} {of|in|in the} ${table}"), ((p, table) => {
            const arg = table.schema.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
        $grammar.addRule("projection_Number", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("the number of ${p} {of|in} the ${table}"), ((p, table) => {
            const arg = table.schema.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
    }
    $grammar.declareSymbol("compute_question");
    if (!$options.flags.turking) {
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("how {far|near|close} {is|are} ${table} {from here|} {?|}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)])], $locale._("how {far|near|close} {is|are} the ${table} {from here|} {?|}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} {is|are} ${table} {from|to} ${place} {?|}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_arg_min_max_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("how {far|near|close} {is|are} the ${table} {from|to} ${place} {?|}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'));
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} {does|do} ${table} have ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} {in a|in|in the} ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} are there {in a|in|in the} ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} {does|do} the ${table} have ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} in the ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_ArrayCount", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} are there in the ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isNumber);
            return C.makeProjection(table, p.name);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} {does|do} ${table} have ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} {in a|in|in the} ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} are there {in a|in|in the} ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} {does|do} the ${table} have ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} in the ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Any", "p", undefined), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} are there in the ${table} ?"), ((p, table) => {
            (0, assert_1.default)(table.schema.getArgType(p.name).isArray);
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeProjection(table, conflictParam);
            return C.makeAggComputeExpression(table, 'count', null, p, thingtalk_1.Type.Number);
        }), C.expressionKeyFn, {});
        if (!$options.flags.dialogues) {
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} with ${filter} {does|do} ${table} have ?"), ((p, filter, table) => {
                const ptype = table.schema.getArgType(p.name);
                if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                    return null;
                const elementType = ptype.elem;
                if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                    return null;
                const list = C.makeListExpression(p, filter);
                if (!list)
                    return null;
                return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
            }), C.expressionKeyFn, {});
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} with ${filter} {in a|in|in the} ${table} ?"), ((p, filter, table) => {
                const ptype = table.schema.getArgType(p.name);
                if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                    return null;
                const elementType = ptype.elem;
                if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                    return null;
                const list = C.makeListExpression(p, filter);
                if (!list)
                    return null;
                return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
            }), C.expressionKeyFn, {});
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} with ${filter} are there {in a|in|in the} ${table} ?"), ((p, filter, table) => {
                const ptype = table.schema.getArgType(p.name);
                if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                    return null;
                const elementType = ptype.elem;
                if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                    return null;
                const list = C.makeListExpression(p, filter);
                if (!list)
                    return null;
                return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
            }), C.expressionKeyFn, {});
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} with ${filter} {does|do} the ${table} have ?"), ((p, filter, table) => {
                const ptype = table.schema.getArgType(p.name);
                if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                    return null;
                const elementType = ptype.elem;
                if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                    return null;
                const list = C.makeListExpression(p, filter);
                if (!list)
                    return null;
                return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
            }), C.expressionKeyFn, {});
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} with ${filter} in the ${table} ?"), ((p, filter, table) => {
                const ptype = table.schema.getArgType(p.name);
                if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                    return null;
                const elementType = ptype.elem;
                if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                    return null;
                const list = C.makeListExpression(p, filter);
                if (!list)
                    return null;
                return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
            }), C.expressionKeyFn, {});
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Array__Compound", "p", undefined), new $runtime.NonTerminal("with_filter", "filter", ["functionName", 0, "functionName"]), new $runtime.NonTerminal("with_arg_min_max_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} with ${filter} are there in the ${table} ?"), ((p, filter, table) => {
                const ptype = table.schema.getArgType(p.name);
                if (!ptype || !(ptype instanceof thingtalk_1.Type.Array) || !(filter instanceof thingtalk_1.Ast.AtomBooleanExpression))
                    return null;
                const elementType = ptype.elem;
                if (!(elementType instanceof thingtalk_1.Type.Compound) || !elementType.fields[filter.name])
                    return null;
                const list = C.makeListExpression(p, filter);
                if (!list)
                    return null;
                return C.makeAggComputeExpression(table, 'count', null, list, thingtalk_1.Type.Number);
            }), C.expressionKeyFn, {});
        }
        if ($options.flags.aggregation) {
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_list", (true)])], $locale._("how many ${table} are there ?"), ((table) => {
                (0, assert_1.default)(table.schema.is_list);
                const newSchema = table.schema.filterArguments((arg) => arg.direction !== thingtalk_1.Ast.ArgDirection.OUT)
                    .addArguments([new thingtalk_1.Ast.ArgumentDef(null, thingtalk_1.Ast.ArgDirection.OUT, 'count', thingtalk_1.Type.Number)]);
                newSchema.is_list = false;
                const agg = new thingtalk_1.Ast.AggregationExpression(null, table, '*', 'count', newSchema);
                return new thingtalk_1.Ast.ProjectionExpression(null, agg, ['count'], [], [], newSchema);
            }), C.expressionKeyFn, {});
            $grammar.addRule("compute_question", [new $runtime.NonTerminal("with_filtered_table", "table", ["is_list", (true)])], $locale._("{please|} count the ${table}"), ((table) => {
                (0, assert_1.default)(table.schema.is_list);
                const newSchema = table.schema.filterArguments((arg) => arg.direction !== thingtalk_1.Ast.ArgDirection.OUT)
                    .addArguments([new thingtalk_1.Ast.ArgumentDef(null, thingtalk_1.Ast.ArgDirection.OUT, 'count', thingtalk_1.Type.Number)]);
                newSchema.is_list = false;
                const agg = new thingtalk_1.Ast.AggregationExpression(null, table, '*', 'count', newSchema);
                return new thingtalk_1.Ast.ProjectionExpression(null, agg, ['count'], [], [], newSchema);
            }), C.expressionKeyFn, {});
            if (!$options.flags.schema_org) {
                $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Any", "p", ["is_numeric", (true)]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} are {in|in the} ${table} ?"), ((p, table) => {
                    const arg = table.schema.getArgument(p.name);
                    if (!arg || arg.is_input || !arg.type.isNumeric())
                        return null;
                    if (!table.schema.is_list)
                        return null;
                    const newSchema = table.schema.filterArguments((arg) => arg.direction !== thingtalk_1.Ast.ArgDirection.OUT || arg.name === p.name);
                    newSchema.is_list = false;
                    const agg = new thingtalk_1.Ast.AggregationExpression(null, table, p.name, 'sum', newSchema);
                    return new thingtalk_1.Ast.ProjectionExpression(null, agg, [p.name], [], [], newSchema);
                }), C.expressionKeyFn, {});
            }
            if (!$options.flags.schema_org) {
                $grammar.addRule("compute_question", [new $runtime.NonTerminal("out_param_Any", "p", ["is_numeric", (true)]), new $runtime.NonTerminal("with_filtered_table", "table", ["functionName", 0, "functionName"])], $locale._("how many ${p} {do|does} ${table} have ?"), ((p, table) => {
                    const arg = table.schema.getArgument(p.name);
                    if (!arg || arg.is_input || !arg.type.isNumeric())
                        return null;
                    if (!table.schema.is_list)
                        return null;
                    const newSchema = table.schema.filterArguments((arg) => arg.direction !== thingtalk_1.Ast.ArgDirection.OUT || arg.name === p.name);
                    newSchema.is_list = false;
                    const agg = new thingtalk_1.Ast.AggregationExpression(null, table, p.name, 'sum', newSchema);
                    return new thingtalk_1.Ast.ProjectionExpression(null, agg, [p.name], [], [], newSchema);
                }), C.expressionKeyFn, {});
            }
        }
    }
    $grammar.declareSymbol("with_arg_min_max_table");
    if (!$options.flags.turking) {
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo", (true)])], $locale._("{nearest|closest} ${table} {|from here|to here|to me}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("{nearest|closest} ${table}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)])], $locale._("{farthest|most far away} ${table}"), ((table) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), HERE], new thingtalk_1.Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("{nearest|closest} ${table} to ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {that is|which is} {nearest|closest} to ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("complete_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {nearest|closest} to ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("{nearest|closest} ${table} to ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {that is|which is} {nearest|closest} to ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {nearest|closest} to ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'asc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("{farthest|most far away} ${table} from ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {that is|which is} {farthest|most far away} from ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", ["has_geo", (true)]), new $runtime.NonTerminal("constant_Location", "place", undefined)], $locale._("${table} {farthest|most far away} from ${place}"), ((table, place) => {
            (0, assert_1.default)(hasGeoLocationOutput(table.schema));
            return C.makeComputeArgMinMaxExpression(table, 'distance', [new thingtalk_1.Ast.Value.VarRef('geo'), place], new thingtalk_1.Type.Measure('m'), 'desc');
        }), C.expressionKeyFn, {});
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["functionName", 0, "functionName"])], $locale._("${table} with the {most|highest number of|largest number of|largest count of} ${p}"), ((table, p) => {
            const arg = table.schema.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isArray)
                return null;
            const conflictParam = C.hasConflictParam(table, p.name, 'count');
            if (conflictParam)
                return C.makeArgMaxMinTable(table, conflictParam, 'desc');
            return C.makeAggComputeArgMinMaxExpression(table, 'count', null, p, thingtalk_1.Type.Number, 'desc');
        }), C.expressionKeyFn, { weight: (0.33) });
        if (!$options.flags.turking) {
            $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["functionName", 0, "functionName"])], $locale._("${table} with the {least|fewest|smallest number of|tiniest number of|smallest count of} ${p}"), ((table, p) => {
                const arg = table.schema.getArgument(p.name);
                if (!arg || arg.is_input || !arg.type.isArray)
                    return null;
                const conflictParam = C.hasConflictParam(table, p.name, 'count');
                if (conflictParam)
                    return C.makeArgMaxMinTable(table, conflictParam, 'asc');
                return C.makeAggComputeArgMinMaxExpression(table, 'count', null, p, thingtalk_1.Type.Number, 'asc');
            }), C.expressionKeyFn, { weight: (0.33) });
        }
        if ($options.flags.turking) {
            $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_Array__Any", "p", ["functionName", 0, "functionName"])], $locale._("${table} with the {fewest|smallest number of} ${p}"), ((table, p) => {
                const arg = table.schema.getArgument(p.name);
                if (!arg || arg.is_input || !arg.type.isArray)
                    return null;
                const conflictParam = C.hasConflictParam(table, p.name, 'count');
                if (conflictParam)
                    return C.makeArgMaxMinTable(table, conflictParam, 'asc');
                return C.makeAggComputeArgMinMaxExpression(table, 'count', null, p, thingtalk_1.Type.Number, 'asc');
            }), C.expressionKeyFn, { weight: (0.33) });
        }
        $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", ["functionName", 0, "functionName"])], $locale._("${table} with the {most|highest number of|largest number of|largest count of} ${p}"), ((table, p) => {
            const arg = table.schema.getArgument(p.name);
            if (!arg || arg.is_input || !arg.type.isNumber)
                return null;
            return C.makeArgMaxMinTable(table, p.name, 'desc');
        }), C.expressionKeyFn, { weight: (0.33) });
        if (!$options.flags.turking) {
            $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", ["functionName", 0, "functionName"])], $locale._("${table} with the {least|fewest|smallest number of|tiniest number of|smallest count of} ${p}"), ((table, p) => {
                const arg = table.schema.getArgument(p.name);
                if (!arg || arg.is_input || !arg.type.isNumber)
                    return null;
                return C.makeArgMaxMinTable(table, p.name, 'asc');
            }), C.expressionKeyFn, { weight: (0.33) });
        }
        if ($options.flags.turking) {
            $grammar.addRule("with_arg_min_max_table", [new $runtime.NonTerminal("with_filtered_table", "table", undefined), new $runtime.NonTerminal("out_param_ArrayCount", "p", ["functionName", 0, "functionName"])], $locale._("${table} with the {fewest|smallest number of} ${p}"), ((table, p) => {
                const arg = table.schema.getArgument(p.name);
                if (!arg || arg.is_input || !arg.type.isNumber)
                    return null;
                return C.makeArgMaxMinTable(table, p.name, 'asc');
            }), C.expressionKeyFn, { weight: (0.33) });
        }
    }
}
exports.$load = $load;
;
//# sourceMappingURL=computation.genie.out.js.map