"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.negativeListProposalReply = exports.listProposalLearnMoreReply = exports.positiveListProposalReplyActionByName = exports.positiveListProposalReply = exports.makeListProposalReply = exports.checkListProposal = exports.makeListProposalFromDirectAnswers = exports.addActionToListProposal = exports.checkThingpediaListProposal = exports.listProposalKeyFn = void 0;
const assert_1 = __importDefault(require("assert"));
const thingtalk_1 = require("thingtalk");
const ThingTalkUtils = __importStar(require("../../utils/thingtalk"));
const C = __importStar(require("../ast_manip"));
const state_manip_1 = require("../state_manip");
const common_1 = require("./common");
const refinement_helpers_1 = require("./refinement-helpers");
const slot_bag_1 = require("../slot_bag");
function listProposalKeyFn({ results, info, action, hasLearnMore }) {
    return {
        idType: results[0].value.id ? results[0].value.id.getType() : null,
        queryName: info ? info.schema.qualifiedName : null,
        actionName: action ? action.schema.qualifiedName : null,
        length: results.length
    };
}
exports.listProposalKeyFn = listProposalKeyFn;
function checkInvocationCast(x) {
    (0, assert_1.default)(x instanceof thingtalk_1.Ast.Invocation);
    return x;
}
function checkListProposal(nameList, info, hasLearnMore) {
    const { ctx, results } = nameList;
    const resultType = results[0].value.id.getType();
    const currentStmt = ctx.current.stmt;
    const currentTable = currentStmt.expression;
    const last = currentTable.last;
    if ((last instanceof thingtalk_1.Ast.SliceExpression ||
        (last instanceof thingtalk_1.Ast.ProjectionExpression && last.expression instanceof thingtalk_1.Ast.SliceExpression)) &&
        results.length !== ctx.results.length)
        return null;
    if (info !== null) {
        const idType = info.schema.getArgType('id');
        if (!idType || !idType.equals(resultType))
            return null;
        const resultInfo = ctx.resultInfo;
        if (resultInfo.projection !== null) {
            // check that all projected names are present
            for (const name of resultInfo.projection) {
                if (!info.has(name))
                    return null;
            }
        }
        // check that the filter uses the right set of parameters
        for (const result of results) {
            if (!(0, common_1.isInfoPhraseCompatibleWithResult)(result, info))
                return null;
        }
    }
    else {
        if (ctx.resultInfo.projection !== null)
            return null;
    }
    const action = ctx.nextInfo && ctx.nextInfo.isAction ? checkInvocationCast(C.getInvocation(ctx.next)) : null;
    return { results, info, action, hasLearnMore };
}
exports.checkListProposal = checkListProposal;
function checkThingpediaListProposal(proposal, additionalInfo) {
    const [ctx, info] = proposal;
    const resultInfo = ctx.resultInfo;
    if (resultInfo.projection !== null) {
        // check that all projected names are present
        for (const name of resultInfo.projection) {
            if (!info.has(name))
                return null;
        }
    }
    let mergedInfo = info;
    if (additionalInfo) {
        // check that the new info is truthful
        for (const result of ctx.results) {
            if (!(0, common_1.isInfoPhraseCompatibleWithResult)(result, additionalInfo))
                return null;
        }
        mergedInfo = slot_bag_1.SlotBag.merge(mergedInfo, additionalInfo);
    }
    if (!mergedInfo)
        return null;
    const action = ctx.nextInfo && ctx.nextInfo.isAction ? checkInvocationCast(C.getInvocation(ctx.next)) : null;
    return { results: ctx.results, info: mergedInfo, action, hasLearnMore: false };
}
exports.checkThingpediaListProposal = checkThingpediaListProposal;
function addActionToListProposal(nameList, action) {
    const { ctx, results } = nameList;
    if (ctx.resultInfo.projection !== null)
        return null;
    const currentStmt = ctx.current.stmt;
    const currentTable = currentStmt.expression;
    const last = currentTable.last;
    if (last instanceof thingtalk_1.Ast.SliceExpression &&
        results.length !== ctx.results.length)
        return null;
    if (!results[0].value.id)
        return null;
    const resultType = results[0].value.id.getType();
    if (!C.hasArgumentOfType(action, resultType))
        return null;
    const ctxAction = ctx.nextInfo && ctx.nextInfo.isAction ? checkInvocationCast(C.getInvocation(ctx.next)) : null;
    if (ctxAction && !C.isSameFunction(ctxAction.schema, action.schema))
        return null;
    return { results, info: null, action, hasLearnMore: false };
}
exports.addActionToListProposal = addActionToListProposal;
function makeListProposalFromDirectAnswers(...phrases) {
    for (let i = 0; i < phrases.length; i++) {
        if (phrases[i].index !== i)
            return null;
    }
    const ctx = phrases[0].result.ctx;
    const currentStmt = ctx.current.stmt;
    const currentTable = currentStmt.expression;
    const last = currentTable.last;
    if ((last instanceof thingtalk_1.Ast.SliceExpression ||
        (last instanceof thingtalk_1.Ast.ProjectionExpression && last.expression instanceof thingtalk_1.Ast.SliceExpression)) &&
        phrases.length !== ctx.results.length)
        return null;
    // check that all phrases talk about the same slots (it would be weird otherwise)
    for (let i = 1; i < phrases.length; i++) {
        for (const key of phrases[i].result.info.keys()) {
            if (!phrases[0].result.info.has(key))
                return null;
        }
        for (const key of phrases[0].result.info.keys()) {
            if (!phrases[i].result.info.has(key))
                return null;
        }
    }
    const resultInfo = ctx.resultInfo;
    if (resultInfo.projection !== null) {
        // check that all projected names are present
        for (const name of resultInfo.projection) {
            if (!phrases[0].result.info.has(name))
                return null;
        }
    }
    // don't use a direct answer with a list if the user is issuing a query by name
    const filterTable = C.findFilterExpression(currentTable);
    if (filterTable && C.filterUsesParam(filterTable.filter, 'id'))
        return null;
    const results = ctx.results.slice(0, phrases.length);
    return { results, info: null, action: null, hasLearnMore: false };
}
exports.makeListProposalFromDirectAnswers = makeListProposalFromDirectAnswers;
function makeListProposalReply(ctx, proposal) {
    const { results, action, hasLearnMore } = proposal;
    const options = {
        numResults: results.length
    };
    if (action || hasLearnMore)
        options.end = false;
    let dialogueAct;
    switch (results.length) {
        case 2:
            dialogueAct = 'sys_recommend_two';
            break;
        case 3:
            dialogueAct = 'sys_recommend_three';
            break;
        case 4:
            dialogueAct = 'sys_recommend_four';
            break;
        default:
            dialogueAct = 'sys_recommend_many';
    }
    if (action === null)
        return (0, state_manip_1.makeAgentReply)(ctx, (0, state_manip_1.makeSimpleState)(ctx, dialogueAct, null), proposal, null, options);
    else
        return (0, state_manip_1.makeAgentReply)(ctx, (0, state_manip_1.addAction)(ctx, dialogueAct, action, 'proposed'), proposal, null, options);
}
exports.makeListProposalReply = makeListProposalReply;
function positiveListProposalReply(loader, ctx, [name, acceptedAction, mustHaveAction]) {
    // if actionProposal === null the flow is roughly
    //
    // U: hello i am looking for a restaurant
    // A: how about the ... or the ... ?
    // U: I like the ... bla
    //
    // in this case, the agent should hit the "... is a ... restaurant in the ..."
    // we treat it as "execute" dialogue act and add a filter that causes the program to return a single result
    const proposal = ctx.aux;
    const { results, action: actionProposal } = proposal;
    if (!results[0].value.id)
        return null;
    let good = false;
    for (const result of results) {
        if (result.value.id.equals(name)) {
            good = true;
            break;
        }
    }
    if (!good)
        return null;
    if (acceptedAction === null)
        acceptedAction = actionProposal;
    if (acceptedAction === null) {
        if (mustHaveAction)
            return null;
        const currentStmt = ctx.current.stmt;
        const currentTable = currentStmt.expression;
        const namefilter = new thingtalk_1.Ast.BooleanExpression.Atom(null, 'id', '==', name);
        const newTable = (0, refinement_helpers_1.queryRefinement)(currentTable, namefilter, (one, two) => new thingtalk_1.Ast.BooleanExpression.And(null, [one, two]), null);
        if (newTable === null)
            return null;
        return (0, state_manip_1.addQuery)(ctx, 'execute', newTable, 'accepted');
    }
    else {
        if (actionProposal !== null && !C.isSameFunction(actionProposal.schema, acceptedAction.schema))
            return null;
        // do not consider a phrase of the form "play X" to be "accepting the action by name"
        // if the action auto-confirms, because the user is likely playing something else
        if (acceptedAction && name) {
            const confirm = ThingTalkUtils.normalizeConfirmAnnotation(acceptedAction.schema);
            if (confirm === 'auto')
                return null;
        }
        const chainParam = (0, common_1.findChainParam)(results[0], acceptedAction);
        if (!chainParam)
            return null;
        return (0, state_manip_1.addActionParam)(ctx, 'execute', acceptedAction, chainParam, name, 'accepted');
    }
}
exports.positiveListProposalReply = positiveListProposalReply;
function positiveListProposalReplyActionByName(loader, ctx, action) {
    const proposal = ctx.aux;
    const { results } = proposal;
    if (!results[0].value.id)
        return null;
    let name = null;
    const acceptedAction = action.clone();
    const idType = results[0].value.id.getType();
    // find the chain parameter for the action, extract the name, and set the param to undefined
    // as the rest of the code expects
    for (const in_param of acceptedAction.in_params) {
        const arg = action.schema.getArgument(in_param.name);
        (0, assert_1.default)(arg);
        if (arg.type.equals(idType)) {
            name = in_param.value;
            in_param.value = new thingtalk_1.Ast.Value.Undefined(true);
            break;
        }
    }
    if (!name)
        return null;
    return positiveListProposalReply(loader, ctx, [name, acceptedAction, false]);
}
exports.positiveListProposalReplyActionByName = positiveListProposalReplyActionByName;
function negativeListProposalReply(ctx, [preamble, request]) {
    if (!((preamble === null || preamble instanceof thingtalk_1.Ast.FilterExpression) &&
        (request === null || request instanceof thingtalk_1.Ast.FilterExpression)))
        return null;
    const proposal = ctx.aux;
    const { results, info } = proposal;
    if (!results[0].value.id)
        return null;
    const proposalType = results[0].value.id.getType();
    request = (0, refinement_helpers_1.combinePreambleAndRequest)(preamble, request, info, proposalType);
    if (request === null)
        return null;
    return (0, refinement_helpers_1.proposalReply)(ctx, request, refinement_helpers_1.refineFilterToAnswerQuestionOrChangeFilter);
}
exports.negativeListProposalReply = negativeListProposalReply;
function listProposalLearnMoreReply(ctx, name) {
    // note: a learn more from a list proposal is different than a learn_more from a recommendation
    // in a recommendation, there is no change to the program, and the agent replies "what would
    // you like to know"
    // in a list proposal, we add a filter "id == "
    const proposal = ctx.aux;
    const { results } = proposal;
    if (!results[0].value.id)
        return null;
    let good = false;
    for (const result of results) {
        if (result.value.id.equals(name)) {
            good = true;
            break;
        }
    }
    if (!good)
        return null;
    const currentStmt = ctx.current.stmt;
    const currentTable = currentStmt.expression;
    const namefilter = new thingtalk_1.Ast.BooleanExpression.Atom(null, 'id', '==', name);
    const newTable = (0, refinement_helpers_1.queryRefinement)(currentTable, namefilter, (one, two) => new thingtalk_1.Ast.BooleanExpression.And(null, [one, two]), null);
    if (newTable === null)
        return null;
    return (0, state_manip_1.addQuery)(ctx, 'execute', newTable, 'accepted');
}
exports.listProposalLearnMoreReply = listProposalLearnMoreReply;
//# sourceMappingURL=list-proposal.js.map