import { Ast, Type } from 'thingtalk';
import { Placeholder, ErrorMessage, ParamSlot, FilterValueSlot, FilterSlot, InputParamSlot, DomainIndependentFilterSlot, ExpressionWithCoreference, makeInputParamSlot, makeDomainIndependentFilter, makeFilter, makeAndFilter, makeDateRangeFilter, typeToStringSafe, isSameFunction } from './utils';
export { Placeholder, ErrorMessage, ParamSlot, FilterValueSlot, FilterSlot, InputParamSlot, DomainIndependentFilterSlot, ExpressionWithCoreference, makeInputParamSlot, makeDomainIndependentFilter, makeFilter, makeAndFilter, makeDateRangeFilter, };
export * from './keyfns';
import type ThingpediaLoader from './load-thingpedia';
export declare type ArgMinMax = [ParamSlot, 'asc' | 'desc'];
export declare function isEntityOfFunction(type: InstanceType<typeof Type.Entity>, schema: Ast.FunctionDef): boolean;
declare function makeDate(base: Ast.Value | Date | Ast.DateEdge | Ast.DatePiece | Ast.WeekDayDate | null, operator: '+' | '-', offset: null): Ast.Value;
declare function makeDate(base: Ast.Value | Date | Ast.DateEdge | Ast.DatePiece | Ast.WeekDayDate | null, operator: '+' | '-', offset: Ast.Value | null): Ast.Value | null;
declare function makeDateWithDateTime(base: Ast.Value | Date | Ast.DateEdge | Ast.DatePiece | Ast.WeekDayDate | null, time: Ast.Value | null): Ast.Value;
export declare function fixTwoYearNumber(year: number): number;
export declare function makeJSDate(year: number, month: number, loader: ThingpediaLoader): Date;
export declare function dateOrDatePiece(year: number | null, month: number | null, loader: ThingpediaLoader): Date | Ast.DatePiece;
declare function makeMonthDateRange(year: number | null, month: number | null, loader: ThingpediaLoader): [Ast.Value, Ast.Value];
declare function getFunctionNames(ast: Ast.Node): string[];
declare function getFunctions(ast: Ast.Node): Ast.FunctionDef[];
export declare function betaReduceMany<T extends Ast.Expression | Ast.Invocation>(ast: T, replacements: Record<string, Ast.Value>): T | null;
export declare function makeDontCareFilter(slot: ParamSlot): FilterSlot;
declare function makeOrFilter(tpLoader: ThingpediaLoader, slot: ParamSlot, op: string, values: [Ast.Value, Ast.Value], negate?: boolean): FilterSlot | null;
declare function makeButFilter(tpLoader: ThingpediaLoader, slot: ParamSlot, op: string, values: [Ast.Value, Ast.Value]): FilterSlot | null;
declare function makeListExpression(param: ParamSlot, filter: FilterSlot): FilterValueSlot | null;
declare function makeAggregateFilter(param: ParamSlot, aggregationOp: string, field: ParamSlot | '*' | null, op: string, value: Ast.Value): FilterSlot | null;
declare function makeAggregateFilterWithFilter(param: ParamSlot, filter: FilterSlot | null, aggregationOp: string, field: ParamSlot | '*' | null, op: string, value: Ast.Value): FilterSlot | null;
export declare function countInputOutputParams(fndef: Ast.FunctionDef): {
    input: number;
    output: number;
};
declare function makeEdgeFilterStream(loader: ThingpediaLoader, proj: Ast.Expression, op: string, value: Ast.Value): Ast.Expression | null;
declare function addUnit(unit: string, num: Ast.VarRefValue | Ast.NumberValue): Ast.Value;
export declare function getScalarExpressionName(ast: Ast.Value): string;
/**
 * Return all names that are explicitly projected by a projection.
 *
 * This is equivalent to all the output parameters minus the minimal projection.
 */
export declare function getProjectionArguments(table: Ast.ProjectionExpression): string[];
declare function resolveProjection(schema: Ast.FunctionDef, args: string[], computations?: Ast.Value[], aliases?: Array<string | null>): Ast.FunctionDef;
declare function makeProjection(table: Ast.Expression, pname: string): Ast.ProjectionExpression;
/**
 * Compute the parameter passing to use from a table if a parameter name is
 * not spefified explicitly.
 */
export declare function getImplicitParameterPassing(schema: Ast.FunctionDef): string;
export declare function makeTypeBasedTableProjection(tpLoader: ThingpediaLoader, table: Ast.Expression, intotype?: Type): Ast.ProjectionExpression | null;
export declare function makeTypeBasedStreamProjection(table: Ast.Expression): Ast.ProjectionExpression | null;
declare function makeSingleFieldProjection(loader: ThingpediaLoader, ftype: 'table' | 'stream', ptype: Type | null, table: Ast.Expression, param: ParamSlot | 'geo'): Ast.Expression | null;
declare function makeMultiFieldProjection(loader: ThingpediaLoader, ftype: 'table' | 'stream', table: Ast.Expression, outParams: ParamSlot[]): Ast.Expression | null;
declare function makeArgMaxMinTable(table: Ast.Expression, pname: string, direction: 'asc' | 'desc', count?: Ast.Value): Ast.SliceExpression | null;
declare function makeSortedTable(table: Ast.Expression, pname: string, direction?: string): Ast.SortExpression | null;
declare function checkValidQuery(table: Ast.Expression): boolean;
export declare function toChainExpression(expr: Ast.Expression): Ast.ChainExpression;
declare function makeProgram(loader: ThingpediaLoader, rule: Ast.Expression): Ast.Program | null;
declare function combineStreamCommand(stream: Ast.Expression, command: Ast.ChainExpression): Ast.ChainExpression | null;
export declare function combineStreamQuery(loader: ThingpediaLoader, stream: Ast.Expression, table: Ast.Expression): Ast.ChainExpression | null;
declare function checkFilter(loader: ThingpediaLoader, table: Ast.Expression, filter: FilterSlot | DomainIndependentFilterSlot): boolean;
declare function iterateFilters(table: Ast.Expression): Generator<[Ast.FunctionDef, Ast.BooleanExpression], void>;
declare function iterateFields(filter: Ast.BooleanExpression): Generator<Ast.AtomBooleanExpression | Ast.DontCareBooleanExpression, void>;
declare function hasUniqueFilter(table: Ast.Expression): boolean;
interface AddFilterOptions {
    ifFilter?: boolean;
}
declare function addFilter(loader: ThingpediaLoader, table: Ast.Expression, filter: FilterSlot | DomainIndependentFilterSlot, options?: AddFilterOptions): Ast.Expression | null;
declare function tableToStream(table: Ast.Expression, options: {
    monitorItemID: boolean;
}): Ast.Expression | null;
declare function builtinSayAction(loader: ThingpediaLoader, message?: Ast.Value | string): Ast.InvocationExpression | null;
declare function locationSubquery(loader: ThingpediaLoader, loc: Ast.Value, negate?: boolean): DomainIndependentFilterSlot | null;
declare function timeSubquery(loader: ThingpediaLoader, low: Ast.Value | null, high: Ast.Value | null): DomainIndependentFilterSlot | null;
declare function hasExistentialSubquery(filter: Ast.BooleanExpression): boolean;
declare function makeExistentialSubquery(proj: Ast.Expression, op: string, value: Ast.Value, negate?: boolean): DomainIndependentFilterSlot | null;
export declare function resolveChain(expressions: Ast.Expression[]): Ast.FunctionDef;
export declare function makeChainExpression(first: Ast.Expression, second: Ast.Expression): Ast.ChainExpression;
export declare function addParameterPassing(first: Ast.Expression, second: ExpressionWithCoreference): Ast.ChainExpression | null;
export declare function addSameNameParameterPassing(loader: ThingpediaLoader, chain: Ast.ChainExpression, joinArg: ParamSlot): Ast.ChainExpression | null;
declare function isConstantAssignable(loader: ThingpediaLoader, value: Ast.Value, ptype: Type): boolean;
export declare function replacePlaceholderWithUndefined<T extends Ast.Expression | Ast.Invocation>(lhs: T, param: string): T | null;
declare function sayProjection(loader: ThingpediaLoader, maybeProj: Ast.Expression | null): Ast.Expression | null;
declare function hasConflictParam(table: Ast.Expression, pname: string, operation: string): string | null;
declare function addComparisonSubquery(table: Ast.Expression, subquery: Ast.Expression, pname: string | null, negate?: boolean): Ast.Expression | null;
declare function addReverseComparisonSubquery(table: Ast.Expression, subquery: Ast.Expression, pname: string | null, negate?: boolean): Ast.Expression | null;
declare function makeComputeExpression(table: Ast.Expression, operation: string, operands: Ast.Value[], resultType: Type): Ast.Expression;
declare function makeComputeFilterExpression(loader: ThingpediaLoader, table: Ast.Expression, operation: 'distance', operands: Ast.Value[], resultType: Type, filterOp: string, filterValue: Ast.Value): Ast.Expression | null;
declare function makeWithinGeoDistanceExpression(loader: ThingpediaLoader, table: Ast.Expression, location: Ast.Value, filterValue: Ast.Value): Ast.Expression | null;
declare function makeComputeArgMinMaxExpression(table: Ast.Expression, operation: string, operands: Ast.Value[], resultType: Type, direction?: 'asc' | 'desc'): Ast.Expression | null;
declare function makeAggComputeExpression(table: Ast.Expression, operation: string, field: string | null, list: ParamSlot | FilterValueSlot, resultType: Type): Ast.Expression | null;
declare function makeAggComputeArgMinMaxExpression(table: Ast.Expression, operation: string, field: string | null, list: ParamSlot | FilterValueSlot, resultType: Type, direction?: 'asc' | 'desc'): Ast.Expression | null;
declare function hasArgumentOfType(invocation: Ast.Invocation, type: Type): boolean;
declare function filterUsesParam(filter: Ast.BooleanExpression, pname: string): boolean;
interface AddInputParamsOptions {
    allowOutput?: boolean;
}
declare function checkInvocationInputParam(loader: ThingpediaLoader, invocation: Ast.Invocation, param: InputParamSlot, options?: AddInputParamsOptions): boolean;
declare function addInvocationInputParam(loader: ThingpediaLoader, invocation: Ast.Invocation, param: InputParamSlot, options?: AddInputParamsOptions): Ast.Invocation | null;
declare function addActionInputParam(loader: ThingpediaLoader, action: Ast.Expression, param: InputParamSlot, options?: AddInputParamsOptions): Ast.Expression | null;
/**
 * Find the filter expression in the context.
 *
 * Returns filter expression
 */
declare function findFilterExpression(root: Ast.Expression): Ast.FilterExpression | null;
declare function getInvocation(historyItem: Ast.Node): Ast.Invocation | Ast.FunctionCallExpression;
declare function adjustDefaultParameters<T extends Ast.Node>(stmt: T): T;
export declare function expressionUsesIDFilter(expr: Ast.Expression): boolean;
export declare function makeReminder(loader: ThingpediaLoader, timer: Ast.FunctionCallExpression, message?: Ast.Value): Ast.ChainExpression | null;
export declare function makeDateReminder(loader: ThingpediaLoader, date: Ast.Value, message?: Ast.Value): Ast.ChainExpression | null;
export declare function makeDurationReminder(loader: ThingpediaLoader, duration: Ast.Value, message?: Ast.Value): Ast.ChainExpression | null;
export declare function makeAlarm(loader: ThingpediaLoader, timer: Ast.FunctionCallExpression): Ast.ChainExpression | null;
export declare function makeDateAlarm(loader: ThingpediaLoader, date: Ast.Value): Ast.ChainExpression | null;
export declare function makeDurationAlarm(loader: ThingpediaLoader, duration: Ast.Value): Ast.ChainExpression | null;
export declare function makeFrequencyTimer(loader: ThingpediaLoader, frequency: Ast.Value, unit: 'ms' | 's' | 'min' | 'h' | 'day' | 'week' | 'mon' | 'year'): Ast.FunctionCallExpression;
export declare function makeIntervalTimer(loader: ThingpediaLoader, unit: 'ms' | 's' | 'min' | 'h' | 'day' | 'week' | 'mon' | 'year'): Ast.FunctionCallExpression;
export declare function makeRepeatingTimeTimer(loader: ThingpediaLoader, times: Ast.Value[]): Ast.FunctionCallExpression;
export declare function makeDateTimer(loader: ThingpediaLoader, date: Ast.Value): Ast.FunctionCallExpression | null;
declare function makeSelfJoin(table: Ast.Expression, condition: FilterSlot): Ast.ProjectionExpression | null;
declare function makeSelfJoinFromParam(tpLoader: ThingpediaLoader, table: Ast.Expression, param: ParamSlot): Ast.ProjectionExpression | null;
declare function makeGenericJoin(tpLoader: ThingpediaLoader, lhs: Ast.Expression, lhsParam: ParamSlot, rhs: Ast.Expression, rhsParam: ParamSlot): Ast.ProjectionExpression | null;
export declare function whenDoRule(table: Ast.Expression, action: ExpressionWithCoreference, options: {
    monitorItemID: boolean;
}): Ast.ChainExpression | null;
export { typeToStringSafe, isSameFunction, hasArgumentOfType, isConstantAssignable, filterUsesParam, getFunctionNames, getFunctions, getInvocation, adjustDefaultParameters, hasConflictParam, addUnit, makeDate, makeMonthDateRange, makeDateWithDateTime, builtinSayAction, locationSubquery, timeSubquery, makeProgram, combineStreamCommand, checkInvocationInputParam, addInvocationInputParam, addActionInputParam, hasUniqueFilter, makeOrFilter, makeButFilter, makeAggregateFilter, makeAggregateFilterWithFilter, checkFilter, addFilter, findFilterExpression, hasExistentialSubquery, makeExistentialSubquery, addComparisonSubquery, addReverseComparisonSubquery, makeListExpression, makeSortedTable, makeArgMaxMinTable, checkValidQuery, resolveProjection, makeProjection, makeSingleFieldProjection, makeMultiFieldProjection, sayProjection, makeSelfJoin, makeSelfJoinFromParam, makeGenericJoin, makeEdgeFilterStream, tableToStream, makeComputeExpression, makeComputeFilterExpression, makeComputeArgMinMaxExpression, makeAggComputeExpression, makeAggComputeArgMinMaxExpression, makeWithinGeoDistanceExpression, iterateFilters, iterateFields, };
