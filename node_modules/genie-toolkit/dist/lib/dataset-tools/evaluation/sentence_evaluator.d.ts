/// <reference types="node" />
import Stream from 'stream';
import * as ThingTalkUtils from '../../utils/thingtalk';
import { ParserClient } from '../../prediction/parserclient';
import { SentenceExample } from '../parsers';
declare const COMPLEXITY_METRICS: {
    num_params(id: string, code: string): number;
    turn_number(id: string, code: string): number;
};
declare type SentenceEvaluatorOptions = {
    locale: string;
    targetLanguage: string;
    debug: boolean;
    tokenized?: boolean;
    oracle?: boolean;
    complexityMetric?: keyof typeof COMPLEXITY_METRICS;
    includeEntityValue?: boolean;
    excludeEntityDisplay?: boolean;
    ignoreEntityType?: boolean;
} & ThingTalkUtils.ParseOptions;
export interface ExampleEvaluationResult {
    id: string;
    preprocessed: string;
    target_code: string[];
    target_devices: string[];
    ok: boolean[];
    ok_without_param: boolean[];
    ok_function: boolean[];
    ok_device: boolean[];
    ok_num_function: boolean[];
    ok_syntax: boolean[];
    is_primitive: boolean;
    complexity: number | undefined;
    has_numeric: boolean;
}
export declare type EvaluationResult = {
    total: number;
    primitives: number;
    compounds: number;
    ok: number[];
    ok_without_param: number[];
    ok_function: number[];
    ok_device: number[];
    ok_num_function: number[];
    ok_syntax: number[];
    'prim/ok': number[];
    'prim/ok_without_param': number[];
    'prim/ok_function': number[];
    'prim/ok_device': number[];
    'prim/ok_num_function': number[];
    'prim/ok_syntax': number[];
    'comp/ok': number[];
    'comp/ok_without_param': number[];
    'comp/ok_function': number[];
    'comp/ok_device': number[];
    'comp/ok_num_function': number[];
    'comp/ok_syntax': number[];
    [key: string]: any;
};
export declare class SentenceEvaluatorStream extends Stream.Transform {
    private _parser;
    private _options;
    private _tokenizer;
    private _minibatch;
    constructor(parser: ParserClient | null, options: SentenceEvaluatorOptions);
    private _evaluate;
    private _flushMinibatch;
    private _pushExample;
    _transform(ex: SentenceExample, encoding: BufferEncoding, callback: (err: Error | null) => void): void;
    _flush(callback: (err: Error | null) => void): void;
}
interface CollectSentenceStatisticsOptions {
    minComplexity?: number;
    maxComplexity?: number;
    splitByDevice?: boolean;
}
export declare class CollectSentenceStatistics extends Stream.Writable {
    private _minComplexity;
    private _maxComplexity;
    private _splitByDevice;
    private _buffer;
    constructor(options?: CollectSentenceStatisticsOptions);
    _write(ex: ExampleEvaluationResult, encoding: BufferEncoding, callback: () => void): void;
    _final(callback: () => void): void;
    read(): Promise<Record<string, EvaluationResult>>;
}
export {};
