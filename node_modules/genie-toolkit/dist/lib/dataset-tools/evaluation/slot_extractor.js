"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const thingtalk_1 = require("thingtalk");
const assert_1 = __importDefault(require("assert"));
const I18n = __importStar(require("../../i18n"));
const entity_finder_1 = require("../../dialogue-agent/entity-linking/entity-finder");
const misc_utils_1 = require("../../utils/misc-utils");
/**
 * Convert a ThingTalk dialogue state to a set of MultiWOZ-style slots.
 */
class SlotExtractor {
    constructor(locale, tpClient, schemaRetriever, database, omittedSlots = ['train-name']) {
        this._database = database;
        this._tpClient = tpClient;
        this._schemas = schemaRetriever;
        this._omittedSlots = omittedSlots;
        this._tokenizer = I18n.get(locale).getTokenizer();
        this._cachedEntityMatches = new Map;
    }
    _isWellKnownEntity(entityType) {
        switch (entityType) {
            case 'tt:username':
            case 'tt:hashtag':
            case 'tt:picture':
            case 'tt:url':
            case 'tt:email_address':
            case 'tt:phone_number':
            case 'tt:path_name':
            case 'tt:function':
                return true;
            default:
                return false;
        }
    }
    _tokenizeSlot(value) {
        return this._tokenizer.tokenize(value).rawTokens.join(' ');
    }
    async _resolveEntity(value) {
        if (this._isWellKnownEntity(value.type)) {
            (0, assert_1.default)(value.value !== null, `Unexpected missing entity value "${value.value}" for a ${value.type} entity`);
            return { value: value.value, name: value.display || '', canonical: value.value };
        }
        const searchKey = value.display || value.value;
        if (!searchKey) {
            // the neural model produced an empty string
            return {
                value: '',
                name: '',
                canonical: ''
            };
        }
        const cacheKey = value.type + '/' + value.value + '/' + searchKey;
        let resolved = this._cachedEntityMatches.get(cacheKey);
        if (resolved)
            return resolved;
        if (this._database && this._database.has(value.type)) {
            // resolve as ID entity from the database (simulate issuing a query for it)
            const ids = this._database.get(value.type).map((entry) => {
                const id = entry.id;
                return {
                    value: id.value,
                    name: id.display,
                    canonical: id.display.toLowerCase()
                };
            });
            if (value.value) {
                for (const id of ids) {
                    if (id.value === value.value) {
                        resolved = id;
                        break;
                    }
                }
            }
            if (!resolved)
                resolved = (0, entity_finder_1.getBestEntityMatch)(searchKey, value.type, ids);
            this._cachedEntityMatches.set(cacheKey, resolved);
            return resolved;
        }
        if (value.type === 'tt:device') {
            if (value.value) {
                try {
                    const classDef = await this._schemas.getFullMeta(value.value);
                    value.display = classDef.nl_annotations.thingpedia_name || classDef.nl_annotations.canonical;
                }
                catch (e) {
                    // ignore errors if the device is not known
                }
                if (!value.display)
                    value.display = (0, misc_utils_1.cleanKind)(value.value);
                return {
                    value: value.value,
                    name: value.display || '',
                    canonical: this._tokenizer.tokenize(value.display).rawTokens.join(' ')
                };
            }
            const candidates = await this._tpClient.searchDevice(value.display);
            if (candidates.length === 0) {
                resolved = {
                    value: value.display || '',
                    name: value.display || '',
                    canonical: value.display || ''
                };
            }
            else {
                resolved = (0, entity_finder_1.getBestEntityMatch)(value.display, value.type, candidates.map((d) => ({
                    value: d.primary_kind,
                    name: d.name,
                    canonical: this._tokenizer.tokenize(d.name).rawTokens.join(' ')
                })));
            }
        }
        else {
            // resolve as regular Thingpedia entity
            const candidates = await this._safeLookupEntity(value.type, searchKey);
            if (candidates.data.length === 0) {
                // this entity has no NER
                resolved = {
                    value: value.value || value.display || '',
                    name: value.display || '',
                    canonical: value.display || ''
                };
            }
            else {
                resolved = (0, entity_finder_1.getBestEntityMatch)(searchKey, value.type, candidates.data);
            }
        }
        this._cachedEntityMatches.set(cacheKey, resolved);
        return resolved;
    }
    async _safeLookupEntity(type, searchKey) {
        try {
            return await this._tpClient.lookupEntity(type, searchKey);
        }
        catch (e) {
            if (typeof e.code === 'number') // http error
                return { data: [] };
            throw e;
        }
    }
    async _valueToSlot(value) {
        // HACK
        if (value instanceof thingtalk_1.Ast.ComputationValue)
            return this._valueToSlot(value.operands[0]);
        if (value instanceof thingtalk_1.Ast.EntityValue) {
            const resolved = await this._resolveEntity(value);
            if (resolved)
                return resolved.canonical;
            return this._tokenizeSlot(value.display || '');
        }
        if (value instanceof thingtalk_1.Ast.BooleanValue)
            return value.value ? 'yes' : 'no';
        if (value instanceof thingtalk_1.Ast.LocationValue) {
            if (value.value instanceof thingtalk_1.Ast.RelativeLocation)
                return value.value.relativeTag;
            if (value.value instanceof thingtalk_1.Ast.AbsoluteLocation)
                return this._tokenizeSlot(value.value.display || '');
            // unresolved
            (0, assert_1.default)(value.value instanceof thingtalk_1.Ast.UnresolvedLocation);
            return this._tokenizeSlot(value.value.name);
        }
        if (value instanceof thingtalk_1.Ast.TimeValue) {
            if (value.value instanceof thingtalk_1.Ast.RelativeTime)
                return value.value.relativeTag;
            return String(value.toJS()).toLowerCase();
        }
        if (value instanceof thingtalk_1.Ast.ContextRefValue)
            return 'context-' + value.name;
        if (value instanceof thingtalk_1.Ast.StringValue) {
            // "tokenize" the value, because the prediction will also be tokenized
            return this._tokenizeSlot(value.toJS());
        }
        if (value instanceof thingtalk_1.Ast.DateValue) {
            const date = value.value;
            if (date === null)
                return 'now';
            else if (date instanceof thingtalk_1.Ast.DateEdge)
                return date.edge + ' ' + date.unit;
            else if (date instanceof thingtalk_1.Ast.WeekDayDate)
                return date.weekday;
            else if (date instanceof thingtalk_1.Ast.DatePiece)
                return `${date.year}/${date.month}/${date.day}`;
        }
        if (value instanceof thingtalk_1.Ast.EventValue) {
            if (value.name === null)
                return '$event';
            else
                return '$' + value.name;
        }
        // everything else (time, currency, number, enum), use JS value
        return String(value.toJS()).toLowerCase();
    }
    async extractSlots(state) {
        const slotValues = {};
        let currentDomain;
        function nameToSlot(domain, name) {
            if (name === 'id' || name === domain)
                return domain + '-name';
            const slotKey = domain + '-' + name.replace(/_/g, '-');
            return slotKey;
        }
        // note: this function relies on the precise visit order, in which an invocation
        // is visited before the boolean expressions that use the output of that invocation
        state.visit(new class extends thingtalk_1.Ast.NodeVisitor {
            visitInvocation(invocation) {
                const selector = invocation.selector;
                (0, assert_1.default)(selector instanceof thingtalk_1.Ast.DeviceSelector);
                const device = selector.kind;
                const domain = device.substring(device.lastIndexOf('.') + 1).toLowerCase();
                currentDomain = domain;
                // delete all slots for this domain (they'll be set again right after)
                for (const arg of invocation.schema.iterateArguments()) {
                    if (arg.name === currentDomain) {
                        // do not erase the "id" slot just because we have an action!
                        (0, assert_1.default)(arg.type.isEntity);
                        continue;
                    }
                    const slotKey = nameToSlot(domain, arg.name);
                    delete slotValues[slotKey];
                }
                for (const in_param of invocation.in_params) {
                    if (in_param.value.isUndefined || in_param.value.isVarRef)
                        continue;
                    const slotKey = nameToSlot(domain, in_param.name);
                    slotValues[slotKey] = in_param.value;
                }
                // do not recurse
                return false;
            }
            visitDialogueHistoryItem(item) {
                // recurse only if this item comes from the user and not the agent
                return item.confirm !== 'proposed';
            }
            visitDontCareBooleanExpression(expr) {
                const slotKey = nameToSlot(currentDomain, expr.name);
                slotValues[slotKey] = new thingtalk_1.Ast.Value.Enum('dontcare');
                return false;
            }
            visitAtomBooleanExpression(expr) {
                if (expr.value.isUndefined || expr.value.isVarRef)
                    return false;
                const slotKey = nameToSlot(currentDomain, expr.name);
                if (expr.operator === 'in_array') // multiple values, pick the first one
                    slotValues[slotKey] = expr.value.value[0];
                else
                    slotValues[slotKey] = expr.value;
                return false;
            }
            visitNotBooleanExpression(expr) {
                // explicitly do not recurse into "not" operators
                return false;
            }
            visitOrBooleanExpression(expr) {
                // explicitly do not recurse into "or" operators
                // (unless they are an "or" of one operand)
                return expr.operands.length === 1;
            }
        });
        // remove slots that are not in multiwoz
        for (const slot of this._omittedSlots)
            delete slotValues[slot];
        // resolve entities and map Ast.Value to a string we can compare for equality
        const slotStrings = {};
        for (const key in slotValues)
            slotStrings[key] = await this._valueToSlot(slotValues[key]);
        return slotStrings;
    }
}
exports.default = SlotExtractor;
//# sourceMappingURL=slot_extractor.js.map