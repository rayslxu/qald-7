import * as ThingTalk from 'thingtalk';
import { Ast, Runtime } from 'thingtalk';
import NotificationFormatter from '../../dialogue-agent/notifications/formatter';
import type AppExecutor from './app_executor';
import type Engine from '../index';
export interface OutputDelegate {
    done(): void;
    output(outputType: string, outputValue: Record<string, unknown>): void;
    error(error: Error): void;
}
/**
 * Wrap a ThingTalk statement and provide access to the Engine.
 *
 * This is an implementation of {@link external:thingtalk.ExecEnvironment}
 * suitable for running with the Genie engine.
 *
 * @package
 */
export default class ExecWrapper extends Runtime.ExecEnvironment {
    engine: Engine;
    app: AppExecutor;
    format: NotificationFormatter;
    private _programId;
    private _outputDelegate;
    private _trigger;
    private _execCache;
    private _hooks;
    constructor(engine: Engine, app: AppExecutor, output: OutputDelegate);
    setOutput(delegate: OutputDelegate): void;
    get program_id(): ThingTalk.Builtin.Entity;
    /**
     * Retrieve the unique ID of the conversation associated with this execution
     * environment.
     *
     * This roughly corresponds to the ID of the session or speaker where the user
     * is issuing the command.
     */
    get conversation(): string | undefined;
    get locale(): string;
    get timezone(): string;
    endProgram(): void;
    stopTrigger(): void;
    private _wrapClearCache;
    loadContext(): never;
    invokeTimer(base: Date, interval: number, frequency: number): AsyncIterator<{
        __timestamp: number;
    }>;
    invokeAtTimer(time: ThingTalk.Builtin.Time[], expiration_date: Date | undefined): AsyncIterator<{
        __timestamp: number;
    }>;
    invokeOnTimer(date: Date[]): AsyncIterator<{
        __timestamp: number;
    }>;
    invokeMonitor(kind: string, attrs: Record<string, string>, fname: string, params: Record<string, unknown>, hints: Runtime.CompiledQueryHints): AsyncIterator<[string, Record<string, unknown> & {
        __timestamp: number;
    }]>;
    private _findInCache;
    clearGetCache(): void;
    private _getDevices;
    addExitProcedureHook(hook: () => void | Promise<void>): void;
    exitProcedure(procid: number, procname: string): Promise<void>;
    invokeQuery(kind: string, attrs: Record<string, string>, fname: string, params: Record<string, unknown>, hints: Runtime.CompiledQueryHints): AsyncIterable<[string, Record<string, unknown>]>;
    invokeDBQuery(kind: string, attrs: Record<string, string>, query: Ast.Program): AsyncIterable<[string, Record<string, unknown>]>;
    readState(stateId: number): Promise<any>;
    writeState(stateId: number, state: unknown): Promise<void>;
    invokeAction(kind: string, attrs: Record<string, string>, fname: string, params: Record<string, unknown>): AsyncIterable<[string, Record<string, unknown>]>;
    get icon(): string | null;
    reportError(message: string, error: Error & {
        code?: string;
    }): Promise<void>;
    output(outputType: string, outputValues: Record<string, unknown>): Promise<void>;
    formatEvent(outputType: string, outputValue: Record<string, unknown>, hint: string): Promise<string>;
}
