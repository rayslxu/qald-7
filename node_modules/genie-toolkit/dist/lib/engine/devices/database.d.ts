import * as Tp from 'thingpedia';
import { ObjectSet } from 'thingpedia';
import { SchemaRetriever } from 'thingtalk';
import { AbstractDatabase } from '../db';
import SyncManager from '../sync/manager';
/**
 * The collection of all configured Thingpedia devices.
 */
export default class DeviceDatabase extends ObjectSet.Base<Tp.BaseDevice> {
    private _factory;
    private schemas;
    private _devices;
    private _byDescriptor;
    private _syncManager;
    private _syncdb;
    private _subdeviceAddedListener;
    private _subdeviceRemovedListener;
    private _objectAddedHandler;
    private _objectDeletedHandler;
    private _isUpdatingState;
    private _updateTimer;
    /**
     * Construct the device database for this engine.
     *
     * There is only one device database instance per engine,
     * and it is accessible as {@link AssistantEngine.devices}.
     *
     * @param platform - the platform associated with the engine
     * @param syncManager - the tier manager to use for device synchronization
     * @param factory - the factory to load and construct Thingpedia devices
     * @param schemas - the schema retriever to typecheck ThingTalk code
     * @internal
     */
    constructor(platform: Tp.BasePlatform, db: AbstractDatabase, syncManager: SyncManager, factory: Tp.DeviceFactory, schemas: SchemaRetriever);
    loadOneDevice(serializedDevice: Tp.BaseDevice.DeviceState & {
        uniqueId?: string;
    }, addToDB: boolean): Promise<Tp.BaseDevice | null>;
    start(): Promise<void>;
    private _onObjectAdded;
    private _onObjectDeleted;
    stop(): Promise<void>;
    values(): Tp.BaseDevice[];
    private _getValuesOfExactKind;
    /**
     * Return all devices, and expand collection devices into concrete devices.
     *
     * The result of this call might change without an object-added/object-removed
     * event. Use DeviceView to track all the devices that match a selector.
     *
     * @param kind - if specified, only devices with `hasKind(kind)` will be returned.
     * */
    getAllDevices(kind?: string): Tp.BaseDevice[];
    getAllDevicesOfKind(kind?: string): Tp.BaseDevice[];
    getDeviceByDescriptor(descriptor: string): Tp.BaseDevice | undefined;
    private _notifySubdeviceAdded;
    private _notifySubdeviceRemoved;
    private _startSubdevices;
    private _stopSubdevices;
    private _notifyDeviceAdded;
    private _notifyDeviceRemoved;
    private _saveDevice;
    private _addDeviceInternal;
    addDevice(device: Tp.BaseDevice): Promise<void>;
    addSerialized(state: Tp.BaseDevice.DeviceState): Promise<Tp.BaseDevice>;
    addFromOAuth(kind: string): Promise<[string, Tp.BaseDevice.SessionMap]>;
    completeOAuth(kind: string, url: string, session: Record<string, string>): Promise<Tp.BaseDevice | null>;
    addFromDiscovery(kind: string, publicData: Record<string, unknown>, privateData: Record<string, unknown>): Promise<Tp.BaseDevice>;
    completeDiscovery(instance: Tp.BaseDevice, delegate: Tp.ConfigDelegate): Promise<Tp.BaseDevice>;
    addInteractively(kind: string, delegate: Tp.ConfigDelegate): Promise<Tp.BaseDevice>;
    private _removeDeviceFromCache;
    removeDevice(device: Tp.BaseDevice): Promise<void>;
    hasDevice(uniqueId: string): boolean;
    getDevice(uniqueId: string): Tp.BaseDevice | undefined;
    reloadDevice(device: Tp.BaseDevice): Promise<void>;
    getCachedDeviceClasses(): Promise<{
        name: string;
        version: number;
    }[]>;
    updateDevicesOfKind(kind: string): Promise<void>;
    private _reloadAllDevices;
    private _updateAll;
}
