export interface Hashable<T> {
    hash(): number;
    equals(other: T): boolean;
}
declare type PrimitiveType = string | number | boolean | null | undefined | symbol | bigint;
export declare type HashableType<Key> = PrimitiveType | Hashable<Key>;
/**
 * An implementation of the standard Map interface that supports custom
 * hashable objects.
 */
export declare class HashMap<Key extends HashableType<Key>, Value> {
    private store;
    private _size;
    constructor(iterable?: Iterable<[Key, Value]>);
    get size(): number;
    private _hash;
    private _equals;
    get(key: Key): Value | undefined;
    has(key: Key): boolean;
    set(key: Key, value: Value): this;
    delete(key: Key): boolean;
    clear(): void;
    entries(): IterableIterator<[Key, Value]>;
    forEach<ThisArg>(cb: (this: ThisArg, value: Value, key: Key, map: HashMap<Key, Value>) => void, thisArg: ThisArg): void;
    forEach(cb: (value: Value, key: Key, map: HashMap<Key, Value>) => void): void;
    [Symbol.iterator](): IterableIterator<[Key, Value]>;
    keys(): Iterable<Key>;
    values(): Iterable<Value>;
}
/**
 * A variant of HashMap that allows multiple values per key.
 */
export declare class HashMultiMap<Key extends HashableType<Key>, Value> {
    private _storage;
    private _size;
    constructor(elements?: Iterable<[Key, Value]>);
    keys(): Iterable<Key>;
    values(): Iterable<Value>;
    [Symbol.iterator](): IterableIterator<[Key, Value]>;
    entries(): Iterable<[Key, Value]>;
    get size(): number;
    clear(): void;
    delete(key: Key): void;
    deleteValue(key: Key, value: Value): void;
    forEach<T>(callback: (this: T, value: Value, key: Key, map: this) => void, thisArg: T): void;
    get(key: Key): readonly Value[];
    has(key: Key): boolean;
    put(key: Key, value: Value): number;
}
export {};
