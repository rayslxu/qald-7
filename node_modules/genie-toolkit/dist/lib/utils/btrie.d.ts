/// <reference types="node" />
import GrowableBuffer from './growable_buffer';
import { WILDCARD } from './trie';
export { WILDCARD };
declare class TrieBuilderLeafNode {
    value: string | undefined;
    private _size;
    private _dataPtrOffset;
    constructor();
    addValue(value: string, valueCombine: (one: string | undefined, two: string) => string): void;
    get size(): number;
    writeKey(buffer: GrowableBuffer, offset: number): number;
    writeData(buffer: GrowableBuffer, offset: number, valueMap: Map<string, number>): number;
}
declare class TrieBuilderIntermediateNode {
    key: string | typeof WILDCARD;
    children: Map<string | typeof WILDCARD, TrieBuilderIntermediateNode>;
    protected _childrenBeginPtrOffset: number;
    protected _leaf: TrieBuilderLeafNode | null;
    protected _isCompact: boolean;
    protected _size: number | undefined;
    protected _sortedChildren: TrieBuilderIntermediateNode[] | undefined;
    constructor(key: string | typeof WILDCARD);
    get size(): number;
    setValue(value: string, valueCombine: (one: string | undefined, two: string) => string): void;
    addChild(key: string | typeof WILDCARD): TrieBuilderIntermediateNode;
    getChild(key: string | typeof WILDCARD): TrieBuilderIntermediateNode | undefined;
    protected _sortChildren(): void;
    private _writeOwnKey;
    writeKey(buffer: GrowableBuffer, offset: number): number;
    writeData(buffer: GrowableBuffer, offset: number, valueMap: Map<string, number>): number;
    writeChildren(buffer: GrowableBuffer, offset: number): number;
}
declare class TrieBuilderRootNode extends TrieBuilderIntermediateNode {
    constructor();
    writeKey(buffer: GrowableBuffer, offset: number): number;
    writeChildren(buffer: GrowableBuffer, offset: number): number;
}
export declare class BTrieBuilder {
    private _valueCombine;
    root: TrieBuilderRootNode;
    constructor(valueCombine: (one: string | undefined, two: string) => string);
    insert(sequence: Array<string | typeof WILDCARD>, value: string): void;
    build(): Buffer;
}
/**
 * A B-Tree-based (immutable) Trie.
 *
 * This is a disk-based data structure for efficient storing of key-value pairs,
 * where the keys are sequences. It is designed to be memory-mappable, which is
 * memory efficient.
 *
 * The file is organized in _nodes_, which roughly represent the trie nodes.
 * Each node is identified by a 1 byte head, followed by a variable size.
 *
 * Four types of nodes exist:
 * - _data_ nodes contain the values mapped to by the Trie; they are formed by a 4 byte length
 *   followed by the data
 * - _leaf_ nodes indicate a complete key (end of string marker); they are 4 bytes
 *   that point to the corresponding data node
 * - _intermediate_ nodes indicate a portion of the key (a single word); they are composed
 *   of 1 byte key length, followed by the key, followed by 4 bytes of pointer and 2 bytes
 *   of length into a _key block_; the key block is the sequential list of children of this
 *   node
 * - _compact_ nodes are an optimization of intermediate nodes with only one child; compact
 *   nodes have 1 byte key length, followed by the key; the child is then emitted immediately
 *   after the compact node, without pointers
 */
export declare class BTrie {
    private _buffer;
    private _root;
    constructor(buffer: Buffer);
    _check(condition: boolean, ...data: unknown[]): void;
    private _skipNode;
    private _skipEntry;
    private _findKey;
    search(sequence: string[]): string | undefined;
}
