import * as Tp from 'thingpedia';
import { Ast, SchemaRetriever, Syntax } from 'thingtalk';
export interface ParseOptions {
    locale?: string;
    timezone: string | undefined;
    thingpediaClient: Tp.BaseClient | null;
    schemaRetriever?: SchemaRetriever;
    loadMetadata?: boolean;
}
export declare function parse(code: string, schemas: SchemaRetriever): Promise<Ast.Input>;
export declare function parse(code: string, options: ParseOptions): Promise<Ast.Input>;
export declare function parsePrediction(code: string | string[], entities: Syntax.EntityMap | Syntax.EntityResolver, options: ParseOptions, strict: true): Promise<Ast.Input>;
export declare function parsePrediction(code: string | string[], entities: Syntax.EntityMap | Syntax.EntityResolver, options: ParseOptions, strict?: boolean): Promise<Ast.Input | null>;
interface PredictionCandidate {
    code: string[];
}
export declare function parseAllPredictions(candidates: PredictionCandidate[], entities: Syntax.EntityMap, options: ParseOptions): Promise<Ast.Input[]>;
/**
 * Convert a program or dialogue state to a normalized sequence of tokens, suitable
 * to input to the neural network as context.
 */
export declare function serializeNormalized(program: Ast.Input | null, entities?: Syntax.EntityMap): [string[], Syntax.EntityMap];
interface SerializeOptions {
    locale: string;
    timezone: string | undefined;
    ignoreSentence?: boolean;
    compatibility?: string;
    includeEntityValue?: boolean;
}
/**
 * Convert a program or dialogue state to a sequence of tokens to predict.
 */
export declare function serializePrediction(program: Ast.Input, sentence: string | string[], entities: Syntax.EntityMap, options: SerializeOptions): string[];
export {};
