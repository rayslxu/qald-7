/// <reference types="node" />
import * as Stream from 'stream';
declare type WriteCallback = (err?: Error) => void;
declare class ArrayAccumulator<T> extends Stream.Writable implements Stream.Writable {
    private _buffer;
    constructor();
    _write(obj: T, encoding: BufferEncoding, callback: WriteCallback): void;
    read(): Promise<T[]>;
}
declare class SetAccumulator<T> extends Stream.Writable implements Stream.Writable {
    private _buffer;
    constructor();
    _write(obj: T, encoding: BufferEncoding, callback: WriteCallback): void;
    read(): Promise<Set<T>>;
}
declare class MapAccumulator<V, F extends keyof V> extends Stream.Writable implements Stream.Writable {
    _buffer: Map<V[F], V>;
    _field: F;
    constructor(field?: F);
    _write(obj: V, encoding: BufferEncoding, callback: WriteCallback): void;
    read(): Promise<Map<V[F], V>>;
}
declare class ArrayStream<T> extends Stream.Readable implements Stream.Readable {
    private _iterator;
    constructor(array: T[], options: Stream.ReadableOptions);
    _read(): void;
}
interface ChainStreamOptions extends Stream.ReadableOptions {
    separator?: string | Buffer;
}
declare class ChainStream extends Stream.Readable implements Stream.Readable {
    private _chain;
    private _separator?;
    private _i;
    constructor(chain: Stream.Readable[], options: ChainStreamOptions);
    _read(n: number): void;
}
declare function chain(streams: Stream.Readable[], options: ChainStreamOptions): ChainStream;
declare class CountStream<T> extends Stream.Duplex {
    private _buffer;
    private _N;
    private _i;
    private _reading;
    constructor();
    _read(): void;
    private _pushSome;
    _write(obj: T, encoding: BufferEncoding, callback: WriteCallback): void;
    _final(callback: WriteCallback): void;
}
export { ArrayAccumulator, ArrayStream, SetAccumulator, MapAccumulator, chain, CountStream, };
export declare function waitFinish(stream: NodeJS.WritableStream): Promise<void>;
export declare function waitEnd(stream: NodeJS.ReadableStream): Promise<void>;
