import BaseTokenizer from '../../i18n/tokenizer/base';
interface LanguagePack {
    locale: string;
    getTokenizer(): BaseTokenizer;
}
/**
 * Natural language template language that supports grammar-based constraints
 * to handle agreement in number, tense, gender, etc.
 *
 */
declare type FlagValue = string | number;
/**
 * The result of replacing placeholders in a template.
 *
 * This is a tree of strings or choices, each associated with flags.
 */
export declare abstract class ReplacedResult {
    static EMPTY: ReplacedResult;
    /**
     * Apply a flag constraint to this tree.
     *
     * Returns a constrained tree, or null if no possible set of choices
     * is valid.
     *
     */
    abstract constrain(flag: string, value: FlagValue): ReplacedResult | null;
    abstract chooseSample(rng: () => number): string;
    abstract chooseBest(): string;
}
export declare class ReplacedConcatenation extends ReplacedResult {
    text: Array<string | ReplacedResult>;
    constFlags: Record<string, FlagValue>;
    refFlags: Record<string, [number, string]>;
    constructor(text: Array<string | ReplacedResult>, constFlags: Record<string, FlagValue>, refFlags: Record<string, [number, string]>);
    toString(): string;
    constrain(flag: string, value: FlagValue): ReplacedResult | null;
    chooseSample(rng: () => number): string;
    chooseBest(): string;
}
export declare class ReplacedChoice extends ReplacedResult {
    choices: ReplacedResult[];
    constructor(choices: ReplacedResult[]);
    toString(): string;
    constrain(flag: string, value: FlagValue): ReplacedResult | null;
    chooseSample(rng: () => number): string;
    chooseBest(): string;
}
export declare class ReplacedList extends ReplacedResult {
    elements: ReplacedResult[];
    locale: string;
    listType: string | undefined;
    constructor(elements: ReplacedResult[], locale: string, listType: string | undefined);
    get length(): number;
    private _makeList;
    toString(): string;
    constrain(flag: string, value: FlagValue): ReplacedResult | null;
    chooseSample(rng: () => number): string;
    chooseBest(): string;
}
/**
 * An object that represents the value with which to replace a placeholder.
 */
export interface PlaceholderReplacement {
    value: any;
    text: ReplacedResult;
}
declare type PlaceholderConstraints = Record<number, Record<string, FlagValue>>;
interface ReplacementContext {
    replacements: Record<number, PlaceholderReplacement | undefined>;
    constraints: PlaceholderConstraints;
}
export declare abstract class Replaceable {
    private static _cache;
    static EMPTY: Replaceable;
    /**
     * Parse a template string into a replaceable object.
     */
    static parse(template: string): Replaceable;
    /**
     * Parse a template string into a replaceable object, and preprocess
     * it immediately.
     *
     * This method differs from {@link Replaceable.parse} because it will
     * cache the result so it is fast to call multiple times for the same string.
     */
    static get(template: string, langPack: LanguagePack, names: string[]): Replaceable;
    abstract visit(cb: (repl: Replaceable) => boolean): void;
    abstract preprocess(langPack: LanguagePack, placeholders: string[]): this;
    abstract optimize(constraints: PlaceholderConstraints): Replaceable | null;
    abstract replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * A named placeholder.
 *
 * A placeholder can be followed by an option. The meaning of the option is not
 * defined at this level.
 */
export declare class Placeholder extends Replaceable {
    param: string;
    key: string[];
    option: string;
    private _index;
    constructor(param: string, key?: string[], option?: string);
    toString(): string;
    visit(cb: (repl: Replaceable) => boolean): void;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    optimize(): this;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * A phrase that is already expressed as a replaced result.
 *
 * This is a Replaceable that does not contain any placeholder.
 */
export declare class ReplacedPhrase extends Replaceable {
    text: ReplacedResult;
    constructor(text: ReplacedResult);
    clone(): ReplacedPhrase;
    toString(): string;
    visit(cb: (repl: Replaceable) => boolean): void;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    optimize(): this;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * A piece of text with flags such as gender, number, tense, etc.
 *
 * In syntax, they are represented by free text followed by `[flag=value]`.
 * Examples:
 *
 * `actor [gender=masculine]`
 * `restaurants [plural=other]`
 */
export declare class Phrase extends Replaceable {
    text: string;
    flags: Record<string, string>;
    constructor(text: string, flags?: Record<string, string>);
    clone(): Phrase;
    toString(): string;
    toReplaced(): ReplacedConcatenation;
    visit(cb: (repl: Replaceable) => boolean): void;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    optimize(): this;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * Concatenation of multiple replaceable elements.
 *
 * The concatenation does not propagate the flags of the elements, but
 * it has its own set of flags.
 */
export declare class Concatenation extends Replaceable {
    children: Replaceable[];
    flags: Record<string, FlagValue>;
    refFlags: Record<string, [string | number, string]>;
    private _computedRefFlags;
    private _hasAnyFlag;
    constructor(children: Replaceable[], flags: Record<string, FlagValue>, refFlags: Record<string, [string | number, string]>);
    toString(): string;
    visit(cb: (repl: Replaceable) => boolean): void;
    optimize(constraints: PlaceholderConstraints): Concatenation | null;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * A phrase that has multiple equivalent variants.
 *
 * Different variants can set different flags, to account for gender,
 * plural, case, tense, mood, etc.
 */
export declare class Choice implements Replaceable {
    variants: Replaceable[];
    constructor(variants: Replaceable[]);
    toString(): string;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    optimize(constraints: PlaceholderConstraints): Replaceable | null;
    visit(cb: (repl: Replaceable) => boolean): void;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * A phrase that depends on a numeric value.
 *
 * The syntax is:
 * ```
 * ${param.key:plural:
 *    pluralname{variant}
 *    ...
 * }
 * ```
 *
 * Example:
 * ```
 * ${results.length:plural:
 *    one{restaurant}
 *    other{restaurants}
 * }
 */
export declare class Plural implements Replaceable {
    param: string;
    key: string[];
    type: Intl.PluralRuleType;
    variants: Record<string | number, Replaceable>;
    private _index;
    private _rules;
    constructor(param: string, key: string[], type: Intl.PluralRuleType, variants: Record<string | number, Replaceable>);
    toString(): string;
    visit(cb: (repl: Replaceable) => boolean): void;
    optimize(constraints: PlaceholderConstraints): Plural | null;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * A phrase that depends on an enumerated value.
 *
 * The syntax is:
 * ```
 * ${param.key:select:
 *    v1{variant}
 *    v2{variant}
 *    ...
 * }
 * ```
 *
 * Example:
 *
 * ```
 * ${status.value:select:
 *    sunny{The sun is shining}
 *    cloudy{The sun is covered by clouds}
 * }
 * ```
 */
export declare class ValueSelect implements Replaceable {
    param: string;
    key: string[];
    variants: Record<string, Replaceable>;
    private _index;
    constructor(param: string, key: string[], variants: Record<string, Replaceable>);
    toString(): string;
    visit(cb: (repl: Replaceable) => boolean): void;
    optimize(constraints: PlaceholderConstraints): ValueSelect | null;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
/**
 * A phrase that depends on a flag.
 *
 * The syntax is:
 * ```
 * ${param[key]:select:
 *    v1{variant}
 *    v2{variant}
 *    ...
 * }
 * ```
 * (which depends on a flag of the parameter)
 *
 * Example:
 *
 * ```
 * ${table[gender]:select:
 *    masculine{his}
 *    feminine{her}
 * }
 * ```
 */
export declare class FlagSelect implements Replaceable {
    param: string;
    flag: string;
    variants: Record<string, Replaceable>;
    private _index;
    constructor(param: string, flag: string, variants: Record<string, Replaceable>);
    toString(): string;
    visit(cb: (repl: Replaceable) => boolean): void;
    optimize(constraints: PlaceholderConstraints): Replaceable | null;
    preprocess(langPack: LanguagePack, placeholders: string[]): this;
    replace(ctx: ReplacementContext): ReplacedResult | null;
}
export {};
