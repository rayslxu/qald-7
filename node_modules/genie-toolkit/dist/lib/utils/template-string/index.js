"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Genie.
//
// Copyright 2019-2021 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FlagSelect = exports.ValueSelect = exports.Plural = exports.Choice = exports.Concatenation = exports.Phrase = exports.ReplacedPhrase = exports.Placeholder = exports.Replaceable = exports.ReplacedList = exports.ReplacedChoice = exports.ReplacedConcatenation = exports.ReplacedResult = void 0;
const random_1 = require("../../utils/random");
const TemplateGrammar = __importStar(require("./grammar"));
/**
 * The result of replacing placeholders in a template.
 *
 * This is a tree of strings or choices, each associated with flags.
 */
class ReplacedResult {
}
exports.ReplacedResult = ReplacedResult;
class EmptyReplacement extends ReplacedResult {
    constrain(flag, value) {
        return this;
    }
    chooseSample(rng) {
        return '';
    }
    chooseBest() {
        return '';
    }
}
ReplacedResult.EMPTY = new EmptyReplacement();
function whitespaceJoin(iterable, joiner = '') {
    joiner = joiner.trim();
    let buf = '';
    for (const element of iterable) {
        const string = (typeof element === 'string' ? element : String(element)).trim();
        if (!string)
            continue;
        if (buf) {
            buf += ' ';
            if (joiner) {
                buf += joiner;
                buf += ' ';
            }
        }
        buf += string;
    }
    return buf;
}
class ReplacedConcatenation extends ReplacedResult {
    constructor(text, constFlags, refFlags) {
        super();
        this.text = text;
        this.constFlags = constFlags;
        this.refFlags = refFlags;
    }
    toString() {
        const buf = this.text.map((t) => '{' + t + '}').join(' ');
        const flags = [];
        for (const flag in this.constFlags)
            flags.push(`${flag}=${this.constFlags[flag]}`);
        for (const flag in this.refFlags)
            flags.push(`${flag}=${this.refFlags[flag][0]}[${this.refFlags[flag][1]}]`);
        if (flags.length > 0)
            return buf + ` [${flags.join(',')}]`;
        else
            return buf;
    }
    constrain(flag, value) {
        if (flag in this.constFlags) {
            const ourValue = this.constFlags[flag];
            if (ourValue === value)
                return this;
            else
                return null;
        }
        if (flag in this.refFlags) {
            const [index, subflag] = this.refFlags[flag];
            const toConstrain = this.text[index];
            if (!(toConstrain instanceof ReplacedResult))
                return this;
            const constrained = toConstrain.constrain(subflag, value);
            if (constrained === null)
                return null;
            const newText = this.text.slice(0, index);
            newText.push(constrained);
            newText.push(...this.text.slice(index + 1));
            const newFlags = {};
            Object.assign(newFlags, this.constFlags);
            newFlags[flag] = value;
            const newRefFlags = {};
            Object.assign(newRefFlags, this.refFlags);
            delete newRefFlags[flag];
            return new ReplacedConcatenation(newText, newFlags, newRefFlags);
        }
        // no constraint at all
        return this;
    }
    chooseSample(rng) {
        const text = this.text.map((t) => typeof t === 'string' ? t : t.chooseSample(rng));
        return whitespaceJoin(text);
    }
    chooseBest() {
        const text = this.text.map((t) => typeof t === 'string' ? t : t.chooseBest());
        return whitespaceJoin(text);
    }
}
exports.ReplacedConcatenation = ReplacedConcatenation;
class ReplacedChoice extends ReplacedResult {
    constructor(choices) {
        super();
        this.choices = choices;
    }
    toString() {
        return `{${this.choices.join('|')}}`;
    }
    constrain(flag, value) {
        const constrained = this.choices.map((c) => c.constrain(flag, value))
            .filter((x) => x !== null);
        if (constrained.length === 0)
            return null;
        if (constrained.length === 1)
            return constrained[0];
        return new ReplacedChoice(constrained);
    }
    chooseSample(rng) {
        return (0, random_1.uniform)(this.choices, rng).chooseSample(rng);
    }
    chooseBest() {
        return this.choices[0].chooseBest();
    }
}
exports.ReplacedChoice = ReplacedChoice;
class ReplacedList extends ReplacedResult {
    constructor(elements, locale, listType) {
        super();
        this.elements = elements;
        this.locale = locale;
        this.listType = listType;
    }
    get length() {
        return this.elements.length;
    }
    _makeList(elements, listType) {
        if (listType === 'disjunction' ||
            listType === 'conjunction') {
            const strings = elements.map((el) => String(el));
            const formatted = new Intl.ListFormat(this.locale, { type: listType })
                .formatToParts(strings);
            return whitespaceJoin(formatted.map((el) => el.type === 'literal' ? el.value.trim() : el.value));
        }
        return whitespaceJoin(elements, this.listType);
    }
    toString() {
        return this._makeList(this.elements, 'conjunction');
    }
    constrain(flag, value) {
        const mapped = [];
        for (const el of this.elements) {
            const constrained = el.constrain(flag, value);
            if (constrained === null)
                return null;
            mapped.push(el);
        }
        if (flag === 'list_type') {
            if (this.listType === undefined)
                return new ReplacedList(mapped, this.locale, String(value));
            else if (this.listType !== value)
                return null;
        }
        return new ReplacedList(mapped, this.locale, this.listType);
    }
    chooseSample(rng) {
        const listType = this.listType === undefined ?
            ((0, random_1.coin)(0.5, rng) ? 'conjunction' : 'disjunction') : this.listType;
        return this._makeList(this.elements.map((el) => el.chooseSample(rng)), listType);
    }
    chooseBest() {
        var _a;
        return this._makeList(this.elements.map((el) => el.chooseBest()), (_a = this.listType) !== null && _a !== void 0 ? _a : 'conjunction');
    }
}
exports.ReplacedList = ReplacedList;
class Replaceable {
    /**
     * Parse a template string into a replaceable object.
     */
    static parse(template) {
        return TemplateGrammar.parse(template);
    }
    /**
     * Parse a template string into a replaceable object, and preprocess
     * it immediately.
     *
     * This method differs from {@link Replaceable.parse} because it will
     * cache the result so it is fast to call multiple times for the same string.
     */
    static get(template, langPack, names) {
        const cacheKey = langPack.locale + '/' + template;
        const cached = Replaceable._cache.get(cacheKey);
        if (cached)
            return cached;
        const parsed = TemplateGrammar.parse(template);
        parsed.preprocess(langPack, names);
        Replaceable._cache.set(cacheKey, parsed);
        return parsed;
    }
}
exports.Replaceable = Replaceable;
Replaceable._cache = new Map();
/**
 * A named placeholder.
 *
 * A placeholder can be followed by an option. The meaning of the option is not
 * defined at this level.
 */
class Placeholder extends Replaceable {
    constructor(param, key = [], option = '') {
        super();
        this.param = param;
        this.key = key;
        this.option = option;
        this._index = undefined;
    }
    toString() {
        return `\${${this.param}${this.key.length > 0 ? '.' + this.key.join('.') : ''}`
            + (this.option ? `:${this.option}` : '') + '}';
    }
    visit(cb) {
        cb(this);
    }
    preprocess(langPack, placeholders) {
        try {
            const param = [this.param, ...this.key].join('.');
            this._index = getPlaceholderIndex(placeholders, param);
        }
        catch (e) {
            this._index = getPlaceholderIndex(placeholders, this.param);
        }
        return this;
    }
    optimize() {
        return this;
    }
    replace(ctx) {
        const param = ctx.replacements[this._index];
        if (!param)
            return null;
        if (this.key.length > 0) {
            const replacement = get(param.value, this.key);
            if (replacement === null || replacement === undefined)
                return null;
            return new ReplacedConcatenation([String(replacement)], {}, {});
        }
        else {
            let replacement = param.text;
            const paramConstraints = ctx.constraints[this._index] || {};
            for (const flag in paramConstraints) {
                const value = paramConstraints[flag];
                const maybeReplacement = replacement.constrain(flag, value);
                if (maybeReplacement === null)
                    return null;
                replacement = maybeReplacement;
            }
            return replacement;
        }
    }
}
exports.Placeholder = Placeholder;
/**
 * A phrase that is already expressed as a replaced result.
 *
 * This is a Replaceable that does not contain any placeholder.
 */
class ReplacedPhrase extends Replaceable {
    constructor(text) {
        super();
        this.text = text;
    }
    clone() {
        return new ReplacedPhrase(this.text);
    }
    toString() {
        return this.text.toString();
    }
    visit(cb) {
        cb(this);
    }
    preprocess(langPack, placeholders) {
        return this;
    }
    optimize() {
        return this;
    }
    replace(ctx) {
        return this.text;
    }
}
exports.ReplacedPhrase = ReplacedPhrase;
Replaceable.EMPTY = new ReplacedPhrase(ReplacedResult.EMPTY);
function templateEscape(str) {
    return str.replace(/[${}|[\]\\]/g, '\\$0');
}
/**
 * A piece of text with flags such as gender, number, tense, etc.
 *
 * In syntax, they are represented by free text followed by `[flag=value]`.
 * Examples:
 *
 * `actor [gender=masculine]`
 * `restaurants [plural=other]`
 */
class Phrase extends Replaceable {
    constructor(text, flags = {}) {
        super();
        this.text = text;
        this.flags = flags;
    }
    clone() {
        const flags = {};
        Object.assign(flags, this.flags);
        return new Phrase(this.text, flags);
    }
    toString() {
        const text = templateEscape(this.text);
        const flags = [];
        for (const flag in this.flags)
            flags.push(`${flag}=${this.flags[flag]}`);
        if (flags.length > 0)
            return `${text} [${flags.join(',')}]`;
        else
            return text;
    }
    toReplaced() {
        return new ReplacedConcatenation([this.text], this.flags, {});
    }
    visit(cb) {
        cb(this);
    }
    preprocess(langPack, placeholders) {
        const tokenizer = langPack.getTokenizer();
        this.text = tokenizer.tokenize(this.text).rawTokens.join(' ');
        return this;
    }
    optimize() {
        return this;
    }
    replace(ctx) {
        return new ReplacedConcatenation([this.text], this.flags, {});
    }
}
exports.Phrase = Phrase;
function mergeConstraints(into, newConstraints) {
    for (const placeholder in newConstraints) {
        if (!(placeholder in into))
            into[placeholder] = {};
        for (const flag in newConstraints[placeholder])
            into[placeholder][flag] = newConstraints[placeholder][flag];
    }
}
/**
 * Concatenation of multiple replaceable elements.
 *
 * The concatenation does not propagate the flags of the elements, but
 * it has its own set of flags.
 */
class Concatenation extends Replaceable {
    constructor(children, flags, refFlags) {
        super();
        this.children = children;
        this.flags = flags;
        this.refFlags = refFlags;
        this._computedRefFlags = {};
        this._hasAnyFlag = Object.keys(flags).length + Object.keys(refFlags).length > 0;
    }
    toString() {
        const buf = this.children.join(' ');
        const flags = [];
        for (const flag in this.flags)
            flags.push(`${flag}=${this.flags[flag]}`);
        for (const flag in this.refFlags)
            flags.push(`${flag}=${this.refFlags[flag][0]}[${this.refFlags[flag][1]}]`);
        if (flags.length > 0)
            return buf + ` [${flags.join(',')}]`;
        else
            return buf;
    }
    visit(cb) {
        if (!cb(this))
            return;
        for (const c of this.children)
            c.visit(cb);
    }
    optimize(constraints) {
        const optimized = [];
        let anyChange = false;
        for (const c of this.children) {
            const copt = c.optimize(constraints);
            if (copt === null)
                return null;
            optimized.push(copt);
            anyChange = anyChange || c !== copt;
        }
        if (!anyChange)
            return this;
        const optconcat = new Concatenation(optimized, this.flags, this.refFlags);
        optconcat._computedRefFlags = this._computedRefFlags;
        return optconcat;
    }
    preprocess(langPack, placeholders) {
        for (const c of this.children)
            c.preprocess(langPack, placeholders);
        for (const ourFlag in this.refFlags) {
            const [placeholder, theirFlag] = this.refFlags[ourFlag];
            if (typeof placeholder === 'number') {
                if (placeholder < 0 || placeholder >= this.children.length)
                    throw new Error(`Invalid ref-flag [${ourFlag}=${placeholder}[${theirFlag}]]`);
                this._computedRefFlags[ourFlag] = [placeholder, theirFlag];
            }
            else {
                let found = -1;
                for (let i = 0; i < this.children.length; i++) {
                    const c = this.children[i];
                    if (c instanceof Placeholder && c.param === placeholder) {
                        found = i;
                        break;
                    }
                }
                if (found < 0)
                    throw new Error(`Invalid ref-flag [${ourFlag}=${placeholder}[${theirFlag}]], must refer to a placeholder immediately used in the same concatenation expression`);
                this._computedRefFlags[ourFlag] = [found, theirFlag];
            }
        }
        return this;
    }
    replace(ctx) {
        const replaced = [];
        for (const child of this.children) {
            const childReplacement = child.replace(ctx);
            if (childReplacement === null)
                return null;
            // if we don't have any flags, we can flatten the replacement
            // if we do have flags, we cannot because it will change the meaning of the ref flags
            if (!this._hasAnyFlag && childReplacement instanceof ReplacedConcatenation)
                replaced.push(...childReplacement.text);
            else
                replaced.push(childReplacement);
        }
        return new ReplacedConcatenation(replaced, this.flags, this._computedRefFlags);
    }
}
exports.Concatenation = Concatenation;
/**
 * A phrase that has multiple equivalent variants.
 *
 * Different variants can set different flags, to account for gender,
 * plural, case, tense, mood, etc.
 */
class Choice {
    constructor(variants) {
        this.variants = variants;
    }
    toString() {
        return `{${this.variants.join('|')}}`;
    }
    preprocess(langPack, placeholders) {
        for (const v of this.variants)
            v.preprocess(langPack, placeholders);
        return this;
    }
    optimize(constraints) {
        const optimized = [];
        let anyChange = false;
        for (const v of this.variants) {
            const vopt = v.optimize(constraints);
            if (vopt === null) {
                anyChange = true;
                continue;
            }
            optimized.push(vopt);
            anyChange = anyChange || v !== vopt;
        }
        if (optimized.length === 0)
            return null;
        else if (optimized.length === 1)
            return optimized[0];
        if (!anyChange)
            return this;
        return new Choice(optimized);
    }
    visit(cb) {
        if (!cb(this))
            return;
        for (const v of this.variants)
            v.visit(cb);
    }
    replace(ctx) {
        const variants = [];
        for (const v of this.variants) {
            const replaced = v.replace(ctx);
            if (replaced === null)
                continue;
            variants.push(replaced);
        }
        if (variants.length === 0)
            return null;
        else if (variants.length === 1)
            return variants[0];
        else
            return new ReplacedChoice(variants);
    }
}
exports.Choice = Choice;
function get(value, keys) {
    for (const key of keys) {
        value = value[key];
        if (value === null || value === undefined)
            return value;
    }
    return value;
}
function getPlaceholderIndex(placeholders, toFind) {
    const index = placeholders.indexOf(toFind);
    if (index < 0)
        throw new TypeError(`Invalid placeholder \${${toFind}}, allowed placeholders are: ${placeholders.join(', ')}`);
    return index;
}
/**
 * A phrase that depends on a numeric value.
 *
 * The syntax is:
 * ```
 * ${param.key:plural:
 *    pluralname{variant}
 *    ...
 * }
 * ```
 *
 * Example:
 * ```
 * ${results.length:plural:
 *    one{restaurant}
 *    other{restaurants}
 * }
 */
class Plural {
    constructor(param, key, type, variants) {
        this.param = param;
        this.key = key;
        this.type = type;
        this.variants = variants;
        this._index = undefined;
        this._rules = undefined;
    }
    toString() {
        let buf = `\${${this.param}${this.key.length > 0 ? '.' + this.key.join('.') : ''}:${this.type === 'cardinal' ? 'plural' : this.type}:`;
        for (const variant in this.variants)
            buf += `${typeof variant === 'number' ? '=' + variant : variant}{${this.variants[variant]}}`;
        buf += `}`;
        return buf;
    }
    visit(cb) {
        if (!cb(this))
            return;
        for (const v in this.variants)
            this.variants[v].visit(cb);
    }
    optimize(constraints) {
        const optimized = {};
        let anyVariant = false;
        let anyChange = false;
        for (const v in this.variants) {
            const vopt = this.variants[v].optimize(constraints);
            if (vopt === null) {
                anyChange = true;
                continue;
            }
            optimized[v] = vopt;
            anyVariant = true;
            anyChange = anyChange || this.variants[v] !== vopt;
        }
        if (!anyVariant)
            return null;
        if (!anyChange)
            return this;
        const optthis = new Plural(this.param, this.key, this.type, optimized);
        optthis._index = this._index;
        optthis._rules = this._rules;
        return optthis;
    }
    preprocess(langPack, placeholders) {
        for (const v in this.variants)
            this.variants[v].preprocess(langPack, placeholders);
        this._index = getPlaceholderIndex(placeholders, this.param);
        this._rules = new Intl.PluralRules(langPack.locale, { type: this.type });
        return this;
    }
    replace(ctx) {
        const param = ctx.replacements[this._index];
        if (!param)
            return null;
        const value = get(param.value, this.key);
        if (value === null || value === undefined)
            return null;
        const number = Number(value);
        if (number in this.variants)
            return this.variants[number].replace(ctx);
        const variant = this._rules.select(number);
        if (variant in this.variants)
            return this.variants[variant].replace(ctx);
        else
            return null;
    }
}
exports.Plural = Plural;
/**
 * A phrase that depends on an enumerated value.
 *
 * The syntax is:
 * ```
 * ${param.key:select:
 *    v1{variant}
 *    v2{variant}
 *    ...
 * }
 * ```
 *
 * Example:
 *
 * ```
 * ${status.value:select:
 *    sunny{The sun is shining}
 *    cloudy{The sun is covered by clouds}
 * }
 * ```
 */
class ValueSelect {
    constructor(param, key, variants) {
        this.param = param;
        this.key = key;
        this.variants = variants;
        this._index = undefined;
    }
    toString() {
        let buf = `\${${this.param}${this.key.length > 0 ? '.' + this.key.join('.') : ''}:select:`;
        for (const variant in this.variants)
            buf += `${variant}{${this.variants[variant]}}`;
        buf += `}`;
        return buf;
    }
    visit(cb) {
        if (!cb(this))
            return;
        for (const v in this.variants)
            this.variants[v].visit(cb);
    }
    optimize(constraints) {
        const optimized = {};
        let anyVariant = false;
        let anyChange = false;
        for (const v in this.variants) {
            const vopt = this.variants[v].optimize(constraints);
            if (vopt === null) {
                anyChange = true;
                continue;
            }
            optimized[v] = vopt;
            anyVariant = true;
            anyChange = anyChange || this.variants[v] !== vopt;
        }
        if (!anyVariant)
            return null;
        if (!anyChange)
            return this;
        const optthis = new ValueSelect(this.param, this.key, optimized);
        optthis._index = this._index;
        return optthis;
    }
    preprocess(langPack, placeholders) {
        for (const v in this.variants)
            this.variants[v].preprocess(langPack, placeholders);
        this._index = getPlaceholderIndex(placeholders, this.param);
        return this;
    }
    replace(ctx) {
        const param = ctx.replacements[this._index];
        if (!param)
            return null;
        const value = String(get(param.value, this.key));
        if (value in this.variants)
            return this.variants[value].replace(ctx);
        else if ('_' in this.variants)
            return this.variants['_'].replace(ctx);
        else
            return null;
    }
}
exports.ValueSelect = ValueSelect;
/**
 * A phrase that depends on a flag.
 *
 * The syntax is:
 * ```
 * ${param[key]:select:
 *    v1{variant}
 *    v2{variant}
 *    ...
 * }
 * ```
 * (which depends on a flag of the parameter)
 *
 * Example:
 *
 * ```
 * ${table[gender]:select:
 *    masculine{his}
 *    feminine{her}
 * }
 * ```
 */
class FlagSelect {
    constructor(param, flag, variants) {
        this.param = param;
        this.flag = flag;
        this.variants = variants;
        this._index = undefined;
    }
    toString() {
        let buf = `\${${this.param}[${this.flag}]:select:`;
        for (const variant in this.variants)
            buf += `${variant}{${this.variants[variant]}}`;
        buf += `}`;
        return buf;
    }
    visit(cb) {
        if (!cb(this))
            return;
        for (const v in this.variants)
            this.variants[v].visit(cb);
    }
    optimize(constraints) {
        // check if we already have a constraint on this param
        if (constraints[this._index] && this.flag in constraints[this._index]) {
            const constraint = constraints[this._index][this.flag];
            if (!this.variants[constraint])
                return null;
            return this.variants[constraint].optimize(constraints);
        }
        const optimized = {};
        let anyVariant = false;
        for (const v in this.variants) {
            // make a new replacement context with the added constraint on this
            // placeholder
            // the constraint will be propagated down to where this placeholder is
            // used, and will be applied to the replacement of the placeholder
            const newConstraints = {};
            mergeConstraints(newConstraints, constraints);
            mergeConstraints(newConstraints, { [this._index]: { [this.flag]: v } });
            const vopt = this.variants[v].optimize(newConstraints);
            if (vopt === null)
                continue;
            optimized[v] = vopt;
            anyVariant = true;
        }
        if (!anyVariant)
            return null;
        const optthis = new FlagSelect(this.param, this.flag, optimized);
        optthis._index = this._index;
        return optthis;
    }
    preprocess(langPack, placeholders) {
        for (const v in this.variants)
            this.variants[v].preprocess(langPack, placeholders);
        this._index = getPlaceholderIndex(placeholders, this.param);
        return this;
    }
    replace(ctx) {
        // check if we already have a constraint on this param
        if (ctx.constraints[this._index] && this.flag in ctx.constraints[this._index]) {
            const constraint = ctx.constraints[this._index][this.flag];
            if (!this.variants[constraint])
                return null;
            return this.variants[constraint].replace(ctx);
        }
        const variants = [];
        for (const v in this.variants) {
            // make a new replacement context with the added constraint on this
            // placeholder
            // the constraint will be propagated down to where this placeholder is
            // used, and will be applied to the replacement of the placeholder
            const newCtx = {
                replacements: ctx.replacements,
                constraints: {}
            };
            mergeConstraints(newCtx.constraints, ctx.constraints);
            mergeConstraints(newCtx.constraints, { [this._index]: { [this.flag]: v } });
            const replaced = this.variants[v].replace(newCtx);
            if (replaced === null)
                continue;
            variants.push(replaced);
        }
        if (variants.length === 0)
            return null;
        else if (variants.length === 1)
            return variants[0];
        else
            return new ReplacedChoice(variants);
    }
}
exports.FlagSelect = FlagSelect;
//# sourceMappingURL=index.js.map