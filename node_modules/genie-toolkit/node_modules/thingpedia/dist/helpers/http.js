"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Thingpedia
//
// Copyright 2016-2019 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestStream = exports.getStream = exports.postStream = exports.post = exports.get = exports.request = exports.HTTPError = void 0;
const assert_1 = __importDefault(require("assert"));
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const Url = __importStar(require("url"));
/**
 * HTTP Helpers.
 *
 * @module
 */
function getModule(parsed) {
    if (parsed.protocol === 'https:')
        return https;
    else
        return http;
}
const DEFAULT_TIMEOUT = 30000; // 30 seconds
class HTTPError extends Error {
    constructor(statusCode, url, data) {
        super('Unexpected HTTP error ' + statusCode + ' in request to ' + url);
        this.code = statusCode;
        this.url = url;
        this.detail = data;
    }
}
exports.HTTPError = HTTPError;
function httpRequestStream(url, method, data, options_, uploadStream, downloadStream, downloadRaw, attemptedOAuth2 = false) {
    var _a;
    const options = options_ || {};
    let parsed = Url.parse(url);
    const proxy = process.env.THINGENGINE_PROXY;
    if (proxy && (!parsed.port || parsed.port === '80' || parsed.port === '443')) {
        parsed = Url.parse(proxy);
        parsed.path = url;
    }
    parsed.method = method;
    parsed.headers = {};
    let oauth2 = null;
    if (options.auth) {
        parsed.headers['Authorization'] = options.auth;
    }
    else if (options.useOAuth2) {
        oauth2 = options.useOAuth2.queryInterface('oauth2');
        if (oauth2 !== null) {
            const authMethod = options.authMethod || 'Bearer';
            parsed.headers['Authorization'] = authMethod + ' ' + oauth2.accessToken;
        }
    }
    if (options.accept)
        parsed.headers['Accept'] = options.accept;
    if (options.dataContentType)
        parsed.headers['Content-Type'] = options.dataContentType;
    if (options['user-agent'])
        parsed.headers['User-Agent'] = options['user-agent'];
    else // add a default user agent
        parsed.headers['User-Agent'] = 'Thingpedia/1.0.0 nodejs/' + process.version;
    if (options.extraHeaders)
        Object.assign(parsed.headers, options.extraHeaders);
    if (options.debug === undefined)
        options.debug = true;
    parsed.timeout = (_a = options.timeout) !== null && _a !== void 0 ? _a : DEFAULT_TIMEOUT;
    const ignoreErrors = !!options.ignoreErrors;
    return new Promise((callback, errback) => {
        const req = getModule(parsed).request(parsed, (res) => {
            if ((options.followRedirects === true || options.followRedirects === undefined) &&
                (res.statusCode === 302 || res.statusCode === 301 ||
                    res.statusCode === 308 || res.statusCode === 307)) {
                res.resume();
                const location = res.headers['location'];
                assert_1.default(location);
                const redirect = Url.resolve(url, location);
                callback(httpRequestStream(redirect, method, data, options, uploadStream, downloadStream, downloadRaw));
                return;
            }
            if ((options.followRedirects === true || options.followRedirects === undefined) &&
                res.statusCode === 303) {
                res.resume();
                const location = res.headers['location'];
                assert_1.default(location);
                const redirect = Url.resolve(url, location);
                callback(httpRequestStream(redirect, 'GET', null, options, false, downloadStream, downloadRaw));
                return;
            }
            if (!ignoreErrors && res.statusCode === 401 && oauth2 !== null && !attemptedOAuth2 && oauth2.refreshToken) {
                res.resume();
                console.log('Refreshing OAuth 2 credentials for failure in request to ' + url);
                callback(oauth2.refreshCredentials().then(() => httpRequestStream(url, method, data, options, uploadStream, downloadStream, downloadRaw, true)));
                return;
            }
            if (!ignoreErrors && res.statusCode >= 300) {
                let data = '';
                res.setEncoding('utf8');
                res.on('data', (chunk) => {
                    data += chunk;
                });
                res.on('end', () => {
                    if (options.debug && (res.statusCode !== 301 && res.statusCode !== 302 && res.statusCode !== 303))
                        console.log('HTTP request failed: ' + data);
                    const error = new HTTPError(res.statusCode, url, data);
                    if (res.statusCode >= 300 && res.statusCode < 400) {
                        const location = res.headers['location'];
                        assert_1.default(location);
                        error.redirect = Url.resolve(url, location);
                    }
                    errback(error);
                });
                return;
            }
            if (downloadStream) {
                callback(res);
            }
            else {
                if (downloadRaw) {
                    const data = [];
                    let len = 0;
                    res.on('data', (chunk) => {
                        data.push(chunk);
                        len += chunk.length;
                    });
                    res.on('end', () => {
                        callback([Buffer.concat(data, len), res.headers['content-type']]);
                    });
                }
                else {
                    let data = '';
                    res.setEncoding('utf8');
                    res.on('data', (chunk) => {
                        data += chunk;
                    });
                    res.on('end', () => {
                        callback(data);
                    });
                }
            }
        });
        req.on('timeout', () => {
            req.destroy();
        });
        req.on('error', (err) => {
            errback(err);
        });
        if (data) {
            if (uploadStream)
                data.pipe(req);
            else
                req.end(data);
        }
        else {
            req.end();
        }
    });
}
function request(url, method, data, options = {}) {
    return httpRequestStream(url, method, data, options, false, false, !!options.raw);
}
exports.request = request;
function get(url, options = {}) {
    return httpRequestStream(url, 'GET', null, options, false, false, !!options.raw);
}
exports.get = get;
function post(url, data, options = {}) {
    return httpRequestStream(url, 'POST', data, options, false, false, !!options.raw);
}
exports.post = post;
function postStream(url, data, options = {}) {
    return httpRequestStream(url, 'POST', data, options, true, false, !!options.raw);
}
exports.postStream = postStream;
function httpDownloadStream(url, method, data, options) {
    return httpRequestStream(url, method, data, options, false, true, false);
}
/**
 * Perform a streaming GET request.
 *
 *
 * The result is the [`http.IncomingMessage`](https://nodejs.org/api/http.html#http_class_http_incomingmessage)
 * from the underlying nodejs HTTP API. The result is also a `stream.Readable` and can be used as such.
 *
 * @param {string} url - the URL to retrieve
 * @param {Object} [options] - request options
 * @param {string} [options.auth] - the value of `Authorization` header
 * @param {string} [options.accept] - the value of `Accept` header
 * @param {BaseDevice} [options.useOAuth2] - if set, the `Authorization` header will be computed for the passed
 *                                           device based on the OAuth 2.0 standard; using this option also enables
 *                                           automatic refresh token handling (if the refresh token exists); this
 *                                           option is ignored if `auth` is also set
 * @param {string} [options.authMethod=Bearer] - set this to override the prefix of the `Authorization` header;
 *                                        this option is ignored unless `useOAuth2` is set
 * @param {string} [options.user-agent] - set the `User-Agent` header; if unset a default user agent is used
 * @param {Object.<string,string>} [options.extraHeaders] - other request headers to set
 * @param {boolean} [options.ignoreErrors=false] - set to `true` to ignore errors (HTTP statuses 300 and higher)
 * @param {boolean} [options.followRedirects=true] - set to `false` to disable automatic handling of HTTP redirects (status 301, 302 and 303)
 * @return {Promise<http.IncomingMessage>} the server response
 */
function getStream(url, options) {
    return httpDownloadStream(url, 'GET', null, options);
}
exports.getStream = getStream;
/**
 * Perform a streaming HTTP request with a custom method.
 *
 * @param {string} url - the URL to POST to
 * @param {string} method - the HTTP method to use
 * @param {string|null} data - the content of the request body; you can pass `null` for an empty body
 * @param {Object} [options] - request options
 * @param {string} [options.dataContentType] - the value of the `Content-Type` request header
 * @param {string} [options.auth] - the value of `Authorization` header
 * @param {string} [options.accept] - the value of `Accept` header
 * @param {BaseDevice} [options.useOAuth2] - if set, the `Authorization` header will be computed for the passed
 *                                           device based on the OAuth 2.0 standard; using this option also enables
 *                                           automatic refresh token handling (if the refresh token exists); this
 *                                           option is ignored if `auth` is also set
 * @param {string} [options.authMethod=Bearer] - set this to override the prefix of the `Authorization` header;
 *                                        this option is ignored unless `useOAuth2` is set
 * @param {string} [options.user-agent] - set the `User-Agent` header; if unset a default user agent is used
 * @param {Object.<string,string>} [options.extraHeaders] - other request headers to set
 * @param {boolean} [options.ignoreErrors=false] - set to `true` to ignore errors (HTTP statuses 300 and higher)
 * @param {boolean} [options.followRedirects=true] - set to `false` to disable automatic handling of HTTP redirects (status 301, 302 and 303)
 * @param {boolean} [options.raw=false] - return the binary response body instead of converting to a string
 * @return {Promise<string>|Promise<Array>} either the string response body, or a tuple with `Buffer` and content type.
 */
function requestStream(url, method, data, options = {}) {
    return httpRequestStream(url, method, data, options, false, true, false);
}
exports.requestStream = requestStream;
//# sourceMappingURL=http.js.map