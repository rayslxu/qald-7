"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Thingpedia
//
// Copyright 2019 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPollInterval = exports.formatString = exports.parseGenericResponse = exports.findMixinArg = exports.getMixinArgs = exports.splitpropchain = void 0;
const string_interp_1 = __importDefault(require("string-interp"));
const thingtalk_1 = require("thingtalk");
/**
  Split a textual chain of properties separated with . into an array of property names.

  Handles \ as escape character.

*/
function splitpropchain(propchainstring) {
    const chain = [];
    let buffer = '';
    let escape = false;
    const reg = /[\\.]/g;
    let match = reg.exec(propchainstring);
    let i = 0;
    while (match !== null) {
        if (match.index > i) {
            if (escape)
                escape = false;
            buffer += propchainstring.substring(i, match.index);
        }
        if (match[0] === '\\') {
            if (escape) {
                buffer += '\\';
                escape = false;
            }
            else {
                escape = true;
            }
        }
        else if (match[0] === '.') {
            if (escape) {
                buffer += '.';
                escape = false;
            }
            else {
                chain.push(buffer);
                buffer = '';
            }
        }
        i = reg.lastIndex;
        match = reg.exec(propchainstring);
    }
    if (i < propchainstring.length)
        buffer += propchainstring.substring(i, propchainstring.length);
    chain.push(buffer);
    return chain;
}
exports.splitpropchain = splitpropchain;
function get(obj, propchain) {
    for (const prop of splitpropchain(propchain))
        obj = obj[prop];
    return obj;
}
function cast(value, type) {
    if (type instanceof thingtalk_1.Type.Array && typeof value === 'string')
        return value.split(/,\s*/g).map((v) => cast(v, type.elem));
    if (type instanceof thingtalk_1.Type.Array)
        return value.map((v) => cast(v, type.elem));
    if (type.isDate)
        return new Date(value);
    if ((type.isNumber || type.isMeasure) && typeof value === 'string')
        return parseFloat(value);
    if (type.isCurrency && typeof value === 'number')
        return new thingtalk_1.Builtin.Currency(value, 'usd');
    if (type.isCurrency && typeof value === 'string')
        return new thingtalk_1.Builtin.Currency(parseFloat(value), 'usd');
    if (type.isCurrency)
        return new thingtalk_1.Builtin.Currency(value.value, value.unit);
    if (type.isEntity && typeof value === 'string')
        return new thingtalk_1.Builtin.Entity(value, null);
    if (type.isEntity)
        return new thingtalk_1.Builtin.Entity(value.value, value.display);
    if (type.isLocation) {
        if (Object.prototype.hasOwnProperty.call(value, 'x') && Object.prototype.hasOwnProperty.call(value, 'y'))
            return new thingtalk_1.Builtin.Location(value.y, value.x, value.display);
        else if (Object.prototype.hasOwnProperty.call(value, 'latitude') && Object.prototype.hasOwnProperty.call(value, 'longitude'))
            return new thingtalk_1.Builtin.Location(value.latitude, value.longitude, value.display);
        else
            return new thingtalk_1.Builtin.Location(value.lat, value.lon, value.display);
    }
    return value;
}
function getMixinArgs(mixin) {
    const args = {};
    for (const in_param of mixin.in_params)
        args[in_param.name] = in_param.value.toJS();
    return args;
}
exports.getMixinArgs = getMixinArgs;
function findMixinArg(mixin, arg) {
    for (const in_param of mixin.in_params) {
        if (in_param.name === arg)
            return in_param.value.toJS();
    }
    return undefined;
}
exports.findMixinArg = findMixinArg;
function parseGenericResponse(json, fndef) {
    function extractOne(result) {
        const extracted = {};
        for (const arg of fndef.iterateArguments()) {
            if (arg.is_input)
                continue;
            if (arg.annotations.json_key)
                extracted[arg.name] = cast(get(result, arg.annotations.json_key.toJS()), arg.type);
            else
                extracted[arg.name] = cast(result[arg.name], arg.type);
        }
        return extracted;
    }
    if (fndef.annotations.json_key)
        json = get(json, fndef.annotations.json_key.toJS());
    if (Array.isArray(json))
        return json.map(extractOne);
    else
        return [extractOne(json)];
}
exports.parseGenericResponse = parseGenericResponse;
function formatString(url, deviceParams, functionParams) {
    return string_interp_1.default(url, (param) => {
        if (functionParams)
            return functionParams[param] || deviceParams[param];
        else
            return deviceParams[param];
    }, {
        failIfMissing: false
    });
}
exports.formatString = formatString;
function getPollInterval(fndef) {
    if (fndef.annotations.poll_interval)
        return fndef.annotations.poll_interval.toJS();
    else
        return -1;
}
exports.getPollInterval = getPollInterval;
//# sourceMappingURL=utils.js.map