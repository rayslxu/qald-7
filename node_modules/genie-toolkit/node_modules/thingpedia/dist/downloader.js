"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Thingpedia
//
// Copyright 2019-2021 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const ThingTalk = __importStar(require("thingtalk"));
const loaders_1 = __importDefault(require("./loaders"));
function safeMkdir(dir) {
    try {
        fs.mkdirSync(dir);
    }
    catch (e) {
        if (e.code !== 'EEXIST')
            throw e;
    }
}
function safeSymlinkSync(from, to) {
    try {
        fs.symlinkSync(from, to, 'dir');
    }
    catch (e) {
        if (e.code !== 'EEXIST')
            throw e;
    }
}
class ModuleDownloader {
    constructor(platform, client, schemas, builtins = {}) {
        this._platform = platform;
        this._client = client;
        // used to typecheck the received manifests
        this._schemas = schemas;
        this._builtins = builtins;
        this._cacheDir = platform.getCacheDir() + '/device-classes';
        this._moduleRequests = new Map;
        safeMkdir(this._cacheDir);
        safeMkdir(this._cacheDir + '/node_modules');
        if (platform.type !== 'android') {
            let ownPath = path.dirname(require.resolve('..'));
            if (process.env.TEST_MODE)
                ownPath = require.resolve('./index');
            safeSymlinkSync(ownPath, this._cacheDir + '/node_modules/thingpedia');
            safeSymlinkSync(path.dirname(require.resolve('thingtalk')), this._cacheDir + '/node_modules/thingtalk');
            const developerDirs = this._getDeveloperDirs();
            if (developerDirs) {
                for (const dir of developerDirs) {
                    safeMkdir(dir + '/node_modules');
                    safeSymlinkSync(ownPath, dir + '/node_modules/thingpedia');
                    safeSymlinkSync(path.dirname(require.resolve('thingtalk')), dir + '/node_modules/thingtalk');
                }
            }
        }
    }
    get platform() {
        return this._platform;
    }
    get client() {
        return this._client;
    }
    async getCachedMetas() {
        const cached = [];
        for (const promise of this._moduleRequests.values()) {
            try {
                const module = await promise;
                cached.push({ name: module.id, version: module.version });
            }
            catch (e) {
                // ignore error if the module fails to load
            }
        }
        return cached;
    }
    async updateModule(id) {
        let oldModule;
        try {
            oldModule = await this._moduleRequests.get(id);
        }
        catch (e) {
            // ignore errors
        }
        this._moduleRequests.delete(id);
        const newModule = await this.getModule(id);
        if (oldModule) {
            if (oldModule.version === newModule.version) {
                // keep the old module we had already loaded
                // this avoids reloading the JS code multiple times
                // unnecessarily
                this._moduleRequests.set(id, Promise.resolve(oldModule));
            }
            else {
                // remove any remnant of the old module
                await oldModule.clearCache();
            }
        }
    }
    getModule(id) {
        this._ensureModuleRequest(id);
        return this._moduleRequests.get(id);
    }
    _getDeveloperDirs() {
        const prefs = this.platform.getSharedPreferences();
        let developerDirs = prefs.get('developer-dir');
        if (!developerDirs)
            return undefined;
        if (!Array.isArray(developerDirs))
            developerDirs = [developerDirs];
        return developerDirs;
    }
    async _loadClassInternal(id) {
        if (this._builtins[id])
            return this._builtins[id].class;
        const classCode = await this._client.getDeviceCode(id);
        const parsed = await ThingTalk.Syntax.parse(classCode, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this._platform.locale,
            timezone: 'UTC'
        }).typecheck(this._schemas);
        assert_1.default(parsed instanceof ThingTalk.Ast.Library && parsed.classes.length === 1);
        const classdef = parsed.classes[0];
        this._schemas.injectClass(classdef);
        return classdef;
    }
    _recursiveLoadParentClasses(classdef, into) {
        return Promise.all(classdef.extends.map(async (parent) => {
            const parentClass = await this._schemas.getFullMeta(parent);
            into[parent] = parentClass;
            await this._recursiveLoadParentClasses(parentClass, into);
        }));
    }
    async loadClass(id) {
        const classdef = await this._loadClassInternal(id);
        const parents = {};
        await this._recursiveLoadParentClasses(classdef, parents);
        return [classdef, parents];
    }
    injectModule(id, module) {
        this._moduleRequests.set(id, Promise.resolve(module));
    }
    async _doLoadModule(id) {
        try {
            const [classdef, parents] = await this.loadClass(id);
            const loaderType = classdef.loader.module;
            if (loaderType === 'org.thingpedia.builtin') {
                if (this._builtins[id])
                    return new loaders_1.default['org.thingpedia.builtin'](id, classdef, parents, this, this._builtins[id].module);
                else
                    return new loaders_1.default['org.thingpedia.builtin.unsupported'](id, classdef, parents, this);
            }
            const loader = new (loaders_1.default[loaderType])(id, classdef, parents, this);
            const config = loader.config;
            if (config && config.hasMissingKeys()) {
                console.log('Loaded proxy class for ' + id + ' due to missing API keys');
                return new loaders_1.default['org.thingpedia.proxied'](id, classdef, parents, this);
            }
            console.log('Loaded class definition for ' + id + ', loader type: ' + loaderType + ', version: ' + classdef.annotations.version.toJS());
            return loader;
        }
        catch (e) {
            // on error, propagate error but don't cache it (so the next time we'll try again)
            this._moduleRequests.delete(id);
            throw e;
        }
    }
    _ensureModuleRequest(id) {
        if (this._moduleRequests.has(id))
            return;
        const request = this._doLoadModule(id);
        this._moduleRequests.set(id, request);
    }
}
exports.default = ModuleDownloader;
//# sourceMappingURL=downloader.js.map