"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Thingpedia
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const ThingTalk = __importStar(require("thingtalk"));
const thingtalk_1 = require("thingtalk");
const qs = __importStar(require("querystring"));
const fs = __importStar(require("fs"));
const fs_1 = require("fs");
const path = __importStar(require("path"));
const util = __importStar(require("util"));
const byline_1 = __importDefault(require("byline"));
const Helpers = __importStar(require("./helpers"));
const base_client_1 = __importDefault(require("./base_client"));
const device_factory_utils_1 = require("./device_factory_utils");
const file_parameter_provider_1 = __importDefault(require("./file_parameter_provider"));
const DEFAULT_THINGPEDIA_URL = 'https://thingpedia.stanford.edu/thingpedia';
/**
 * A Thingpedia Client that communicates with Thingpedia over HTTP(S).
 *
 * If the developer-dir shared preference is set, HTTP results are overridden
 * with the manifest.tt in the developer directory.
 *
 */
class HttpClient extends base_client_1.default {
    /**
     * Construct a new HttpClient.
     *
     * @param {BasePlatform} platform - the platform owning this client
     * @param {string} [url] - the Thingpedia URL to use
     */
    constructor(platform, url = DEFAULT_THINGPEDIA_URL) {
        super();
        this.platform = platform;
        this._url = url + '/api/v3';
        this._localEntityProvider = null;
    }
    /**
     * Retrieve the current user's developer key.
     *
     */
    get developerKey() {
        return this.platform.getDeveloperKey();
    }
    get locale() {
        return this.platform.locale;
    }
    _jsonToAstValue(value) {
        if (value === null || value === undefined)
            return new thingtalk_1.Ast.UndefinedValue();
        if (typeof value === 'boolean')
            return new thingtalk_1.Ast.BooleanValue(value);
        else if (typeof value === 'number')
            return new thingtalk_1.Ast.NumberValue(value);
        else if (typeof value === 'string')
            return new thingtalk_1.Ast.StringValue(value);
        if (Array.isArray(value))
            return new thingtalk_1.Ast.ArrayValue(value.map((v) => this._jsonToAstValue(v)));
        const obj = value;
        const mapped = {};
        for (const key in obj)
            mapped[key] = this._jsonToAstValue(obj[key]);
        return new thingtalk_1.Ast.ObjectValue(mapped);
    }
    async _addConfigFromSecretsJSON(ourConfig, filepath, deviceKind) {
        try {
            let secretJSON = JSON.parse(await fs_1.promises.readFile(filepath, { encoding: 'utf8' }));
            if (typeof secretJSON !== 'object' || secretJSON === null)
                return;
            if (deviceKind !== undefined)
                secretJSON = secretJSON[deviceKind];
            if (typeof secretJSON !== 'object' || secretJSON === null)
                return;
            for (const inParam of ourConfig.in_params) {
                if (inParam.value.isUndefined && secretJSON[inParam.name] !== undefined)
                    inParam.value = this._jsonToAstValue(secretJSON[inParam.name]);
            }
        }
        catch (e) {
            // ignore error if the file is missing, or if it doesn't parse as JSON (likely encrypted)
            if (e.code === 'ENOENT' || e.name === 'SyntaxError')
                return;
            throw e;
        }
    }
    async _addConfigFromThingpedia(ourConfig, deviceKind) {
        try {
            const officialMetadata = await this._getDeviceCodeHttp(deviceKind);
            const officialParsed = ThingTalk.Syntax.parse(officialMetadata, ThingTalk.Syntax.SyntaxType.Normal, {
                locale: this.locale,
                timezone: 'UTC'
            });
            assert_1.default(officialParsed instanceof thingtalk_1.Ast.Library);
            ourConfig.in_params = ourConfig.in_params.filter((ip) => !ip.value.isUndefined);
            const ourConfigParams = new Set(ourConfig.in_params.map((ip) => ip.name));
            const officialConfig = officialParsed.classes[0].config;
            assert_1.default(officialConfig);
            for (const in_param of officialConfig.in_params) {
                if (!ourConfigParams.has(in_param.name))
                    ourConfig.in_params.push(in_param);
            }
        }
        catch (e) {
            if (e.code !== 404)
                throw e;
        }
    }
    async _getLocalDeviceManifest(manifestPath, deviceKind) {
        const ourMetadata = (await util.promisify(fs.readFile)(manifestPath)).toString();
        const ourParsed = ThingTalk.Syntax.parse(ourMetadata, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this.locale,
            timezone: 'UTC'
        });
        assert_1.default(ourParsed instanceof thingtalk_1.Ast.Library);
        const ourClassDef = ourParsed.classes[0];
        ourClassDef.annotations.version = new thingtalk_1.Ast.Value.Number(-1);
        if (ourClassDef.is_abstract)
            return ourClassDef;
        const ourConfig = ourClassDef.config;
        if (!ourConfig)
            return ourClassDef;
        // ourConfig might lack some of the fields that are in the
        // real metadata, such as api keys and OAuth secrets
        //
        // we look in three places for the missing fields:
        // 1. in a secrets.json file in the same directory, containing directly the secrets for this device
        // 2. in a secrets.json file in the global user directory, containing secrets for all devices (indexed by device kind)
        // 3. in the upstream thingpedia
        if (ourConfig.in_params.every((v) => !v.value.isUndefined))
            return ourClassDef;
        await this._addConfigFromSecretsJSON(ourConfig, path.resolve(manifestPath, '../secrets.json'));
        if (ourConfig.in_params.every((v) => !v.value.isUndefined))
            return ourClassDef;
        await this._addConfigFromSecretsJSON(ourConfig, path.resolve(this.platform.getWritableDir(), 'secrets.json'), deviceKind);
        if (ourConfig.in_params.every((v) => !v.value.isUndefined))
            return ourClassDef;
        await this._addConfigFromThingpedia(ourConfig, deviceKind);
        return ourClassDef;
    }
    _getDeveloperDirs() {
        const prefs = this.platform.getSharedPreferences();
        let developerDirs = prefs.get('developer-dir');
        if (!developerDirs)
            return undefined;
        if (!Array.isArray(developerDirs))
            developerDirs = [developerDirs];
        return developerDirs;
    }
    async _tryGetLocalDeviceManifest(developerDirs, kind) {
        const localeParts = this.locale.toLowerCase().split(/[-_.@]/);
        // try with locale first
        while (localeParts.length > 0) {
            for (const dir of developerDirs) {
                const localPath = path.resolve(dir, kind, `manifest.${localeParts.join('-')}.tt`);
                if (await util.promisify(fs.exists)(localPath))
                    return this._getLocalDeviceManifest(localPath, kind);
            }
            localeParts.pop();
        }
        // try without locale next
        for (const dir of developerDirs) {
            const localPath = path.resolve(dir, kind, `manifest.tt`);
            if (await util.promisify(fs.exists)(localPath))
                return this._getLocalDeviceManifest(localPath, kind);
        }
        return null;
    }
    async getDeviceCode(kind) {
        const developerDirs = this._getDeveloperDirs();
        if (developerDirs) {
            const classDef = await this._tryGetLocalDeviceManifest(developerDirs, kind);
            if (classDef !== null)
                return classDef.prettyprint();
        }
        return this._getDeviceCodeHttp(kind);
    }
    async getModuleLocation(id) {
        const developerDirs = this._getDeveloperDirs();
        if (developerDirs) {
            for (const dir of developerDirs) {
                if (await util.promisify(fs.exists)(path.resolve(dir, id)))
                    return 'file://' + path.resolve(dir, id);
            }
        }
        return this._getModuleLocationHttp(id);
    }
    async getSchemas(kinds, withMetadata) {
        const developerDirs = this._getDeveloperDirs();
        if (!developerDirs)
            return this._getSchemasHttp(kinds, withMetadata);
        const forward = [];
        const handled = [];
        for (const kind of kinds) {
            const classDef = await this._tryGetLocalDeviceManifest(developerDirs, kind);
            if (classDef !== null)
                handled.push(classDef);
            else
                forward.push(kind);
        }
        let code = '';
        if (handled.length > 0)
            code += new thingtalk_1.Ast.Input.Library(null, handled, []).prettyprint();
        if (forward.length > 0)
            code += await this._getSchemasHttp(kinds, withMetadata);
        return code;
    }
    async _getLocalFactory(localPath, kind) {
        const classDef = await this._getLocalDeviceManifest(localPath, kind);
        return device_factory_utils_1.makeDeviceFactory(classDef);
    }
    async getDeviceSetup(kinds) {
        const developerDirs = this._getDeveloperDirs();
        if (!developerDirs)
            return this._getDeviceSetupHttp(kinds);
        const forward = [];
        const handled = {};
        for (const kind of kinds) {
            let ok = false;
            for (const dir of developerDirs) {
                const localPath = path.resolve(dir, kind, 'manifest.tt');
                if (await util.promisify(fs.exists)(localPath)) {
                    handled[kind] = await this._getLocalFactory(localPath, kind);
                    ok = true;
                    break;
                }
            }
            if (!ok)
                forward.push(kind);
        }
        if (forward.length > 0)
            Object.assign(handled, await this._getDeviceSetupHttp(forward));
        return handled;
    }
    _getModuleLocationHttp(id) {
        let to = this._url + '/devices/package/' + id;
        if (this.developerKey)
            to += '?developer_key=' + this.developerKey;
        return Helpers.Http.get(to, { followRedirects: false }).then((res) => {
            throw new Error(`Expected a redirect downloading device ${id}`);
        }, (err) => {
            if (err.code >= 400)
                throw new Error(`Unexpected HTTP status ${err.code} downloading device ${id}`);
            return err.redirect;
        });
    }
    async _simpleRequest(to, params = {}, accept = 'application/json', options = { extractData: true, method: 'GET' }) {
        params.locale = this.locale;
        params.thingtalk_version = ThingTalk.version;
        if (this.developerKey)
            params.developer_key = this.developerKey;
        to += '?' + qs.stringify(params);
        const response = await Helpers.Http.request(this._url + to, options.method || 'GET', '', { accept });
        if (accept === 'application/json') {
            const parsed = JSON.parse(response);
            if (parsed.result !== 'ok')
                throw new Error(`Operation failed: ${parsed.error || parsed.result}`);
            if (options.extractData)
                return parsed.data;
            else
                return parsed;
        }
        else {
            return response;
        }
    }
    // raw manifest code
    _getDeviceCodeHttp(kind) {
        return this._simpleRequest('/devices/code/' + kind, {}, 'application/x-thingtalk');
    }
    async _checkSnapshot() {
        const cachePath = path.resolve(this.platform.getCacheDir(), 'snapshot.tt');
        // open the file first so we can be correct wrt concurrent writes to the file (which
        // occur as atomic renames)
        let file;
        try {
            file = await util.promisify(fs.open)(cachePath, 'r', 0o666);
        }
        catch (e) {
            if (e.code === 'ENOENT')
                return null;
            else
                throw e;
        }
        try {
            const stat = await util.promisify(fs.fstat)(file);
            // cache again if older than one day
            if (Number(stat.mtime) < Date.now() - 24 * 3600 * 1000)
                return null;
            return await util.promisify(fs.readFile)(file, { encoding: 'utf8' });
        }
        finally {
            await util.promisify(fs.close)(file);
        }
    }
    async _cacheSnapshot() {
        const params = {
            meta: '1',
            locale: this.locale,
            thingtalk_version: ThingTalk.version,
        };
        if (this.developerKey)
            params.developer_key = this.developerKey;
        const stream = await Helpers.Http.getStream(this._url + '/snapshot/-1?' + qs.stringify(params), {
            accept: 'application/x-thingtalk'
        });
        const cachePath = path.resolve(this.platform.getCacheDir(), 'snapshot.tt');
        // perform an atomic write on the snapshot file: write to a temporary file then rename the file
        const cacheFile = fs.createWriteStream(cachePath + '.tmp');
        stream.pipe(cacheFile);
        await new Promise((resolve, reject) => {
            cacheFile.on('error', reject);
            cacheFile.on('finish', resolve);
        });
        await util.promisify(fs.rename)(cachePath + '.tmp', cachePath);
        return util.promisify(fs.readFile)(cachePath, { encoding: 'utf8' });
    }
    async _getSchemasHttp(kinds, withMetadata) {
        // if we have cached the full snapshot, we return that
        const cached = await this._checkSnapshot();
        if (cached)
            return cached;
        return this._simpleRequest('/schema/' + kinds.join(','), {
            meta: withMetadata ? '1' : '0'
        }, 'application/x-thingtalk');
    }
    getDeviceList(klass, page, page_size) {
        const params = {
            page: page !== undefined ? String(page) : undefined,
            page_size: page_size !== undefined ? String(page_size) : undefined
        };
        if (klass)
            params.class = klass;
        return this._simpleRequest('/devices/all', params);
    }
    searchDevice(q) {
        return this._simpleRequest('/devices/search', { q });
    }
    getDeviceFactories(klass) {
        const params = {};
        if (klass)
            params.class = klass;
        return this._simpleRequest('/devices/setup', params);
    }
    _getDeviceSetupHttp(kinds) {
        return this._simpleRequest('/devices/setup/' + kinds.join(','));
    }
    async getKindByDiscovery(publicData) {
        const to = this._url + '/devices/discovery';
        const params = {
            locale: this.locale,
            thingtalk_version: ThingTalk.version
        };
        if (this.developerKey)
            params.developer_key = this.developerKey;
        const response = await Helpers.Http.post(to + '?' + qs.stringify(params), JSON.stringify(publicData), { dataContentType: 'application/json' });
        assert_1.default(typeof response === 'string');
        const parsed = JSON.parse(response);
        if (parsed.result !== 'ok')
            throw new Error(`Operation failed: ${parsed.error || parsed.result}`);
        return parsed.data.kind;
    }
    getExamplesByKey(key) {
        return this._simpleRequest('/examples/search', { q: key }, 'application/x-thingtalk');
    }
    async getExamplesByKinds(kinds) {
        const developerDirs = this._getDeveloperDirs();
        if (!developerDirs)
            return this._getExamplesByKinds(kinds);
        const forward = [];
        const handled = [];
        for (const kind of kinds) {
            let ok = false;
            for (const dir of developerDirs) {
                const localPath = path.resolve(dir, kind, 'dataset.tt');
                if (await util.promisify(fs.exists)(localPath)) {
                    handled.push(await util.promisify(fs.readFile)(localPath, { encoding: 'utf8' }));
                    ok = true;
                    break;
                }
            }
            if (!ok)
                forward.push(kind);
        }
        if (forward.length > 0)
            handled.push(await this._getExamplesByKinds(forward));
        const buffer = handled.join('\n');
        return buffer;
    }
    _getExamplesByKinds(kinds) {
        return this._simpleRequest('/examples/by-kinds/' + kinds.join(','), {}, 'application/x-thingtalk');
    }
    clickExample(exampleId) {
        return this._simpleRequest('/examples/click/' + exampleId, {}, 'application/x-thingtalk', { method: 'POST' });
    }
    _getLocalEntityProvider() {
        if (this._localEntityProvider)
            return this._localEntityProvider;
        return this._localEntityProvider = this._doGetLocalEntityProvider();
    }
    async _getParameterDatasetsFile() {
        const developerDirs = this._getDeveloperDirs();
        if (!developerDirs)
            return null;
        // for each developer directory, search in the same directory
        // and in the parent directory
        // this covers the normal case where it's in the same directory,
        // and the thingpedia-common-devices case
        for (const d of developerDirs) {
            let localPath = path.resolve(d, 'parameter-datasets.tsv');
            if (await util.promisify(fs.exists)(localPath))
                return localPath;
            localPath = path.resolve(d, '../parameter-datasets.tsv');
            if (await util.promisify(fs.exists)(localPath))
                return localPath;
        }
        return null;
    }
    async _doGetLocalEntityProvider() {
        const filename = await this._getParameterDatasetsFile();
        if (!filename)
            return null;
        const provider = new file_parameter_provider_1.default(filename, this.platform.locale);
        await provider.load();
        return provider;
    }
    async lookupEntity(entityType, searchTerm) {
        const localProvider = await this._getLocalEntityProvider();
        if (localProvider) {
            // ignore search term, return everything
            const result = await localProvider.lookupEntity(entityType, searchTerm);
            if (result.length > 0)
                return { data: result, meta: { name: entityType, is_well_known: false, has_ner_support: true } };
        }
        try {
            return await this._simpleRequest('/entities/lookup/' + encodeURIComponent(entityType), { q: searchTerm }, 'application/json', { extractData: false });
        }
        catch (e) {
            if (e.code !== 404)
                throw e;
            return { data: [], meta: { name: entityType, is_well_known: false, has_ner_support: false } };
        }
    }
    lookupLocation(searchTerm, around) {
        if (around) {
            return this._simpleRequest('/locations/lookup', { q: searchTerm, latitude: String(around.latitude), longitude: String(around.longitude) }, 'application/json');
        }
        else {
            return this._simpleRequest('/locations/lookup', { q: searchTerm }, 'application/json');
        }
    }
    getAllExamples() {
        return this._simpleRequest('/examples/all', {}, 'application/x-thingtalk');
    }
    async getAllEntityTypes() {
        return this._simpleRequest('/entities/all');
    }
    async getAllDeviceNames() {
        const names = [];
        let snapshot = await this._checkSnapshot();
        if (!snapshot)
            snapshot = await this._cacheSnapshot();
        const parsed = ThingTalk.Syntax.parse(snapshot, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this.locale,
            timezone: 'UTC'
        });
        assert_1.default(parsed instanceof thingtalk_1.Ast.Library);
        for (const classDef of parsed.classes) {
            names.push({
                kind: classDef.kind,
                kind_canonical: classDef.metadata.canonical
            });
        }
        const developerDirs = this._getDeveloperDirs();
        if (!developerDirs)
            return names;
        for (const dir of developerDirs) {
            for (const device of await util.promisify(fs.readdir)(dir)) {
                const localPath = path.resolve(dir, device, 'dataset.tt');
                if (await util.promisify(fs.exists)(localPath)) {
                    const classDef = (await this._getLocalDeviceManifest(localPath, device));
                    names.push({
                        kind: classDef.kind,
                        kind_canonical: classDef.metadata.canonical
                    });
                }
            }
        }
        return names;
    }
    async *invokeQuery(kind, uniqueId, query, params, hints) {
        const queryparams = {
            locale: this.locale,
            thingtalk_version: ThingTalk.version,
        };
        if (this.developerKey)
            queryparams.developer_key = this.developerKey;
        const stream = await Helpers.Http.requestStream(this._url + '/proxy/query/' + kind + '/' + query + qs.stringify(queryparams), 'POST', JSON.stringify({ uniqueId, params, hints }), {
            accept: 'application/json-l'
        });
        for await (const line of stream.pipe(byline_1.default()))
            yield JSON.parse(line);
    }
}
exports.default = HttpClient;
//# sourceMappingURL=http_client.js.map