"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of Thingpedia
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const ThingTalk = __importStar(require("thingtalk"));
const thingtalk_1 = require("thingtalk");
const fs = __importStar(require("fs"));
const util = __importStar(require("util"));
const qs = __importStar(require("qs"));
const Helpers = __importStar(require("./helpers"));
const compat_1 = require("./compat");
const device_factory_utils_1 = require("./device_factory_utils");
const base_client_1 = __importDefault(require("./base_client"));
const file_parameter_provider_1 = __importDefault(require("./file_parameter_provider"));
// who to contact to resolve locations and entities
const THINGPEDIA_URL = 'https://thingpedia.stanford.edu/thingpedia/api/v3';
/**
 * A Thingpedia Client backed by local files.
 *
 */
class FileClient extends base_client_1.default {
    /**
     * Construct a new FileClient.
     *
     * @param {Object} args - construction parameters
     * @param {string} args.locale - the locale of the user
     * @param {string} args.thingpedia - the path to the `thingpedia.tt` file
     * @param {string} args.entities - the path to the `entities.json` file
     * @param {string} args.dataset - the path to the `dataset.tt` file
     */
    constructor(args) {
        super();
        this._locale = args.locale;
        this._devices = null;
        this._entities = null;
        this._dataset = null;
        this._examples = {};
        this._thingpediafilename = args.thingpedia;
        this._entityfilename = args.entities;
        this._datasetfilename = args.dataset;
        this._entityProvider = null;
        if (args.parameter_datasets)
            this._entityProvider = new file_parameter_provider_1.default(args.parameter_datasets, args.locale);
        this._loaded = null;
    }
    get locale() {
        return this._locale;
    }
    getModuleLocation(id) {
        throw new Error('not implemented');
    }
    getDeviceSetup(kinds) {
        throw new Error('not implemented');
    }
    getKindByDiscovery(publicData) {
        throw new Error('not implemented');
    }
    async _load() {
        this._devices = (await util.promisify(fs.readFile)(this._thingpediafilename)).toString();
        if (this._entityfilename)
            this._entities = JSON.parse(String(await util.promisify(fs.readFile)(this._entityfilename))).data;
        else
            this._entities = null;
        if (this._datasetfilename) {
            this._dataset = await util.promisify(fs.readFile)(this._datasetfilename, { encoding: 'utf8' });
            let parsed;
            try {
                parsed = await ThingTalk.Syntax.parse(this._dataset, ThingTalk.Syntax.SyntaxType.Normal, {
                    locale: this.locale,
                    timezone: 'UTC'
                });
            }
            catch (e) {
                if (e.name !== 'SyntaxError')
                    throw e;
                parsed = await ThingTalk.Syntax.parse(this._dataset, ThingTalk.Syntax.SyntaxType.Legacy, {
                    locale: this.locale,
                    timezone: 'UTC'
                });
            }
            assert_1.default(parsed instanceof thingtalk_1.Ast.Library);
            for (const dataset of parsed.datasets) {
                for (const example of dataset.examples) {
                    const primitives = [];
                    for (const [, prim] of example.iteratePrimitives(false)) {
                        assert_1.default(prim instanceof thingtalk_1.Ast.Invocation || prim instanceof thingtalk_1.Ast.ExternalBooleanExpression);
                        const selector = prim.selector;
                        if (selector instanceof thingtalk_1.Ast.DeviceSelector && !primitives.includes(selector.kind))
                            primitives.push(selector.kind);
                    }
                    if (primitives.length === 1) {
                        const device = primitives[0];
                        if (device in this._examples)
                            this._examples[device].push(example);
                        else
                            this._examples[device] = [example];
                    }
                }
            }
        }
        if (this._entityProvider)
            await this._entityProvider.load();
    }
    _ensureLoaded() {
        if (this._loaded)
            return this._loaded;
        else
            return this._loaded = this._load();
    }
    async getDeviceList(klass, page = 0, page_size = 10) {
        await this._ensureLoaded();
        const parsed = ThingTalk.Syntax.parse(this._devices, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this.locale,
            timezone: 'UTC'
        });
        assert_1.default(parsed instanceof thingtalk_1.Ast.Library);
        const list = [];
        for (const classDef of parsed.classes.slice(page_size * page, page_size * (page + 1))) {
            const category = compat_1.getCategory(classDef);
            if (klass && klass !== category)
                continue;
            list.push({
                primary_kind: classDef.kind,
                name: classDef.nl_annotations.thingpedia_name || classDef.kind,
                description: classDef.nl_annotations.thingpedia_description || '',
                category,
                subcategory: classDef.getImplementationAnnotation('subcategory') || 'service',
                license: classDef.getImplementationAnnotation('license') || '',
                website: classDef.getImplementationAnnotation('website') || '',
                repository: classDef.getImplementationAnnotation('repository') || '',
                issue_tracker: classDef.getImplementationAnnotation('issue_tracker') || '',
            });
        }
        return list;
    }
    async searchDevice(q) {
        await this._ensureLoaded();
        q = q.toLowerCase();
        const parsed = ThingTalk.Syntax.parse(this._devices, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this.locale,
            timezone: 'UTC'
        });
        assert_1.default(parsed instanceof thingtalk_1.Ast.Library);
        const list = [];
        for (const classDef of parsed.classes) {
            const record = {
                primary_kind: classDef.kind,
                name: classDef.nl_annotations.thingpedia_name || classDef.kind,
                description: classDef.nl_annotations.thingpedia_description || '',
                category: compat_1.getCategory(classDef),
                subcategory: classDef.getImplementationAnnotation('subcategory') || 'service',
                license: classDef.getImplementationAnnotation('license') || '',
                website: String(classDef.getImplementationAnnotation('website') || ''),
                repository: String(classDef.getImplementationAnnotation('repository') || ''),
                issue_tracker: String(classDef.getImplementationAnnotation('issue_tracker') || ''),
            };
            // very simple search
            if (record.name.toLowerCase().includes(q) ||
                record.description.toLowerCase().includes(q))
                list.push(record);
        }
        return list;
    }
    async getDeviceFactories(klass) {
        await this._ensureLoaded();
        const parsed = ThingTalk.Syntax.parse(this._devices, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this.locale,
            timezone: 'UTC'
        });
        assert_1.default(parsed instanceof thingtalk_1.Ast.Library);
        const list = [];
        for (const classDef of parsed.classes) {
            const factory = device_factory_utils_1.makeDeviceFactory(classDef);
            if (factory)
                list.push(factory);
        }
        return list;
    }
    async getSchemas(kinds, useMeta) {
        await this._ensureLoaded();
        // ignore kinds, just return the full file, SchemaRetriever will take care of the rest
        return this._devices;
    }
    async getDeviceCode(kind) {
        // we don't have the full class, so we just return the meta info
        await this._ensureLoaded();
        const parsed = ThingTalk.Syntax.parse(this._devices, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this.locale,
            timezone: 'UTC'
        });
        assert_1.default(parsed instanceof thingtalk_1.Ast.Library);
        for (const classDef of parsed.classes) {
            if (classDef.kind === kind)
                return classDef.prettyprint();
        }
        throw new Error('Not Found');
    }
    async getAllExamples() {
        await this._ensureLoaded();
        return this._dataset;
    }
    async getExamplesByKey(key) {
        throw new Error('not implemented');
    }
    async getExamplesByKinds(kinds) {
        assert_1.default(Array.isArray(kinds));
        await this._ensureLoaded();
        let examples = [];
        for (const device of kinds) {
            if (device in this._examples)
                examples = examples.concat(this._examples[device]);
        }
        const name = `org.thingpedia.dynamic.by_kinds.${kinds.join('__')}`;
        const dataset = new thingtalk_1.Ast.Dataset(null, name, examples);
        const library = new thingtalk_1.Ast.Input.Library(null, [], [dataset]);
        return library.prettyprint();
    }
    async clickExample(exampleId) {
        // do nothing
    }
    async getAllDeviceNames() {
        await this._ensureLoaded();
        const parsed = ThingTalk.Syntax.parse(this._devices, ThingTalk.Syntax.SyntaxType.Normal, {
            locale: this.locale,
            timezone: 'UTC'
        });
        assert_1.default(parsed instanceof thingtalk_1.Ast.Library);
        const names = [];
        for (const classDef of parsed.classes) {
            names.push({
                kind: classDef.kind,
                kind_canonical: classDef.metadata.canonical
            });
        }
        return names;
    }
    async getAllEntityTypes() {
        await this._ensureLoaded();
        return this._entities || [];
    }
    async _httpRequest(to, params = {}, accept = 'application/json', options = { extractData: true }) {
        params.locale = this.locale;
        params.thingtalk_version = ThingTalk.version;
        to += '?' + qs.stringify(params);
        const response = await Helpers.Http.get(THINGPEDIA_URL + to, { accept });
        const parsed = JSON.parse(response);
        if (parsed.result !== 'ok')
            throw new Error(`Operation failed: ${parsed.error || parsed.result}`);
        if (options.extractData)
            return parsed.data;
        else
            return parsed;
    }
    async lookupEntity(entityType, searchTerm) {
        if (this._entityProvider) {
            const result = await this._entityProvider.lookupEntity(entityType, searchTerm);
            if (result.length > 0)
                return { data: result, meta: { name: entityType, is_well_known: false, has_ner_support: true } };
        }
        return this._httpRequest('/entities/lookup/' + encodeURIComponent(entityType), { q: searchTerm }, 'application/json', { extractData: false });
    }
    lookupLocation(searchTerm, around) {
        if (around) {
            return this._httpRequest('/locations/lookup', { q: searchTerm, latitude: String(around.latitude), longitude: String(around.longitude) }, 'application/json');
        }
        else {
            return this._httpRequest('/locations/lookup', { q: searchTerm }, 'application/json');
        }
    }
    invokeQuery() {
        throw new Error('not implemented');
    }
}
exports.default = FileClient;
//# sourceMappingURL=file_thingpedia_client.js.map