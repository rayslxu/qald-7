"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2016-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const TTUnits = __importStar(require("thingtalk-units"));
const Grammar = __importStar(require("./grammar"));
const pretty_1 = require("./new-syntax/pretty");
const list_1 = __importDefault(require("./utils/list"));
function normalizeUnit(unit) {
    if (unit.startsWith('default')) {
        switch (unit) {
            case 'defaultTemperature':
                return 'C';
            default:
                throw new Error('Invalid default unit');
        }
    }
    else {
        return TTUnits.normalizeUnit(unit);
    }
}
function stringHash(x) {
    // DJB2 algorithm
    let hash = 5381;
    for (let i = 0; i < x.length; i++) {
        const c = x.charCodeAt(i);
        hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
    }
    return hash;
}
// strictly speaking, Measure and Arrays are not types, they are type constructors
// (kind * -> *)
// isAssignable() has the magic to check types
/**
 * The base class of all ThingTalk types.
 */
class Type {
    static fromString(str) {
        if (str instanceof Type)
            return str;
        return Grammar.parse(str, { startRule: 'type_ref' });
    }
    prettyprint() {
        return (0, pretty_1.prettyprint)(this.toSource());
    }
    isNumeric() {
        return this.isNumber || this.isMeasure || this.isCurrency;
    }
    isComparable() {
        return this.isNumeric() || this.isDate || this.isTime || this.isString;
    }
    static resolve(type, typeScope) {
        if (typeof type === 'string')
            return Type.resolve(typeScope[type], typeScope);
        if (type instanceof Type.Array)
            return new Type.Array(Type.resolve(type.elem, typeScope));
        if (type instanceof Type.Measure && type.unit === '')
            return new Type.Measure(typeScope['_unit']);
        if (type instanceof Type.Entity && type.type === '')
            return new Type.Entity(typeScope['_entity']);
        return type;
    }
    static isAssignable(type, assignableTo, typeScope = {}, entitySubTypeMap = {}) {
        if (typeof assignableTo === 'string') {
            if (typeScope[assignableTo])
                return Type.isAssignable(type, typeScope[assignableTo], typeScope, entitySubTypeMap);
            typeScope[assignableTo] = type;
            return true;
        }
        if (type.equals(assignableTo))
            return true;
        // if the types are different, and one of them is unknown, we err to
        // fail to assign (which causes a type error) because we don't know
        // the assignment rules
        if (type instanceof Type.Unknown || assignableTo instanceof Type.Unknown)
            return false;
        // Any type matches everything (like "any" in TypeScript - this is unsound but okay)
        if (type.isAny || assignableTo.isAny)
            return true;
        // primitive type conversions
        if (type.isDate && assignableTo.isTime)
            return true;
        if (type.isNumber && assignableTo.isCurrency)
            return true;
        if (type instanceof Type.Measure && assignableTo instanceof Type.Measure && assignableTo.unit !== '') {
            if (type.unit === assignableTo.unit)
                return true;
        }
        if (type instanceof Type.Measure && assignableTo instanceof Type.Measure && assignableTo.unit === '') {
            if (!typeScope['_unit']) {
                typeScope['_unit'] = type.unit;
                return true;
            }
            if (typeScope['_unit'] && typeScope['_unit'] === type.unit)
                return true;
            return false;
        }
        if (type instanceof Type.Array && assignableTo instanceof Type.Array) {
            if (typeof assignableTo.elem === 'string') {
                if (typeof type.elem === 'string')
                    return true;
                if (typeScope[assignableTo.elem])
                    return Type.isAssignable(type.elem, typeScope[assignableTo.elem], typeScope, entitySubTypeMap);
                typeScope[assignableTo.elem] = type.elem;
                return true;
            }
            if (typeof type.elem === 'string') {
                if (typeScope[type.elem])
                    return Type.isAssignable(typeScope[type.elem], assignableTo.elem, typeScope, entitySubTypeMap);
                typeScope[type.elem] = assignableTo.elem;
                return true;
            }
            if (type.elem.isAny)
                return true;
            if (Type.isAssignable(type.elem, assignableTo.elem, typeScope, entitySubTypeMap))
                return true;
        }
        if (type instanceof Type.Array) {
            if (typeof type.elem === 'string')
                return false;
            if (assignableTo instanceof Type.Entity && assignableTo.type === 'tt:contact_group')
                return Type.isAssignable(type.elem, new Type.Entity('tt:contact'), typeScope, entitySubTypeMap);
        }
        if (type instanceof Type.Enum && assignableTo instanceof Type.Enum) {
            if (type.entries === null)
                return true;
            if (assignableTo.entries === null)
                return false;
            if (arrayEquals(type.entries, assignableTo.entries))
                return true;
            if (type.entries[type.entries.length - 1] === '*' &&
                type.entries.slice(0, type.entries.length - 1).every((entry) => assignableTo.entries.includes(entry)))
                return true;
        }
        if (type instanceof Type.Entity && assignableTo instanceof Type.Entity) {
            if (assignableTo.type === '') {
                if (!typeScope['_entity']) {
                    typeScope['_entity'] = type.type;
                    return true;
                }
                if (typeScope['_entity'] && typeScope['_entity'] === type.type)
                    return true;
                return false;
            }
            if (entitySubType(type.type, assignableTo.type, entitySubTypeMap))
                return true;
        }
        return false;
    }
}
Type.prototype.isAny = false;
Type.prototype.isBoolean = false;
Type.prototype.isString = false;
Type.prototype.isNumber = false;
Type.prototype.isCurrency = false;
Type.prototype.isEntity = false;
Type.prototype.isMeasure = false;
Type.prototype.isEnum = false;
Type.prototype.isArray = false;
Type.prototype.isTime = false;
Type.prototype.isDate = false;
Type.prototype.isRecurrentTimeSpecification = false;
Type.prototype.isLocation = false;
Type.prototype.isArgMap = false;
Type.prototype.isObject = false;
class PrimitiveType extends Type {
    constructor(name) {
        super();
        this.name = name;
        this._hash = stringHash(this.name);
        this['is' + name] = true;
    }
    toString() {
        return this.name;
    }
    toSource() {
        return list_1.default.singleton(this.name);
    }
    hash() {
        return this._hash;
    }
    equals(other) {
        // primitive types are singletons
        return this === other;
    }
}
Type.Any = new PrimitiveType('Any');
Type.Boolean = new PrimitiveType('Boolean');
Type.String = new PrimitiveType('String');
Type.Number = new PrimitiveType('Number');
Type.Currency = new PrimitiveType('Currency');
Type.Time = new PrimitiveType('Time');
Type.Date = new PrimitiveType('Date');
Type.RecurrentTimeSpecification = new PrimitiveType('RecurrentTimeSpecification');
Type.Location = new PrimitiveType('Location');
Type.ArgMap = new PrimitiveType('ArgMap');
(function (Type) {
    const ENTITY_HASH = stringHash('Entity');
    class Entity extends Type {
        // the entity type, as RDF-style prefix:name
        constructor(type) {
            super();
            this.type = type;
        }
        toString() {
            return `Entity(${this.type})`;
        }
        toSource() {
            return list_1.default.concat('Entity', '(', this.type, ')');
        }
        hash() {
            return ENTITY_HASH ^ stringHash(this.type);
        }
        equals(other) {
            return other instanceof Entity && this.type === other.type;
        }
    }
    Type.Entity = Entity;
    Entity.prototype.isEntity = true;
    const MEASURE_HASH = stringHash('Measure');
    class Measure extends Type {
        // '' means any unit, creating a polymorphic type
        // any other value is a base unit (m for length, C for temperature)
        constructor(unit) {
            super();
            this.unit = normalizeUnit(unit);
        }
        toString() {
            return `Measure(${this.unit})`;
        }
        toSource() {
            return list_1.default.concat('Measure', '(', this.unit, ')');
        }
        hash() {
            return MEASURE_HASH ^ stringHash(this.unit);
        }
        equals(other) {
            return other instanceof Measure && this.unit === other.unit;
        }
    }
    Type.Measure = Measure;
    Measure.prototype.isMeasure = true;
    const ENUM_HASH = stringHash('Enum');
    class Enum extends Type {
        constructor(entries) {
            super();
            this.entries = entries;
        }
        toString() {
            return `Enum(${this.entries})`;
        }
        toSource() {
            if (this.entries === null)
                return list_1.default.concat('Enum', '(', '*', ')');
            return list_1.default.concat('Enum', '(', list_1.default.join(this.entries.map((e) => list_1.default.singleton(e)), ','), ')');
        }
        hash() {
            let hash = ENUM_HASH;
            if (!this.entries)
                return hash;
            for (const entry of this.entries)
                hash ^= stringHash(entry);
            return hash;
        }
        equals(other) {
            return other instanceof Enum && arrayEquals(this.entries, other.entries);
        }
    }
    Type.Enum = Enum;
    Enum.prototype.isEnum = true;
    const ARRAY_HASH = stringHash('Array');
    class Array extends Type {
        constructor(elem) {
            super();
            this.elem = elem;
        }
        toString() {
            return `Array(${this.elem})`;
        }
        toSource() {
            if (typeof this.elem === 'string')
                return list_1.default.concat('Array', '(', this.elem, ')');
            return list_1.default.concat('Array', '(', this.elem.toSource(), ')');
        }
        hash() {
            return ARRAY_HASH ^
                (typeof this.elem === 'string' ? stringHash(this.elem) :
                    this.elem.hash());
        }
        equals(other) {
            if (!(other instanceof Array))
                return false;
            if (typeof this.elem === 'string')
                return this.elem === other.elem;
            if (typeof other.elem === 'string')
                return false;
            return this.elem.equals(other.elem);
        }
    }
    Type.Array = Array;
    Array.prototype.isArray = true;
    const COMPOUND_HASH = stringHash('Compound');
    class Compound extends Type {
        constructor(name, fields) {
            super();
            this.name = name;
            this.fields = fields;
            this._hash = undefined;
        }
        toString() {
            if (this.name)
                return `Compound(${this.name})`;
            return `Compound`;
        }
        toSource() {
            let list = list_1.default.concat('{', '\t+', '\n');
            let first = true;
            for (const field in this.fields) {
                // ignored flattened nested compound arguments
                if (field.indexOf('.') >= 0)
                    continue;
                const arg = this.fields[field];
                if (first)
                    first = false;
                else
                    list = list_1.default.concat(list, ',', '\n');
                list = list_1.default.concat(list, arg.toSource());
            }
            list = list_1.default.concat(list, '\n', '\t-', '}');
            return list;
        }
        hash() {
            if (this._hash !== undefined)
                return this._hash;
            let hash = COMPOUND_HASH;
            for (const field in this.fields)
                hash ^= stringHash(field) ^ this.fields[field].type.hash();
            return this._hash = hash;
        }
        equals(other) {
            if (!(other instanceof Compound))
                return false;
            if (this.name !== other.name)
                return false;
            if (Object.keys(this.fields).length !== Object.keys(other.fields).length)
                return false;
            for (const f in this.fields) {
                if (!(f in other.fields))
                    return false;
                if (!this.fields[f].type.equals(other.fields[f].type))
                    return false;
            }
            return true;
        }
    }
    Type.Compound = Compound;
    Compound.prototype.isCompound = true;
    // forward compatibility: a type that we know nothing about,
    // because it was introduced in a later version of the language
    class Unknown extends Type {
        constructor(name) {
            super();
            this.name = name;
        }
        toString() {
            return this.name;
        }
        toSource() {
            return list_1.default.singleton(this.name);
        }
        hash() {
            return stringHash(this.name);
        }
        equals(other) {
            return other instanceof Unknown &&
                this.name === other.name;
        }
    }
    Type.Unknown = Unknown;
    Unknown.prototype.isUnknown = true;
})(Type || (Type = {}));
exports.default = Type;
function arrayEquals(a, b) {
    if (a === null && b === null)
        return true;
    if (a === null || b === null)
        return false;
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
            return false;
    }
    return true;
}
const DEFAULT_ENTITY_SUB_TYPE = {
    'tt:picture': ['tt:url']
};
function entitySubType(type, assignableTo, entitySubTypeMap) {
    if (type === assignableTo)
        return true;
    const parents = entitySubTypeMap[type] || DEFAULT_ENTITY_SUB_TYPE[type];
    if (parents) {
        for (const parent of parents) {
            if (entitySubType(parent, assignableTo, entitySubTypeMap))
                return true;
        }
    }
    return false;
}
//# sourceMappingURL=type.js.map