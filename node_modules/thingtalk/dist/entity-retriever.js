"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SequentialEntityAllocator = exports.EntityRetriever = exports.AbstractEntityRetriever = void 0;
const assert_1 = __importDefault(require("assert"));
const util = __importStar(require("util"));
const date_utils_1 = require("./utils/date_utils");
const list_1 = __importDefault(require("./utils/list"));
const syntax_api_1 = require("./syntax_api");
const polyfill_1 = require("@js-temporal/polyfill");
const EPSILON = 1e-8;
function entitiesEqual(type, one, two, timezone) {
    if (one === two)
        return true;
    if (!one || !two)
        return false;
    if (type.startsWith('GENERIC_ENTITY_')) {
        const eone = one;
        const etwo = two;
        if (!eone.value && !etwo.value)
            return eone.display === etwo.display;
        return (eone.value === etwo.value);
    }
    if (type.startsWith('MEASURE_') ||
        type === 'DURATION') {
        const eone = one;
        const etwo = two;
        return eone.value === etwo.value && eone.unit === etwo.unit;
    }
    switch (type) {
        case 'CURRENCY': {
            const eone = one;
            const etwo = two;
            return eone.value === etwo.value && eone.unit === etwo.unit;
        }
        case 'TIME': {
            const eone = one;
            const etwo = two;
            return eone.hour === etwo.hour &&
                eone.minute === etwo.minute &&
                (eone.second || 0) === (etwo.second || 0);
        }
        case 'DATE':
            if (!(one instanceof Date))
                one = (0, date_utils_1.parseDate)(one, timezone);
            if (!(two instanceof Date))
                two = (0, date_utils_1.parseDate)(two, timezone);
            return +one === +two;
        case 'LOCATION': {
            const eone = one;
            const etwo = two;
            if (isNaN(eone.latitude) && isNaN(etwo.latitude) && isNaN(eone.longitude) && isNaN(etwo.longitude))
                return eone.display === etwo.display;
            return Math.abs(eone.latitude - etwo.latitude) < EPSILON &&
                Math.abs(eone.longitude - etwo.longitude) < EPSILON;
        }
    }
    return false;
}
function entityToString(entityType, entity) {
    if ((entityType.startsWith('GENERIC_ENTITY_') || entityType === 'LOCATION')) {
        const generic = entity;
        if (generic.display)
            return generic.display;
        if (generic.value)
            return generic.value;
    }
    return String(entity);
}
/**
 * Abstract class capable of allocating entity numbers when converting
 * ThingTalk code to NN syntax (which uses numbered entities matching the input sentence).
 */
class AbstractEntityRetriever {
    constructor(options) {
        var _a;
        this._timezone = (_a = options.timezone) !== null && _a !== void 0 ? _a : polyfill_1.Temporal.Now.timeZone().id;
        this._syntaxType = syntax_api_1.SyntaxType.LegacyNN;
    }
    get timezone() {
        return this._timezone;
    }
    setSyntaxType(syntaxType) {
        this._syntaxType = syntaxType;
    }
}
exports.AbstractEntityRetriever = AbstractEntityRetriever;
/**
 * Entity retriever that looks for an entity in the tokenized entities, if any, and then
 * falls back to string matching in the sentence.
 */
class EntityRetriever extends AbstractEntityRetriever {
    constructor(sentence, entities, options) {
        super(options);
        if (typeof sentence === 'string')
            sentence = sentence.split(' ');
        this.sentence = sentence;
        this.entities = {};
        Object.assign(this.entities, entities);
    }
    _sentenceContains(tokens) {
        for (let i = 0; i <= this.sentence.length - tokens.length; i++) {
            let found = true;
            for (let j = 0; j < tokens.length; j++) {
                if (tokens[j] !== this.sentence[i + j]) {
                    found = false;
                    break;
                }
            }
            if (found)
                return true;
        }
        return false;
    }
    /**
     * Match an entity from the sentence.
     *
     * This method should search for the entity string in the sentence, and return the value
     * to predict in NN-syntax, or `undefined` if the entity is not mentioned.
     * This method can be overridden to implement custom tokenization or normalization.
     *
     * @param {string} entityType - the entity type (USERNAME, HASHTAG, QUOTED_STRING, etc.)
     * @param {string} entityString - the string to search
     * @param {boolean} ignoreNotFound - ignore if the entity is not mentioned; subclasses can
     *   use this to hallucinate entities that are not mentioned, when `ignoreNotFound` is false
     * @return the tokens to predict, or `undefined` if the entity is not mentioned in the sentence.
     */
    _findEntityFromSentence(entityType, entityString, ignoreNotFound) {
        const entityTokens = entityString.toLowerCase().split(' ');
        const found = this._sentenceContains(entityTokens);
        if (found)
            return entityTokens;
        else
            return undefined;
    }
    /**
     * Match a numeric entity from the sentence.
     *
     * This method should search for a mention of the number in the sentence, and return the value
     * to predict in NN-syntax, or `undefined` if the entity is not mentioned.
     * This method can be overridden to implement custom tokenization or normalization.
     *
     * @param {string} entityType - the numeric entity type (NUMBER, MEASURE, CURRENCY, etc.)
     * @param {number} number - the number to search
     * @param {boolean} ignoreNotFound - ignore if the number is not mentioned; subclasses can
     *   use this to hallucinate entities that are not mentioned, when `ignoreNotFound` is false
     * @return the tokens to predict, or `undefined` if the entity is not mentioned in the sentence.
     */
    _findNumberFromSentence(entityType, number, ignoreNotFound) {
        // by default, we normalize using JS syntax for numbers: "." for decimal
        // separator, and no thousand separator
        const entityTokens = [String(number)];
        const found = this._sentenceContains(entityTokens);
        if (found)
            return entityTokens;
        else
            return undefined;
    }
    _findStringLikeEntity(entityType, entity, entityString, ignoreNotFound, includeEntityValue) {
        if (entityType === 'DATE') {
            const dateStr = entity.toISOString();
            if (this._sentenceContains([dateStr]))
                return list_1.default.concat('new', 'Date', '(', '"', dateStr, '"', ')');
        }
        if (entityType === 'NUMBER') {
            const found = this._findNumberFromSentence(entityType, entity, ignoreNotFound);
            if (found) // ignore the returned tokens, and always predict normalized English-like syntax
                return list_1.default.singleton(String(entity));
        }
        if (entityType === 'CURRENCY' || entityType === 'DURATION' || entityType.startsWith('MEASURE_')) {
            const measure = entity;
            const found = this._findNumberFromSentence(entityType, measure.value, ignoreNotFound);
            if (found) // ignore the returned tokens, and always predict normalized English-like syntax
                return list_1.default.concat(String(measure.value), entityType === 'CURRENCY' ? ('$' + measure.unit) : measure.unit);
        }
        if (entityType === 'QUOTED_STRING' || entityType === 'HASHTAG' || entityType === 'USERNAME' ||
            entityType === 'PATH_NAME' || entityType === 'URL' || entityType === 'PHONE_NUMBER' ||
            entityType === 'EMAIL_ADDRESS' || entityType === 'LOCATION' || entityType.startsWith('GENERIC_ENTITY_')) {
            const found = this._findEntityFromSentence(entityType, entityString, ignoreNotFound);
            if (found) {
                if (entityType === 'QUOTED_STRING')
                    return list_1.default.concat('"', ...found, '"');
                else if (entityType === 'HASHTAG')
                    return list_1.default.concat('"', ...found, '"', '^^tt:hashtag');
                else if (entityType === 'USERNAME')
                    return list_1.default.concat('"', ...found, '"', '^^tt:username');
                else if (entityType === 'PATH_NAME')
                    return list_1.default.concat('"', ...found, '"', '^^tt:path_name');
                else if (entityType === 'URL')
                    return list_1.default.concat('"', ...found, '"', '^^tt:url');
                else if (entityType === 'PHONE_NUMBER')
                    return list_1.default.concat('"', ...found, '"', '^^tt:phone_number');
                else if (entityType === 'EMAIL_ADDRESS')
                    return list_1.default.concat('"', ...found, '"', '^^tt:email_address');
                if (this._syntaxType === syntax_api_1.SyntaxType.LegacyNN) {
                    if (entityType === 'LOCATION')
                        return list_1.default.concat('location:', '"', ...found, '"');
                    else
                        return list_1.default.concat('"', ...found, '"', '^^' + entityType.substring('GENERIC_ENTITY_'.length));
                }
                else {
                    if (entityType === 'LOCATION') {
                        return list_1.default.concat('new', 'Location', '(', '"', ...found, '"', ')');
                    }
                    else {
                        const genericEntity = entity;
                        const entityId = includeEntityValue && genericEntity.value ? ['"', ...genericEntity.value.split(' '), '"'] : ['null'];
                        return list_1.default.concat(...entityId, '^^' + entityType.substring('GENERIC_ENTITY_'.length), '(', '"', ...found, '"', ')');
                    }
                }
            }
        }
        // always predict (not copy) these entities if they are missing from the sentence
        // (the neural model will learn the names of the devices
        if (entityType === 'GENERIC_ENTITY_tt:device') {
            const value = entity.value;
            if (this._syntaxType === syntax_api_1.SyntaxType.LegacyNN)
                return list_1.default.singleton('device:' + value);
            else
                return list_1.default.singleton('@' + value);
        }
        if (entityType === 'GENERIC_ENTITY_tt:function') {
            const value = entity.value;
            if (this._syntaxType === syntax_api_1.SyntaxType.LegacyNN) {
                return list_1.default.singleton('@' + value);
            }
            else {
                const dot = value.lastIndexOf('.');
                const kind = value.substring(0, dot);
                const name = value.substring(dot + 1, value.length);
                return list_1.default.concat('@' + kind, '.', name);
            }
        }
        return undefined;
    }
    _findEntityInBag(entityType, value, entities) {
        for (const what in entities) {
            if (!what.startsWith(entityType + '_'))
                continue;
            if (entitiesEqual(entityType, entities[what], value, this._timezone))
                return list_1.default.singleton(what);
        }
        return undefined;
    }
    findEntity(entityType, entity, { ignoreNotFound = false, includeEntityValue = false } = {}) {
        const entityString = entityToString(entityType, entity);
        // try in the sentence before we look in the bag of entities (which comes from the context)
        // this is so that we predict
        // " foo " ^^tt:whatever
        // if the sentence contains "foo", regardless of whether GENERIC_ENTITY_tt:whatever_0 is "foo" or not
        let found = this._findStringLikeEntity(entityType, entity, entityString, true, includeEntityValue);
        if (found)
            return found;
        found = this._findEntityInBag(entityType, entity, this.entities);
        if (found)
            return found;
        if (ignoreNotFound)
            return null;
        if (entityType.startsWith('GENERIC_ENTITY_') && this._syntaxType === syntax_api_1.SyntaxType.Tokenized) {
            const genericEntity = entity;
            if (genericEntity.display) {
                found = this._findEntityInBag('QUOTED_STRING', genericEntity.display, this.entities);
                if (found) {
                    const entityId = includeEntityValue && genericEntity.value ? ['"', genericEntity.value, '"'] : ['null'];
                    return list_1.default.concat(...entityId, '^^' + entityType.substring('GENERIC_ENTITY_'.length), '(', found, ')');
                }
            }
        }
        found = this._findStringLikeEntity(entityType, entity, entityString, false, includeEntityValue);
        if (found)
            return found;
        throw new Error(`Cannot find entity ${entityString} of type ${entityType}, have ${util.inspect(this.entities)}`);
    }
}
exports.EntityRetriever = EntityRetriever;
class SequentialEntityAllocator extends AbstractEntityRetriever {
    constructor(entities, options) {
        super(options);
        this.offsets = {};
        this.entities = entities;
        this.explicitStrings = !!options.explicitStrings;
        this.updateOffsets();
    }
    reset() {
        this.offsets = {};
        this.entities = {};
    }
    updateOffsets() {
        for (const entity in this.entities) {
            const entityType = entity.slice(0, entity.lastIndexOf('_'));
            const offset = entity.slice(entity.lastIndexOf('_') + 1);
            (0, assert_1.default)(/^\d+$/.test(offset));
            this.offsets[entityType] = Math.max((this.offsets[entityType] || -1), parseInt(offset) + 1);
        }
    }
    findEntity(entityType, entity, { ignoreNotFound = false, includeEntityValue = false } = {}) {
        if (this.explicitStrings &&
            (entityType === 'QUOTED_STRING' || entityType === 'HASHTAG' || entityType === 'USERNAME' ||
                entityType === 'LOCATION' || entityType.startsWith('GENERIC_ENTITY_'))) {
            const entityString = entityToString(entityType, entity).split(' ');
            if (entityType === 'QUOTED_STRING')
                return list_1.default.concat('"', ...entityString, '"');
            else if (entityType === 'HASHTAG')
                return list_1.default.concat('"', ...entityString, '"', '^^tt:hashtag');
            else if (entityType === 'USERNAME')
                return list_1.default.concat('"', ...entityString, '"', '^^tt:username');
            if (this._syntaxType === syntax_api_1.SyntaxType.LegacyNN) {
                if (entityType === 'LOCATION')
                    return list_1.default.concat('location:', '"', ...entityString, '"');
                else
                    return list_1.default.concat('"', ...entityString, '"', '^^' + entityType.substring('GENERIC_ENTITY_'.length));
            }
            else {
                if (entityType === 'LOCATION') {
                    return list_1.default.concat('new', 'Location', '(', '"', ...entityString, '"', ')');
                }
                else {
                    const genericEntity = entity;
                    const entityId = includeEntityValue && genericEntity.value ? ['"', genericEntity.value, '"'] : ['null'];
                    return list_1.default.concat(...entityId, '^^' + entityType.substring('GENERIC_ENTITY_'.length), '(', '"', ...entityString, '"', ')');
                }
            }
        }
        for (const what in this.entities) {
            if (!what.startsWith(entityType + '_'))
                continue;
            if (entitiesEqual(entityType, this.entities[what], entity, this._timezone))
                return list_1.default.singleton(what);
        }
        let num;
        if (entityType in this.offsets) {
            num = this.offsets[entityType];
            this.offsets[entityType] += 1;
        }
        else {
            num = 0;
            this.offsets[entityType] = 1;
        }
        const key = entityType + '_' + num;
        this.entities[key] = entity;
        return list_1.default.singleton(key);
    }
}
exports.SequentialEntityAllocator = SequentialEntityAllocator;
//# sourceMappingURL=entity-retriever.js.map