"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
Object.defineProperty(exports, "__esModule", { value: true });
exports.createParser = void 0;
const errors_1 = require("./errors");
const EOF_TOKEN = ' 1EOF';
function findExpected(actions, terminalIds) {
    const ret = [];
    for (const tokenId in actions) {
        for (const term in terminalIds) {
            if (terminalIds[term] === Number(tokenId)) {
                ret.push(term);
                break;
            }
        }
    }
    return ret;
}
function mergeRanges(l1, l2) {
    if (l1 === null)
        return l2;
    if (l2 === null)
        return l1;
    return {
        start: {
            offset: Math.min(l1.start.offset, l2.start.offset),
            line: Math.min(l1.start.line, l2.start.line),
            column: Math.min(l1.start.column, l2.start.column),
            token: Math.min(l1.start.token, l2.start.token),
        },
        end: {
            offset: Math.max(l1.end.offset, l2.end.offset),
            line: Math.max(l1.end.line, l2.end.line),
            column: Math.max(l1.end.column, l2.end.column),
            token: Math.max(l1.end.token, l2.end.token),
        }
    };
}
function tokenToString(tok) {
    if (typeof tok === 'string')
        return tok;
    else
        return tok.token;
}
function createParser({ TERMINAL_IDS, RULE_NON_TERMINALS, ARITY, GOTO, PARSER_ACTION, SEMANTIC_ACTION }) {
    return class ShiftReduceParser {
        constructor(options) {
            this._options = options;
        }
        _helper(sequence, applySemanticAction) {
            const iterator = sequence[Symbol.iterator]();
            let state = 0;
            const stack = [0];
            const results = [null];
            const output = [];
            const locations = [null];
            let currentLocation = null;
            let tokenno = 0;
            let { done, value: nextToken } = iterator.next();
            if (!done) {
                currentLocation = nextToken.location;
                if (currentLocation) {
                    currentLocation.start.token = tokenno;
                    currentLocation.end.token = tokenno + 1;
                }
                tokenno++;
            }
            const $ = {
                ...this._options,
                location: currentLocation,
                error(msg) {
                    throw new errors_1.ThingTalkSyntaxError(msg, currentLocation);
                }
            };
            for (;;) {
                if (done)
                    nextToken = EOF_TOKEN;
                const nextTokenId = TERMINAL_IDS[tokenToString(nextToken)];
                if (!(nextTokenId in PARSER_ACTION[state]))
                    throw new errors_1.ThingTalkSyntaxError(`Parse error: unexpected token ${nextToken} in state ${state}, expected ${findExpected(PARSER_ACTION[state], TERMINAL_IDS)}`, currentLocation);
                const [action, param] = PARSER_ACTION[state][nextTokenId];
                if (action === 0 /* Accept */) // accept
                    return [output, results[1]];
                if (action === 1 /* Shift */) { // shift
                    state = param;
                    stack.push(state);
                    results.push(nextToken);
                    ({ done, value: nextToken } = iterator.next());
                    if (!done) {
                        currentLocation = nextToken.location;
                        if (currentLocation) {
                            currentLocation.start.token = tokenno;
                            currentLocation.end.token = tokenno + 1;
                        }
                        tokenno++;
                    }
                }
                else { // reduce
                    const ruleId = param;
                    output.push(ruleId);
                    const arity = ARITY[ruleId];
                    const args = results.slice(results.length - arity, results.length);
                    const locs = locations.slice(locations.length - arity, locations.length);
                    for (let i = 0; i < arity; i++) {
                        stack.pop();
                        results.pop();
                    }
                    state = stack[stack.length - 1];
                    const lhs = RULE_NON_TERMINALS[ruleId];
                    const nextState = GOTO[state][lhs];
                    state = nextState;
                    stack.push(nextState);
                    if (applySemanticAction) {
                        const action = SEMANTIC_ACTION[ruleId];
                        let ruleLocation = null;
                        for (const loc of locs)
                            ruleLocation = mergeRanges(ruleLocation, loc);
                        $.location = ruleLocation;
                        results.push(action($, ...args));
                    }
                    else {
                        results.push(null);
                    }
                }
            }
        }
        parse(sequence) {
            const [, ast] = this._helper(sequence, true);
            return ast;
        }
        getReduceSequence(sequence) {
            const [reduces,] = this._helper(sequence, false);
            return reduces;
        }
    };
}
exports.createParser = createParser;
//# sourceMappingURL=sr_parser_runtime.js.map