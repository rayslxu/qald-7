"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2016-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.flipOperator = exports.isUnaryExpressionOp = exports.isUnaryTableToStreamOp = exports.isUnaryStreamToStreamOp = exports.isUnaryStreamToTableOp = exports.isUnaryTableToTableOp = exports.getSchemaForSelector = exports.getPropertyPathName = exports.getScalarExpressionName = exports.split = exports.cleanKind = exports.clean = void 0;
const Ast = __importStar(require("../ast"));
function clean(name) {
    if (/^[vwgp]_/.test(name))
        name = name.substr(2);
    return name.replace(/_/g, ' ').replace(/([^A-Z ])([A-Z])/g, '$1 $2').toLowerCase();
}
exports.clean = clean;
function cleanKind(kind) {
    // thingengine.phone -> phone
    if (kind.startsWith('org.thingpedia.builtin.thingengine.'))
        kind = kind.substr('org.thingpedia.builtin.thingengine.'.length);
    // org.thingpedia.builtin.omlet -> omlet
    if (kind.startsWith('org.thingpedia.builtin.'))
        kind = kind.substr('org.thingpedia.builtin.'.length);
    // org.thingpedia.weather -> weather
    if (kind.startsWith('org.thingpedia.'))
        kind = kind.substr('org.thingpedia.'.length);
    // io.home-assistant.battery -> battery
    if (kind.startsWith('io.home-assistant.'))
        kind = kind.substr('io.home-assistant.'.length);
    // com.xkcd -> xkcd
    if (kind.startsWith('com.'))
        kind = kind.substr('com.'.length);
    if (kind.startsWith('gov.'))
        kind = kind.substr('gov.'.length);
    if (kind.startsWith('org.'))
        kind = kind.substr('org.'.length);
    if (kind.startsWith('uk.co.'))
        kind = kind.substr('uk.co.'.length);
    kind = kind.replace(/[.-]/g, ' ');
    return clean(kind);
}
exports.cleanKind = cleanKind;
function* split(pattern, regexp) {
    // a split that preserves capturing parenthesis
    const clone = new RegExp(regexp, 'g');
    let match = clone.exec(pattern);
    let i = 0;
    while (match !== null) {
        if (match.index > i)
            yield pattern.substring(i, match.index);
        yield match;
        i = clone.lastIndex;
        match = clone.exec(pattern);
    }
    if (i < pattern.length)
        yield pattern.substring(i, pattern.length);
}
exports.split = split;
function getScalarExpressionName(ast) {
    if (ast instanceof Ast.VarRefValue)
        return ast.name;
    if (ast instanceof Ast.ComputationValue && /^[a-zA-Z0-9]+$/.test(ast.op))
        return ast.op;
    else if (ast instanceof Ast.FilterValue || ast instanceof Ast.ArrayFieldValue)
        return getScalarExpressionName(ast.value);
    else
        return 'result';
}
exports.getScalarExpressionName = getScalarExpressionName;
function getPropertyPathName(sequence) {
    return sequence.map((elem) => elem.toString()).join('/');
}
exports.getPropertyPathName = getPropertyPathName;
async function getSchemaForSelector(schemaRetriever, kind, name, schemaType, getMeta = false, classes = {}) {
    if (kind in classes) {
        const classDef = classes[kind];
        const where = schemaRetriever._where(schemaType);
        if (where === 'both') {
            if (!(name in classDef.queries) && !(name in classDef.actions))
                throw new TypeError(`Class ${kind} has no function ${name}`);
            return classDef.queries[name] || classDef.actions[name];
        }
        else {
            if (!(name in classDef[where]))
                throw new TypeError(`Class ${kind} has no ${schemaType} ${name}`);
            return classDef[where][name];
        }
    }
    if (getMeta)
        return schemaRetriever.getMeta(kind, schemaType, name);
    else
        return schemaRetriever.getSchemaAndNames(kind, schemaType, name);
}
exports.getSchemaForSelector = getSchemaForSelector;
function isUnaryTableToTableOp(table) {
    return table.isFilter ||
        table.isProjection ||
        table.isCompute ||
        table.isAlias ||
        table.isAggregation ||
        table.isSort ||
        table.isIndex ||
        table.isSlice;
}
exports.isUnaryTableToTableOp = isUnaryTableToTableOp;
function isUnaryStreamToTableOp(table) {
    return false;
}
exports.isUnaryStreamToTableOp = isUnaryStreamToTableOp;
function isUnaryStreamToStreamOp(stream) {
    return stream.isEdgeNew ||
        stream.isEdgeFilter ||
        stream.isFilter ||
        stream.isProjection ||
        stream.isCompute ||
        stream.isAlias;
}
exports.isUnaryStreamToStreamOp = isUnaryStreamToStreamOp;
function isUnaryTableToStreamOp(stream) {
    return stream.isMonitor;
}
exports.isUnaryTableToStreamOp = isUnaryTableToStreamOp;
function isUnaryExpressionOp(expression) {
    return expression instanceof Ast.FilterExpression ||
        expression instanceof Ast.ProjectionExpression ||
        expression instanceof Ast.AliasExpression ||
        expression instanceof Ast.AggregationExpression ||
        expression instanceof Ast.SortExpression ||
        expression instanceof Ast.IndexExpression ||
        expression instanceof Ast.SliceExpression;
}
exports.isUnaryExpressionOp = isUnaryExpressionOp;
function flipOperator(op) {
    switch (op) {
        case '==':
        case '!=':
            return op;
        case '<':
            return '>';
        case '<=':
            return '>=';
        case '>':
            return '<';
        case '>=':
            return '<=';
        case 'contains':
            return 'in_array';
        case 'contains~':
            return '~in_array';
        case '~contains':
            return 'in_array~';
        case 'in_array':
            return 'contains';
        case 'in_array~':
            return '~contains';
        case '~in_array':
            return 'contains~';
        case '=~':
            return '~=';
        case '~=':
            return '=~';
        case 'group_member':
            return 'has_member';
        case 'has_member':
            return 'group_member';
        case 'starts_with':
            return 'prefix_of';
        case 'prefix_of':
            return 'starts_with';
        case 'ends_with':
            return 'suffix_of';
        case 'suffix_of':
            return 'ends_with';
        default:
            throw new TypeError('invalid operator ' + op);
    }
}
exports.flipOperator = flipOperator;
//# sourceMappingURL=index.js.map