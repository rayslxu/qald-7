import * as Ast from '../ast';
import type { ExecEnvironment } from '../runtime/exec_environment';
interface Instruction {
    codegen(prefix: string): string;
}
declare type Register = number;
declare class Block {
    private _instructions;
    constructor();
    add(instr: Instruction): void;
    codegen(prefix: string): string;
}
declare class Copy {
    private _what;
    private _into;
    constructor(what: Register, into: Register);
    codegen(prefix: string): string;
}
declare class CreateTuple {
    private _size;
    private _into;
    constructor(size: number, into: Register);
    codegen(prefix: string): string;
}
declare class CreateObject {
    private _into;
    constructor(into: Register);
    codegen(prefix: string): string;
}
declare class SetIndex {
    private _tuple;
    private _idx;
    private _value;
    constructor(tuple: Register, idx: number, value: Register);
    codegen(prefix: string): string;
}
declare class GetIndex {
    private _tuple;
    private _idx;
    private _into;
    constructor(tuple: Register, idx: number, into: Register);
    codegen(prefix: string): string;
}
declare class GetASTObject {
    private _idx;
    private _into;
    constructor(idx: number, into: Register);
    codegen(prefix: string): string;
}
declare class GetKey {
    private _object;
    private _key;
    private _into;
    constructor(object: Register, key: string, into: Register);
    codegen(prefix: string): string;
}
declare class SetKey {
    private _object;
    private _key;
    private _value;
    constructor(object: Register, key: string, value: Register | null);
    codegen(prefix: string): string;
}
declare class GetVariable {
    private _variable;
    private _into;
    constructor(variable: string, into: Register);
    codegen(prefix: string): string;
}
declare class GetEnvironment {
    private _variable;
    private _into;
    constructor(variable: string, into: Register);
    codegen(prefix: string): string;
}
declare class GetScope {
    private _name;
    private _into;
    constructor(name: string, into: Register);
    codegen(prefix: string): string;
}
declare class AsyncIterator {
    private _into;
    private _iterable;
    constructor(into: Register, iterable: Register);
    codegen(prefix: string): string;
}
declare class LoadConstant {
    private _constant;
    private _into;
    constructor(constant: Ast.Value | null, into: Register);
    codegen(prefix: string): string;
}
declare class LoadBuiltin {
    private _builtin;
    private _into;
    constructor(builtin: string, into: Register);
    codegen(prefix: string): string;
}
declare class NewObject {
    private _class;
    private _into;
    private _args;
    constructor(classname: string, into: Register, ...args: Register[]);
    codegen(prefix: string): string;
}
declare class MapAndReadField {
    private _into;
    private _array;
    private _field;
    constructor(into: Register, array: Register, field: string);
    codegen(prefix: string): string;
}
declare class FormatEvent {
    private _hint;
    private _outputType;
    private _output;
    private _into;
    constructor(hint: string, outputType: Register, output: Register, into: Register);
    codegen(prefix: string): string;
}
declare class VoidFunctionOp {
    private _fn;
    private _args;
    constructor(fn: string, ...args: Register[]);
    codegen(prefix: string): string;
}
declare class FunctionOp {
    private _fn;
    private _into;
    private _args;
    private _passEnv;
    constructor(fn: string, passEnv: boolean, into: Register, ...args: Register[]);
    codegen(prefix: string): string;
}
declare class BinaryOp {
    private _a;
    private _b;
    private _op;
    private _into;
    constructor(a: Register, b: Register, op: string, into: Register);
    codegen(prefix: string): string;
}
declare class UnaryOp {
    private _v;
    private _op;
    private _into;
    constructor(v: Register, op: string, into: Register);
    codegen(prefix: string): string;
}
declare class MethodOp {
    private _obj;
    private _args;
    private _op;
    constructor(obj: Register, op: string, ...args: Register[]);
    codegen(prefix: string): string;
}
declare class EnterProcedure {
    private _procid;
    private _procname;
    constructor(procid: number, procname?: string | null);
    codegen(prefix: string): string;
}
declare class ExitProcedure {
    private _procid;
    private _procname;
    constructor(procid: number, procname?: string | null);
    codegen(prefix: string): string;
}
interface QueryInvocationHints {
    projection: string[];
    filter?: Register;
    sort?: [string, 'asc' | 'desc'];
    limit?: number;
}
export declare type AttributeMap = {
    [key: string]: unknown;
};
declare class InvokeMonitor {
    private _kind;
    private _attrs;
    private _fname;
    private _into;
    private _args;
    private _hints;
    constructor(kind: string, attrs: {
        [key: string]: unknown;
    }, fname: string, into: Register, args: Register, hints: QueryInvocationHints);
    codegen(prefix: string): string;
}
declare class InvokeTimer {
    private _into;
    private _base;
    private _interval;
    private _frequency;
    constructor(into: Register, base: Register, interval: Register, frequency: Register | null);
    codegen(prefix: string): string;
}
declare class InvokeAtTimer {
    private _into;
    private _time;
    private _expiration_date;
    constructor(into: Register, time: Register, expiration_date: Register | null);
    codegen(prefix: string): string;
}
declare class InvokeOnTimer {
    private _into;
    private _date;
    constructor(into: Register, date: Register);
    codegen(prefix: string): string;
}
declare class InvokeQuery {
    private _kind;
    private _attrs;
    private _fname;
    private _into;
    private _args;
    private _hints;
    constructor(kind: string, attrs: AttributeMap, fname: string, into: Register, args: Register, hints: QueryInvocationHints);
    codegen(prefix: string): string;
}
declare class InvokeDBQuery {
    private _kind;
    private _attrs;
    private _into;
    private _query;
    constructor(kind: string, attrs: AttributeMap, into: Register, query: Register);
    codegen(prefix: string): string;
}
declare class InvokeStreamVarRef {
    private _name;
    private _into;
    private _args;
    constructor(name: Register, into: Register, args: Register[]);
    codegen(prefix: string): string;
}
declare class InvokeAction {
    private _kind;
    private _attrs;
    private _fname;
    private _into;
    private _args;
    constructor(kind: string, attrs: AttributeMap, fname: string, into: Register, args: Register);
    codegen(prefix: string): string;
}
declare class InvokeOutput {
    private _outputType;
    private _output;
    constructor(outputType: Register, output: Register);
    codegen(prefix: string): string;
}
declare class InvokeReadState {
    private _into;
    private _stateId;
    constructor(into: Register, stateId: number);
    codegen(prefix: string): string;
}
declare class InvokeWriteState {
    private _state;
    private _stateId;
    constructor(state: Register, stateId: number);
    codegen(prefix: string): string;
}
declare class CheckIsNewTuple {
    private _into;
    private _state;
    private _tuple;
    private _keys;
    constructor(into: Register, state: Register, tuple: Register, keys: string[]);
    codegen(prefix: string): string;
}
declare class AddTupleToState {
    private _into;
    private _state;
    private _tuple;
    constructor(into: Register, state: Register, tuple: Register);
    codegen(prefix: string): string;
}
declare class SendEndOfFlow {
    private _principal;
    private _flow;
    constructor(principal: Register, flow: Register);
    codegen(prefix: string): string;
}
declare class ClearGetCache {
    codegen(prefix: string): string;
}
declare class Break {
    codegen(prefix: string): string;
}
declare class IfStatement {
    private _cond;
    iftrue: Block;
    iffalse: Block;
    constructor(cond: Register);
    codegen(prefix: string): string;
}
declare class ForOfStatement {
    private _into;
    private _iterable;
    body: Block;
    constructor(into: Register, iterable: Register);
    codegen(prefix: string): string;
}
declare class AsyncWhileLoop {
    private _into;
    private _iterator;
    body: Block;
    constructor(into: Register, iterator: Register);
    codegen(prefix: string): string;
}
declare class AsyncFunctionExpression {
    private _into;
    body: Block;
    constructor(into: Register);
    codegen(prefix: string): string;
}
declare class ArrayFilterExpression {
    private _into;
    private _element;
    private _array;
    body: Block;
    constructor(into: Register, element: Register, array: Register);
    codegen(prefix: string): string;
}
declare class AsyncFunctionDeclaration {
    private _into;
    private _body;
    constructor(into: Register, body: IRBuilder);
    codegen(prefix: string): string;
}
declare class InvokeEmit {
    private _values;
    constructor(...values: Register[]);
    codegen(prefix: string): string;
}
declare class LabeledLoop {
    private _label;
    body: Block;
    constructor(label: string);
    codegen(prefix: string): string;
}
declare class LabeledBreak {
    private _label;
    constructor(label: string);
    codegen(prefix: string): string;
}
declare class LabeledContinue {
    private _label;
    constructor(label: string);
    codegen(prefix: string): string;
}
declare class TryCatch {
    private _message;
    try: Block;
    constructor(message: string);
    codegen(prefix: string): string;
}
declare class ReturnValue {
    private _value;
    constructor(value: Register);
    codegen(prefix: string): string;
}
declare type RegisterRange = [Register, Register];
declare type TopLevelScope = {
    [key: string]: unknown;
};
declare class IRBuilder {
    private _extraArgs;
    private _nArgs;
    private _baseRegister;
    private _nextRegister;
    private _skipRegisterRanges;
    private _nextLabel;
    private _root;
    private _blockStack;
    constructor(baseRegister?: number, extraArgs?: string[]);
    setBeginEndHooks(beginHook: Instruction | null, endHook: Instruction | null): void;
    get registerRange(): RegisterRange;
    get nextRegister(): Register;
    skipRegisterRange(range: RegisterRange): void;
    codegen(prefix?: string): string;
    codegenFunction(prefix?: string): string;
    compile(scope: TopLevelScope, asts: Ast.Node[]): (x: ExecEnvironment) => Promise<void>;
    private get _currentBlock();
    allocRegister(): Register;
    allocArgument(): Register;
    allocLabel(): number;
    pushBlock(block: Block): number;
    popBlock(): void;
    saveStackState(): number;
    popTo(upto: number): void;
    popAll(): void;
    add(instr: Instruction): void;
}
export { Register, IRBuilder, IfStatement, Copy, CreateTuple, CreateObject, GetIndex, SetIndex, GetKey, SetKey, GetASTObject, GetVariable, GetEnvironment, GetScope, AsyncIterator, LoadConstant, LoadBuiltin, NewObject, BinaryOp, UnaryOp, MethodOp, VoidFunctionOp, FunctionOp, MapAndReadField, FormatEvent, EnterProcedure, ExitProcedure, InvokeMonitor, InvokeTimer, InvokeAtTimer, InvokeOnTimer, InvokeQuery, InvokeDBQuery, InvokeStreamVarRef, InvokeAction, InvokeOutput, InvokeReadState, InvokeWriteState, InvokeEmit, CheckIsNewTuple, AddTupleToState, LabeledLoop, LabeledBreak, LabeledContinue, ReturnValue, ClearGetCache, SendEndOfFlow, ForOfStatement, AsyncWhileLoop, AsyncFunctionExpression, AsyncFunctionDeclaration, ArrayFilterExpression, Break, TryCatch };
