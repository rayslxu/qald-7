"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExpressionParameters = exports.getDefaultProjection = exports.readScopeVariables = exports.readResultKey = exports.isRemoteSend = exports.compileCast = exports.compileEvent = exports.compileUnaryOp = exports.getRegister = exports.typeForValue = void 0;
const assert_1 = __importDefault(require("assert"));
const Builtin = __importStar(require("../operators"));
const visitor_1 = __importDefault(require("../ast/visitor"));
const Ast = __importStar(require("../ast"));
const type_1 = __importDefault(require("../type"));
const JSIr = __importStar(require("./jsir"));
const scope_1 = __importDefault(require("./scope"));
function getRegister(name, scope) {
    const decl = scope.get(name);
    (0, assert_1.default)(decl.type === 'scalar');
    return decl.register;
}
exports.getRegister = getRegister;
function compileEvent(irBuilder, scope, name) {
    let reg;
    if (name === 'type') {
        return getRegister('$outputType', scope);
    }
    else if (name === 'program_id') {
        reg = irBuilder.allocRegister();
        irBuilder.add(new JSIr.GetEnvironment('program_id', reg));
    }
    else {
        const hint = name ? 'string-' + name : 'string';
        reg = irBuilder.allocRegister();
        irBuilder.add(new JSIr.FormatEvent(hint, getRegister('$outputType', scope), getRegister('$output', scope), reg));
    }
    return reg;
}
exports.compileEvent = compileEvent;
function typeForValue(ast, scope) {
    if (ast instanceof Ast.VarRefValue) {
        const decl = scope.get(ast.name);
        (0, assert_1.default)(decl.type === 'scalar');
        (0, assert_1.default)(decl.tt_type);
        return decl.tt_type;
    }
    else {
        return ast.getType();
    }
}
exports.typeForValue = typeForValue;
function compileUnaryOp(irBuilder, op, arg, into) {
    const unaryOp = Builtin.UnaryOps[op];
    if (unaryOp.op)
        irBuilder.add(new JSIr.UnaryOp(arg, unaryOp.op, into));
    else
        irBuilder.add(new JSIr.UnaryOp(arg, '__builtin.' + unaryOp.fn, into));
}
exports.compileUnaryOp = compileUnaryOp;
function compileCast(irBuilder, reg, type, toType) {
    if (type.equals(toType)) {
        if (type instanceof type_1.default.Entity && (type.type === 'tt:hashtag' || type.type === 'tt:username' || type.type === 'tt:picture')) {
            // for compatibility with the ton of devices that take inputs of these types, we auto-cast to string,
            // this is ok because these types don't really need .display that much
            const casted = irBuilder.allocRegister();
            irBuilder.add(new JSIr.UnaryOp(reg, 'String', casted));
            return casted;
        }
        return reg;
    }
    if (toType.isString) {
        const casted = irBuilder.allocRegister();
        irBuilder.add(new JSIr.UnaryOp(reg, 'String', casted));
        return casted;
    }
    if (type.isDate && toType.isTime) {
        const casted = irBuilder.allocRegister();
        compileUnaryOp(irBuilder, 'get_time', reg, casted);
        return casted;
    }
    if (type.isNumber && toType.isCurrency) {
        const casted = irBuilder.allocRegister();
        compileUnaryOp(irBuilder, 'get_currency', reg, casted);
        return casted;
    }
    return reg;
}
exports.compileCast = compileCast;
function isRemoteSend(fn) {
    const selector = fn.selector;
    return (selector.kind === 'org.thingpedia.builtin.thingengine.remote' || selector.kind.startsWith('__dyn_')) &&
        fn.channel === 'send';
}
exports.isRemoteSend = isRemoteSend;
/**
 * Read a parameter from a result object and put it in the current scope.
 *
 * This function handles nested compound types correctly, by checking that
 * the object is not null/undefined before reading.
 */
function readResultKey(irBuilder, currentScope, result, key, fullName, type, isInVarScopeNames) {
    const reg = irBuilder.allocRegister();
    irBuilder.add(new JSIr.GetKey(result, key, reg));
    currentScope.set(fullName, {
        type: 'scalar',
        tt_type: type,
        register: reg,
        direction: 'output',
        isInVarScopeNames
    });
    if (type instanceof type_1.default.Compound) {
        const ifStmt = new JSIr.IfStatement(reg);
        irBuilder.add(ifStmt);
        irBuilder.pushBlock(ifStmt.iftrue);
        for (const field in type.fields) {
            if (field.indexOf('.') >= 0)
                continue;
            const fieldtype = type.fields[field].type;
            readResultKey(irBuilder, currentScope, reg, field, fullName + '.' + field, fieldtype, false);
        }
        irBuilder.popBlock();
    }
}
exports.readResultKey = readResultKey;
/**
 * Reads all variables that are present in currentScope from the
 * passed-in result object.
 *
 * This is used to re-establish a scope at the end of an aggregation
 * or stream operation.
 *
 * @internal
 */
function readScopeVariables(irBuilder, currentScope, outputType, resultReg) {
    const newScope = new scope_1.default(currentScope.parent);
    newScope.set('$outputType', {
        type: 'scalar',
        tt_type: null,
        register: outputType,
        direction: 'special',
        isInVarScopeNames: false
    });
    newScope.set('$output', {
        type: 'scalar',
        tt_type: null,
        register: resultReg,
        direction: 'special',
        isInVarScopeNames: false
    });
    for (const name of currentScope.ownKeys()) {
        if (name.startsWith('$'))
            continue;
        // ignore nested names, readResultKey will take care of those
        if (name.indexOf('.') >= 0)
            continue;
        const currentScopeObj = currentScope.get(name);
        (0, assert_1.default)(currentScopeObj.type === 'scalar');
        readResultKey(irBuilder, newScope, resultReg, name, name, currentScopeObj.tt_type, currentScopeObj.isInVarScopeNames);
    }
    return newScope;
}
exports.readScopeVariables = readScopeVariables;
function getDefaultProjection(schema) {
    if (!schema)
        return [];
    if (schema.default_projection && schema.default_projection.length > 0)
        return schema.default_projection;
    // if no #[default_projection] is specified, then we project all
    // arguments
    const projection = [];
    for (const arg of schema.iterateArguments()) {
        if (!arg.is_input)
            projection.push(arg.name);
    }
    return projection;
}
exports.getDefaultProjection = getDefaultProjection;
class GetExpressionParameterVisitor extends visitor_1.default {
    constructor(schema) {
        super();
        this.schema = schema;
        this.names = new Set();
    }
    visitVarRefValue(value) {
        if (this.schema.hasArgument(value.name))
            this.names.add(value.name);
        return true;
    }
    visitAtomBooleanExpression(atom) {
        if (this.schema.hasArgument(atom.name))
            this.names.add(atom.name);
        return true;
    }
    visitDontCareBooleanExpression(atom) {
        if (this.schema.hasArgument(atom.name))
            this.names.add(atom.name);
        return true;
    }
}
/**
 * Compute all the parameters used in a filter or scalar expression
 *
 * This is a slight over-approximation, because it will also include parameters
 * in a get-predicate that have the same name. This is ok because it is only
 * used as a hint to the query function (which otherwise would have to return everything),
 * and I think the slight loss in performance is acceptable to keep the code complexity low.
 */
function getExpressionParameters(expression, schema) {
    const visitor = new GetExpressionParameterVisitor(schema);
    expression.visit(visitor);
    return visitor.names;
}
exports.getExpressionParameters = getExpressionParameters;
//# sourceMappingURL=utils.js.map