import * as Builtin from '../operators';
import * as Ast from '../ast';
import Type from '../type';
import * as JSIr from './jsir';
import Scope from './scope';
declare function getRegister(name: string, scope: Scope): JSIr.Register;
export declare type EventType = 'type' | 'program_id' | 'title' | 'body' | null;
declare function compileEvent(irBuilder: JSIr.IRBuilder, scope: Scope, name: EventType): JSIr.Register;
declare function typeForValue(ast: Ast.Value, scope: Scope): Type;
declare function compileUnaryOp(irBuilder: JSIr.IRBuilder, op: keyof typeof Builtin.UnaryOps, arg: JSIr.Register, into: JSIr.Register): void;
declare function compileCast(irBuilder: JSIr.IRBuilder, reg: JSIr.Register, type: Type, toType: Type): JSIr.Register;
declare function isRemoteSend(fn: Ast.Invocation): boolean;
/**
 * Read a parameter from a result object and put it in the current scope.
 *
 * This function handles nested compound types correctly, by checking that
 * the object is not null/undefined before reading.
 */
declare function readResultKey(irBuilder: JSIr.IRBuilder, currentScope: Scope, result: JSIr.Register, key: string, fullName: string, type: Type | null, isInVarScopeNames: boolean): void;
/**
 * Reads all variables that are present in currentScope from the
 * passed-in result object.
 *
 * This is used to re-establish a scope at the end of an aggregation
 * or stream operation.
 *
 * @internal
 */
declare function readScopeVariables(irBuilder: JSIr.IRBuilder, currentScope: Scope, outputType: JSIr.Register, resultReg: JSIr.Register): Scope;
declare function getDefaultProjection(schema: Ast.FunctionDef | null): string[];
/**
 * Compute all the parameters used in a filter or scalar expression
 *
 * This is a slight over-approximation, because it will also include parameters
 * in a get-predicate that have the same name. This is ok because it is only
 * used as a hint to the query function (which otherwise would have to return everything),
 * and I think the slight loss in performance is acceptable to keep the code complexity low.
 */
declare function getExpressionParameters(expression: Ast.Node, schema: Ast.FunctionDef): Set<string>;
export { typeForValue, getRegister, compileUnaryOp, compileEvent, compileCast, isRemoteSend, readResultKey, readScopeVariables, getDefaultProjection, getExpressionParameters };
