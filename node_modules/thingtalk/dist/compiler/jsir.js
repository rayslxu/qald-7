"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncFunctionDeclaration = exports.AsyncFunctionExpression = exports.AsyncWhileLoop = exports.ForOfStatement = exports.SendEndOfFlow = exports.ClearGetCache = exports.ReturnValue = exports.LabeledContinue = exports.LabeledBreak = exports.LabeledLoop = exports.AddTupleToState = exports.CheckIsNewTuple = exports.InvokeEmit = exports.InvokeWriteState = exports.InvokeReadState = exports.InvokeOutput = exports.InvokeAction = exports.InvokeStreamVarRef = exports.InvokeDBQuery = exports.InvokeQuery = exports.InvokeOnTimer = exports.InvokeAtTimer = exports.InvokeTimer = exports.InvokeMonitor = exports.ExitProcedure = exports.EnterProcedure = exports.FormatEvent = exports.MapAndReadField = exports.FunctionOp = exports.VoidFunctionOp = exports.MethodOp = exports.UnaryOp = exports.BinaryOp = exports.NewObject = exports.LoadBuiltin = exports.LoadConstant = exports.AsyncIterator = exports.GetScope = exports.GetEnvironment = exports.GetVariable = exports.GetASTObject = exports.SetKey = exports.GetKey = exports.SetIndex = exports.GetIndex = exports.CreateObject = exports.CreateTuple = exports.Copy = exports.IfStatement = exports.IRBuilder = void 0;
exports.TryCatch = exports.Break = exports.ArrayFilterExpression = void 0;
const assert_1 = __importDefault(require("assert"));
const Builtin = __importStar(require("../runtime/builtins"));
const escaping_1 = require("../utils/escaping");
// A sequence of instructions
class Block {
    constructor() {
        this._instructions = [];
    }
    add(instr) {
        this._instructions.push(instr);
    }
    codegen(prefix) {
        return this._instructions.map((i) => i.codegen(prefix)).join('\n');
    }
}
class Copy {
    constructor(what, into) {
        this._what = what;
        this._into = into;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = _t_${this._what};`;
    }
}
exports.Copy = Copy;
class CreateTuple {
    constructor(size, into) {
        this._size = size;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = new Array(' + this._size + ');';
    }
}
exports.CreateTuple = CreateTuple;
class CreateObject {
    constructor(into) {
        this._into = into;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = {};`;
    }
}
exports.CreateObject = CreateObject;
class SetIndex {
    constructor(tuple, idx, value) {
        this._tuple = tuple;
        this._idx = idx;
        this._value = value;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._tuple + '[' + this._idx + '] = _t_' + this._value + ';';
    }
}
exports.SetIndex = SetIndex;
class GetIndex {
    constructor(tuple, idx, into) {
        this._tuple = tuple;
        this._idx = idx;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = _t_' + this._tuple + '[' + this._idx + '];';
    }
}
exports.GetIndex = GetIndex;
class GetASTObject {
    constructor(idx, into) {
        this._idx = idx;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = __ast[' + this._idx + '];';
    }
}
exports.GetASTObject = GetASTObject;
class GetKey {
    constructor(object, key, into) {
        this._object = object;
        this._key = key;
        this._into = into;
    }
    codegen(prefix) {
        if (this._key.includes('.'))
            return `${prefix}_t_${this._into} = _t_${this._object}["${this._key}"];`;
        return `${prefix}_t_${this._into} = _t_${this._object}.${this._key};`;
    }
}
exports.GetKey = GetKey;
class SetKey {
    constructor(object, key, value) {
        this._object = object;
        this._key = key;
        this._value = value;
    }
    codegen(prefix) {
        if (this._value === null)
            return `${prefix}_t_${this._object}.${this._key} = null;`;
        else
            return `${prefix}_t_${this._object}.${this._key} = _t_${this._value};`;
    }
}
exports.SetKey = SetKey;
class GetVariable {
    constructor(variable, into) {
        this._variable = variable;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = __env._scope.' + this._variable + ';';
    }
}
exports.GetVariable = GetVariable;
class GetEnvironment {
    constructor(variable, into) {
        this._variable = variable;
        this._into = into;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = __env.${this._variable};`;
    }
}
exports.GetEnvironment = GetEnvironment;
class GetScope {
    constructor(name, into) {
        this._name = name;
        this._into = into;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = __scope.${this._name};`;
    }
}
exports.GetScope = GetScope;
class AsyncIterator {
    constructor(into, iterable) {
        this._iterable = iterable;
        this._into = into;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = __builtin.getAsyncIterator(_t_${this._iterable});`;
    }
}
exports.AsyncIterator = AsyncIterator;
function hasJSSource(x) {
    return typeof x === 'object' && x !== null && 'toJSSource' in x;
}
function anyToJS(js) {
    if (Array.isArray(js))
        return '[' + js.map(anyToJS).join(', ') + ']';
    if (typeof js === 'string')
        return (0, escaping_1.stringEscape)(js);
    if (hasJSSource(js))
        return js.toJSSource();
    if (js instanceof Date)
        return `new Date(${js.getTime()})`;
    return String(js);
}
function valueToJSSource(value) {
    if (value === null)
        return 'null';
    const js = value.toJS();
    return anyToJS(js);
}
class LoadConstant {
    constructor(constant, into) {
        this._constant = constant;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = ' + valueToJSSource(this._constant) + ';';
    }
}
exports.LoadConstant = LoadConstant;
class LoadBuiltin {
    constructor(builtin, into) {
        this._builtin = builtin;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = __builtin.' + this._builtin + ';';
    }
}
exports.LoadBuiltin = LoadBuiltin;
class NewObject {
    constructor(classname, into, ...args) {
        this._class = classname;
        this._into = into;
        this._args = args;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = new __builtin.${this._class}(${this._args.map((a) => '_t_' + a).join(', ')});`;
    }
}
exports.NewObject = NewObject;
class MapAndReadField {
    constructor(into, array, field) {
        this._into = into;
        this._array = array;
        this._field = field;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = _t_${this._array}.map(($) => $.${this._field});`;
    }
}
exports.MapAndReadField = MapAndReadField;
class FormatEvent {
    constructor(hint, outputType, output, into) {
        this._hint = hint;
        this._outputType = outputType;
        this._output = output;
        this._into = into;
    }
    codegen(prefix) {
        if (this._outputType === null)
            return `${prefix}_t_${this._into} = await __env.formatEvent(null, _t_${this._output}, ${(0, escaping_1.stringEscape)(this._hint)});`;
        else
            return `${prefix}_t_${this._into} = await __env.formatEvent(_t_${this._outputType}, _t_${this._output}, ${(0, escaping_1.stringEscape)(this._hint)});`;
    }
}
exports.FormatEvent = FormatEvent;
class VoidFunctionOp {
    constructor(fn, ...args) {
        this._fn = fn;
        this._args = args;
    }
    codegen(prefix) {
        return `${prefix}__builtin.${this._fn}(${this._args.map((a) => '_t_' + a).join(', ')});`;
    }
}
exports.VoidFunctionOp = VoidFunctionOp;
class FunctionOp {
    constructor(fn, passEnv, into, ...args) {
        this._fn = fn;
        this._into = into;
        this._args = args;
        this._passEnv = passEnv;
    }
    codegen(prefix) {
        if (this._passEnv)
            return `${prefix}_t_${this._into} = __builtin.${this._fn}(__env, ${this._args.map((a) => '_t_' + a).join(', ')});`;
        else
            return `${prefix}_t_${this._into} = __builtin.${this._fn}(${this._args.map((a) => '_t_' + a).join(', ')});`;
    }
}
exports.FunctionOp = FunctionOp;
class BinaryOp {
    constructor(a, b, op, into) {
        this._a = a;
        this._b = b;
        this._op = op;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = ' + '_t_' + this._a + ' ' + this._op + ' ' + '_t_' + this._b + ';';
    }
}
exports.BinaryOp = BinaryOp;
class UnaryOp {
    constructor(v, op, into) {
        this._v = v;
        this._op = op;
        this._into = into;
    }
    codegen(prefix) {
        return prefix + '_t_' + this._into + ' = ' + this._op + ' (' + '_t_' + this._v + ');';
    }
}
exports.UnaryOp = UnaryOp;
class MethodOp {
    constructor(obj, op, ...args) {
        this._obj = obj;
        this._args = args;
        this._op = op;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._obj}.${this._op}(${this._args.map((a) => '_t_' + a).join(', ')});`;
    }
}
exports.MethodOp = MethodOp;
function objectToJS(obj) {
    let buffer = '{ ';
    for (const key in obj)
        buffer += `${key}: ${anyToJS(obj[key])}, `;
    buffer += '}';
    return buffer;
}
class EnterProcedure {
    constructor(procid, procname = null) {
        this._procid = procid;
        this._procname = procname;
    }
    codegen(prefix) {
        return `${prefix}await __env.enterProcedure(${this._procid}, ${(0, escaping_1.stringEscape)(this._procname)});`;
    }
}
exports.EnterProcedure = EnterProcedure;
class ExitProcedure {
    constructor(procid, procname = null) {
        this._procid = procid;
        this._procname = procname;
    }
    codegen(prefix) {
        return `${prefix}await __env.exitProcedure(${this._procid}, ${(0, escaping_1.stringEscape)(this._procname)});`;
    }
}
exports.ExitProcedure = ExitProcedure;
function invocationHintsToJS(hints) {
    let buffer = `{ projection: [${hints.projection.map(escaping_1.stringEscape).join(', ')}]`;
    if (hints.filter !== undefined)
        buffer += `, filter: _t_${hints.filter}`;
    if (hints.sort !== undefined)
        buffer += `, sort: [${hints.sort.map(escaping_1.stringEscape).join(', ')}]`;
    if (hints.limit !== undefined)
        buffer += `, limit: ${hints.limit}`;
    buffer += ' }';
    return buffer;
}
class InvokeMonitor {
    constructor(kind, attrs, fname, into, args, hints) {
        this._kind = kind;
        this._attrs = attrs;
        this._fname = fname;
        this._into = into;
        this._args = args;
        this._hints = hints;
    }
    codegen(prefix) {
        const hints = invocationHintsToJS(this._hints);
        return `${prefix}_t_${this._into} = await __env.invokeMonitor(${(0, escaping_1.stringEscape)(this._kind)}, ${objectToJS(this._attrs)}, ${(0, escaping_1.stringEscape)(this._fname)}, _t_${this._args}, ${hints});`;
    }
}
exports.InvokeMonitor = InvokeMonitor;
class InvokeTimer {
    constructor(into, base, interval, frequency) {
        this._into = into;
        this._base = base;
        this._interval = interval;
        this._frequency = frequency;
    }
    codegen(prefix) {
        if (this._frequency)
            return `${prefix}_t_${this._into} = await __env.invokeTimer(_t_${this._base}, _t_${this._interval}, _t_${this._frequency});`;
        return `${prefix}_t_${this._into} = await __env.invokeTimer(_t_${this._base}, _t_${this._interval}, null);`;
    }
}
exports.InvokeTimer = InvokeTimer;
class InvokeAtTimer {
    constructor(into, time, expiration_date) {
        this._into = into;
        this._time = time;
        this._expiration_date = expiration_date;
    }
    codegen(prefix) {
        if (this._expiration_date)
            return `${prefix}_t_${this._into} = await __env.invokeAtTimer(_t_${this._time}, _t_${this._expiration_date});`;
        return `${prefix}_t_${this._into} = await __env.invokeAtTimer(_t_${this._time}, null);`;
    }
}
exports.InvokeAtTimer = InvokeAtTimer;
class InvokeOnTimer {
    constructor(into, date) {
        this._into = into;
        this._date = date;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = await __env.invokeOnTimer(_t_${this._date});`;
    }
}
exports.InvokeOnTimer = InvokeOnTimer;
class InvokeQuery {
    constructor(kind, attrs, fname, into, args, hints) {
        this._kind = kind;
        this._attrs = attrs;
        this._fname = fname;
        this._into = into;
        this._args = args;
        this._hints = hints;
    }
    codegen(prefix) {
        const hints = invocationHintsToJS(this._hints);
        return `${prefix}_t_${this._into} = await __env.invokeQuery(${(0, escaping_1.stringEscape)(this._kind)}, ${objectToJS(this._attrs)}, ${(0, escaping_1.stringEscape)(this._fname)}, _t_${this._args}, ${hints});`;
    }
}
exports.InvokeQuery = InvokeQuery;
class InvokeDBQuery {
    constructor(kind, attrs, into, query) {
        this._kind = kind;
        this._attrs = attrs;
        this._into = into;
        this._query = query;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = await __env.invokeDBQuery(${(0, escaping_1.stringEscape)(this._kind)}, ${objectToJS(this._attrs)}, _t_${this._query});`;
    }
}
exports.InvokeDBQuery = InvokeDBQuery;
class InvokeStreamVarRef {
    constructor(name, into, args) {
        this._name = name;
        this._into = into;
        this._args = args;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = await __builtin.invokeStreamVarRef(__env, _t_${this._name}${this._args.map((a) => ', _t_' + a).join('')});`;
    }
}
exports.InvokeStreamVarRef = InvokeStreamVarRef;
class InvokeAction {
    constructor(kind, attrs, fname, into, args) {
        this._kind = kind;
        this._attrs = attrs;
        this._fname = fname;
        this._into = into;
        this._args = args;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = __env.invokeAction(${(0, escaping_1.stringEscape)(this._kind)}, ${objectToJS(this._attrs)}, ${(0, escaping_1.stringEscape)(this._fname)}, _t_${this._args});`;
    }
}
exports.InvokeAction = InvokeAction;
class InvokeOutput {
    constructor(outputType, output) {
        this._outputType = outputType;
        this._output = output;
    }
    codegen(prefix) {
        return `${prefix}await __env.output(String(_t_${this._outputType}), _t_${this._output});`;
    }
}
exports.InvokeOutput = InvokeOutput;
class InvokeReadState {
    constructor(into, stateId) {
        this._into = into;
        this._stateId = stateId;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = await __env.readState(${this._stateId});`;
    }
}
exports.InvokeReadState = InvokeReadState;
class InvokeWriteState {
    constructor(state, stateId) {
        this._state = state;
        this._stateId = stateId;
    }
    codegen(prefix) {
        return `${prefix}await __env.writeState(${this._stateId}, _t_${this._state});`;
    }
}
exports.InvokeWriteState = InvokeWriteState;
class CheckIsNewTuple {
    constructor(into, state, tuple, keys) {
        this._into = into;
        this._state = state;
        this._tuple = tuple;
        this._keys = keys;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = __builtin.isNewTuple(_t_${this._state}, _t_${this._tuple}, [${this._keys.map(escaping_1.stringEscape).join(', ')}]);`;
    }
}
exports.CheckIsNewTuple = CheckIsNewTuple;
class AddTupleToState {
    constructor(into, state, tuple) {
        this._into = into;
        this._state = state;
        this._tuple = tuple;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = __builtin.addTuple(_t_${this._state}, _t_${this._tuple});`;
    }
}
exports.AddTupleToState = AddTupleToState;
class SendEndOfFlow {
    constructor(principal, flow) {
        this._principal = principal;
        this._flow = flow;
    }
    codegen(prefix) {
        return `${prefix}await __env.sendEndOfFlow(_t_${this._principal}, _t_${this._flow});`;
    }
}
exports.SendEndOfFlow = SendEndOfFlow;
class ClearGetCache {
    codegen(prefix) {
        return prefix + '__env.clearGetCache();';
    }
}
exports.ClearGetCache = ClearGetCache;
class Break {
    codegen(prefix) {
        return prefix + 'break;';
    }
}
exports.Break = Break;
class IfStatement {
    constructor(cond) {
        this._cond = cond;
        this.iftrue = new Block;
        this.iffalse = new Block;
    }
    codegen(prefix) {
        return prefix + 'if (_t_' + this._cond + ') {\n' +
            this.iftrue.codegen(prefix + '  ') + '\n'
            + prefix + '} else {\n' +
            this.iffalse.codegen(prefix + '  ') + '\n'
            + prefix + '}';
    }
}
exports.IfStatement = IfStatement;
class ForOfStatement {
    constructor(into, iterable) {
        this._into = into;
        this._iterable = iterable;
        this.body = new Block;
    }
    codegen(prefix) {
        return prefix + 'for (_t_' + this._into + ' of _t_' + this._iterable + ') {\n' +
            this.body.codegen(prefix + '  ') + '\n'
            + prefix + '}';
    }
}
exports.ForOfStatement = ForOfStatement;
class AsyncWhileLoop {
    constructor(into, iterator) {
        this._into = into;
        this._iterator = iterator;
        this.body = new Block;
    }
    codegen(prefix) {
        return prefix + '{\n' +
            prefix + '  let _iter_tmp = await _t_' + this._iterator + '.next();\n' +
            prefix + '  while (!_iter_tmp.done) {\n' +
            prefix + '    _t_' + this._into + ' = _iter_tmp.value;\n' +
            this.body.codegen(prefix + '    ') + '\n' +
            prefix + '    _iter_tmp = await _t_' + this._iterator + '.next();\n' +
            prefix + '  }\n' +
            prefix + '}';
    }
}
exports.AsyncWhileLoop = AsyncWhileLoop;
class AsyncFunctionExpression {
    constructor(into) {
        this._into = into;
        this.body = new Block;
    }
    codegen(prefix) {
        return prefix + `_t_${this._into} = async function(__emit) {\n` +
            this.body.codegen(prefix + '  ') + '\n' +
            prefix + '}';
    }
}
exports.AsyncFunctionExpression = AsyncFunctionExpression;
class ArrayFilterExpression {
    constructor(into, element, array) {
        this._into = into;
        this._element = element;
        this._array = array;
        this.body = new Block;
    }
    codegen(prefix) {
        return prefix + `_t_${this._into} = _t_${this._array}.filter((_t_${this._element}) => {\n` +
            this.body.codegen(prefix + '  ') + '\n' +
            prefix + '});';
    }
}
exports.ArrayFilterExpression = ArrayFilterExpression;
class AsyncFunctionDeclaration {
    constructor(into, body) {
        this._into = into;
        this._body = body;
    }
    codegen(prefix) {
        return `${prefix}_t_${this._into} = ${this._body.codegenFunction(prefix)};`;
    }
}
exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
class InvokeEmit {
    constructor(...values) {
        this._values = values;
    }
    codegen(prefix) {
        return `${prefix}__emit(${this._values.map((v) => '_t_' + v).join(', ')});`;
    }
}
exports.InvokeEmit = InvokeEmit;
class LabeledLoop {
    constructor(label) {
        this._label = label;
        this.body = new Block;
    }
    codegen(prefix) {
        return prefix + `_l_${this._label}: while (true) {\n` +
            this.body.codegen(prefix + '  ') + '\n' +
            prefix + '}';
    }
}
exports.LabeledLoop = LabeledLoop;
class LabeledBreak {
    constructor(label) {
        this._label = label;
    }
    codegen(prefix) {
        return `${prefix}break _l_${this._label};`;
    }
}
exports.LabeledBreak = LabeledBreak;
class LabeledContinue {
    constructor(label) {
        this._label = label;
    }
    codegen(prefix) {
        return `${prefix}continue _l_${this._label};`;
    }
}
exports.LabeledContinue = LabeledContinue;
class TryCatch {
    constructor(message) {
        this._message = message;
        this.try = new Block;
    }
    codegen(prefix) {
        return prefix + 'try {\n' +
            this.try.codegen(prefix + '  ') + '\n' +
            prefix + '} catch(_exc_) {\n' +
            prefix + '  __env.reportError(' + (0, escaping_1.stringEscape)(this._message) + ', _exc_);\n' +
            prefix + '}';
    }
}
exports.TryCatch = TryCatch;
class ReturnValue {
    constructor(value) {
        this._value = value;
    }
    codegen(prefix) {
        return prefix + `return _t_${this._value};`;
    }
}
exports.ReturnValue = ReturnValue;
class RootBlock extends Block {
    constructor() {
        super();
        this._temps = [];
        this._beginHook = null;
        this._endHook = null;
    }
    setBeginEndHooks(beginHook, endHook) {
        this._beginHook = beginHook;
        this._endHook = endHook;
    }
    declare(reg) {
        this._temps.push(reg);
    }
    codegen(prefix) {
        let buffer = `${prefix}  "use strict";\n`;
        for (const t of this._temps)
            buffer += `${prefix}  let _t_${t};\n`;
        if (this._beginHook) {
            buffer += this._beginHook.codegen(prefix + '  ');
            buffer += '\n';
        }
        if (this._endHook) {
            buffer += `${prefix}  try {\n`;
            buffer += super.codegen(prefix + '    ');
            buffer += '\n';
            buffer += `${prefix}  } finally {\n`;
            buffer += this._endHook.codegen(prefix + '    ');
            buffer += '\n';
            buffer += `${prefix}  }`;
        }
        else {
            buffer += super.codegen(prefix + '  ');
        }
        return buffer;
    }
}
// eslint-disable-next-line prefer-arrow-callback
const AsyncFunction = Object.getPrototypeOf(async function () { }).constructor;
class IRBuilder {
    constructor(baseRegister = 0, extraArgs = []) {
        this._extraArgs = extraArgs;
        this._nArgs = 0;
        this._baseRegister = baseRegister;
        this._nextRegister = baseRegister;
        this._skipRegisterRanges = [];
        this._nextLabel = 0;
        this._root = new RootBlock;
        this._blockStack = [this._root];
    }
    setBeginEndHooks(beginHook, endHook) {
        this._root.setBeginEndHooks(beginHook, endHook);
    }
    get registerRange() {
        return [this._baseRegister, this._nextRegister];
    }
    get nextRegister() {
        return this._nextRegister;
    }
    skipRegisterRange(range) {
        this._skipRegisterRanges.push(range);
        this._nextRegister = range[1];
    }
    codegen(prefix = '') {
        let nextSkipPos = 0;
        let nextSkip = nextSkipPos >= this._skipRegisterRanges.length ? null : this._skipRegisterRanges[nextSkipPos];
        for (let reg = this._baseRegister + this._nArgs; reg < this._nextRegister; reg++) {
            if (nextSkip && reg >= nextSkip[0]) {
                reg = nextSkip[1];
                reg--;
                nextSkipPos++;
                nextSkip = nextSkipPos >= this._skipRegisterRanges.length ? null : this._skipRegisterRanges[nextSkipPos];
                continue;
            }
            this._root.declare(reg);
        }
        return this._root.codegen(prefix);
    }
    codegenFunction(prefix = '') {
        const args = ['__env', ...this._extraArgs];
        for (let i = 0; i < this._nArgs; i++)
            args.push('_t_' + (this._baseRegister + i));
        return `async function(${args.join(', ')}) {\n${this.codegen(prefix)}\n${prefix}}`;
    }
    compile(scope, asts) {
        const code = this.codegen();
        const args = ['__builtin', '__scope', '__ast', '__env', ...this._extraArgs];
        for (let i = 0; i < this._nArgs; i++)
            args.push('_t_' + i);
        const f = new AsyncFunction(...args, code);
        return f.bind(null, Builtin, scope, asts);
    }
    get _currentBlock() {
        return this._blockStack[this._blockStack.length - 1];
    }
    allocRegister() {
        const reg = this._nextRegister++;
        return reg;
    }
    allocArgument() {
        (0, assert_1.default)(this._baseRegister + this._nArgs === this._nextRegister);
        const reg = this._nextRegister++;
        this._nArgs++;
        return reg;
    }
    allocLabel() {
        const lbl = this._nextLabel++;
        return lbl;
    }
    pushBlock(block) {
        const now = this._blockStack.length;
        this._blockStack.push(block);
        return now;
    }
    popBlock() {
        this._blockStack.pop();
        if (this._blockStack.length === 0)
            throw new Error('Invalid pop');
    }
    saveStackState() {
        return this._blockStack.length;
    }
    popTo(upto) {
        this._blockStack.length = upto;
    }
    popAll() {
        this._blockStack.length = 0;
        this._blockStack[0] = this._root;
    }
    add(instr) {
        this._currentBlock.add(instr);
    }
}
exports.IRBuilder = IRBuilder;
//# sourceMappingURL=jsir.js.map