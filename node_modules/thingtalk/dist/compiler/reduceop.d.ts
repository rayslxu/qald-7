import * as Ast from '../ast';
import Type from '../type';
import * as JSIr from './jsir';
import Scope from './scope';
import type OpCompiler from './ops-to-jsir';
declare const AggregationInit: {
    min: number;
    max: number;
    argmin: number;
    argmax: number;
    sum: number;
};
export declare type SimpleAggregationType = keyof typeof AggregationInit;
/**
 * An operation the manipulates each produced tuple and a state.
 */
declare abstract class ReduceOp<StateType> {
    abstract init(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): StateType;
    abstract advance(state: StateType, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[], compiler: OpCompiler): void;
    abstract finish(state: StateType, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[], compiler: OpCompiler): [Scope, string[]];
}
export default ReduceOp;
declare namespace ReduceOp {
    abstract class AggregationOp<StateType> extends ReduceOp<StateType> {
        abstract operator: string;
        abstract field: string;
        abstract type: Type;
        protected abstract compute(state: StateType, irBuilder: JSIr.IRBuilder): JSIr.Register;
        finish(state: StateType, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[]): [Scope, string[]];
    }
    export class Count extends AggregationOp<JSIr.Register> {
        operator: 'count';
        field: 'count';
        type: Type;
        constructor();
        init(irBuilder: JSIr.IRBuilder): number;
        advance(count: JSIr.Register, irBuilder: JSIr.IRBuilder, currentScope: Scope): void;
        protected compute(count: JSIr.Register, irBuilder: JSIr.IRBuilder): JSIr.Register;
    }
    export class CountDistinct extends AggregationOp<JSIr.Register> {
        operator: 'count';
        field: string;
        type: Type;
        constructor(field: string);
        init(irBuilder: JSIr.IRBuilder): number;
        advance(set: JSIr.Register, irBuilder: JSIr.IRBuilder, currentScope: Scope): void;
        protected compute(set: JSIr.Register, irBuilder: JSIr.IRBuilder): number;
    }
    export class Average extends AggregationOp<{
        count: JSIr.Register;
        sum: JSIr.Register;
    }> {
        operator: 'avg';
        field: string;
        type: Type;
        constructor(field: string, type: Type);
        init(irBuilder: JSIr.IRBuilder): {
            count: number;
            sum: number;
        };
        advance({ count, sum }: {
            count: JSIr.Register;
            sum: JSIr.Register;
        }, irBuilder: JSIr.IRBuilder, currentScope: Scope): void;
        protected compute({ count, sum }: {
            count: JSIr.Register;
            sum: JSIr.Register;
        }, irBuilder: JSIr.IRBuilder): number;
    }
    export class SimpleAggregation extends AggregationOp<JSIr.Register> {
        operator: SimpleAggregationType;
        field: string;
        type: Type;
        constructor(operator: SimpleAggregationType, field: string, type: Type);
        init(irBuilder: JSIr.IRBuilder): JSIr.Register;
        advance(value: JSIr.Register, irBuilder: JSIr.IRBuilder, currentScope: Scope): void;
        protected compute(value: JSIr.Register, irBuilder: JSIr.IRBuilder): number;
    }
    interface SimpleArgMinMaxState {
        anyResult: JSIr.Register;
        value: JSIr.Register;
        tuple: JSIr.Register;
        outputType: JSIr.Register;
    }
    export class SimpleArgMinMax extends ReduceOp<SimpleArgMinMaxState> {
        field: string;
        operator: 'argmin' | 'argmax';
        constructor(operator: 'argmin' | 'argmax', field: string);
        init(irBuilder: JSIr.IRBuilder): SimpleArgMinMaxState;
        advance({ anyResult, value: previousValue, tuple, outputType }: SimpleArgMinMaxState, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[]): void;
        finish({ anyResult, value, tuple, outputType }: SimpleArgMinMaxState, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[]): [Scope, string[]];
    }
    export class ComplexArgMinMax extends ReduceOp<JSIr.Register> {
        field: Ast.Value;
        operator: 'argmin' | 'argmax';
        base: Ast.Value;
        limit: Ast.Value;
        constructor(operator: 'argmin' | 'argmax', field: Ast.Value, base: Ast.Value, limit: Ast.Value);
        init(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): JSIr.Register;
        advance(state: JSIr.Register, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[], compiler: OpCompiler): void;
        finish(state: JSIr.Register, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[]): [Scope, string[]];
    }
    interface SimpleIndexState {
        anyResult: JSIr.Register;
        index: JSIr.Register;
        counter: JSIr.Register;
    }
    export class SimpleIndex extends ReduceOp<SimpleIndexState> {
        index: Ast.Value;
        constructor(index: Ast.Value);
        init(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): SimpleIndexState;
        advance({ anyResult, index, counter }: SimpleIndexState, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[]): void;
        finish({ anyResult, index, counter }: SimpleIndexState, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[]): [Scope, string[]];
    }
    interface ArrayReduceState {
        array: JSIr.Register;
    }
    abstract class ArrayReduceOp<StateType extends ArrayReduceState> extends ReduceOp<StateType> {
        protected _doInit(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): JSIr.Register;
        advance({ array }: StateType, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[], compiler: OpCompiler): void;
        abstract _doFinish(irBuilder: JSIr.IRBuilder, state: StateType): JSIr.Register;
        finish(state: StateType, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[]): [Scope, string[]];
    }
    export class SimpleSort extends ArrayReduceOp<ArrayReduceState> {
        field: string;
        direction: 'asc' | 'desc';
        constructor(field: string, direction: 'asc' | 'desc');
        init(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): {
            array: number;
        };
        _doFinish(irBuilder: JSIr.IRBuilder, { array }: ArrayReduceState): JSIr.Register;
    }
    export class ComplexSort extends ArrayReduceOp<ArrayReduceState> {
        field: Ast.Value;
        direction: 'asc' | 'desc';
        constructor(field: Ast.Value, direction: 'asc' | 'desc');
        init(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): {
            array: number;
        };
        advance({ array }: ArrayReduceState, irBuilder: JSIr.IRBuilder, currentScope: Scope, varScopeNames: string[], compiler: OpCompiler): void;
        _doFinish(irBuilder: JSIr.IRBuilder, { array }: ArrayReduceState): JSIr.Register;
    }
    interface ComplexIndexState {
        array: JSIr.Register;
        indices: JSIr.Register;
    }
    export class ComplexIndex extends ArrayReduceOp<ComplexIndexState> {
        indices: Ast.Value[];
        constructor(indices: Ast.Value[]);
        init(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): ComplexIndexState;
        _doFinish(irBuilder: JSIr.IRBuilder, { indices, array }: ComplexIndexState): JSIr.Register;
    }
    interface SliceState {
        array: JSIr.Register;
        base: JSIr.Register;
        limit: JSIr.Register;
    }
    export class Slice extends ArrayReduceOp<SliceState> {
        base: Ast.Value;
        limit: Ast.Value;
        constructor(base: Ast.Value, limit: Ast.Value);
        init(irBuilder: JSIr.IRBuilder, currentScope: Scope, compiler: OpCompiler): SliceState;
        _doFinish(irBuilder: JSIr.IRBuilder, { base, limit, array }: SliceState): JSIr.Register;
    }
    export {};
}
