"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const Ast = __importStar(require("../ast"));
const type_1 = __importDefault(require("../type"));
const JSIr = __importStar(require("./jsir"));
const utils_1 = require("./utils");
const scope_1 = __importDefault(require("./scope"));
const AggregationInit = {
    'min': Infinity,
    'max': -Infinity,
    'argmin': Infinity,
    'argmax': -Infinity,
    'sum': 0
};
function setScopeFromResult(currentScope, newScope, tuple, irBuilder, prefix = '') {
    for (const name of currentScope.ownKeys()) {
        if (name.startsWith('$'))
            continue;
        if (!name.startsWith(prefix))
            continue;
        const unprefixedname = name.substring(prefix.length);
        if (unprefixedname.indexOf('.') >= 0)
            continue;
        const value = irBuilder.allocRegister();
        irBuilder.add(new JSIr.GetKey(tuple, unprefixedname, value));
        const currentScopeObj = currentScope.get(name);
        (0, assert_1.default)(currentScopeObj.type === 'scalar');
        newScope.set(name, {
            type: 'scalar',
            tt_type: currentScopeObj.tt_type,
            register: value,
            direction: currentScopeObj.direction,
            isInVarScopeNames: currentScopeObj.isInVarScopeNames
        });
        if (currentScopeObj.tt_type instanceof type_1.default.Compound) {
            const ifStmt = new JSIr.IfStatement(value);
            irBuilder.add(ifStmt);
            irBuilder.pushBlock(ifStmt.iftrue);
            setScopeFromResult(currentScope, newScope, value, irBuilder, prefix + unprefixedname + '.');
            irBuilder.popBlock();
        }
    }
}
/**
 * An operation the manipulates each produced tuple and a state.
 */
class ReduceOp {
}
exports.default = ReduceOp;
(function (ReduceOp) {
    class AggregationOp extends ReduceOp {
        finish(state, irBuilder, currentScope, varScopeNames) {
            const newOutputType = irBuilder.allocRegister();
            const keyword = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.String(this.operator), keyword));
            irBuilder.add(new JSIr.FunctionOp('aggregateOutputType', false, newOutputType, keyword, (0, utils_1.getRegister)('$outputType', currentScope)));
            const newTuple = irBuilder.allocRegister();
            irBuilder.add(new JSIr.CreateObject(newTuple));
            const value = this.compute(state, irBuilder);
            irBuilder.add(new JSIr.SetKey(newTuple, this.field, value));
            const newScope = new scope_1.default(currentScope.parent);
            newScope.set(this.field, {
                type: 'scalar',
                tt_type: this.type,
                direction: 'output',
                register: value,
                isInVarScopeNames: true,
            });
            newScope.set('$outputType', {
                type: 'scalar',
                tt_type: null,
                direction: 'special',
                register: newOutputType,
                isInVarScopeNames: false,
            });
            newScope.set('$output', {
                type: 'scalar',
                tt_type: null,
                direction: 'special',
                register: newTuple,
                isInVarScopeNames: false,
            });
            return [newScope, [this.field]];
        }
    }
    class Count extends AggregationOp {
        constructor() {
            super();
            this.operator = 'count';
            this.field = 'count';
            this.type = type_1.default.Number;
        }
        init(irBuilder) {
            const zero = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(0), zero));
            return zero;
        }
        advance(count, irBuilder, currentScope) {
            const one = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(1), one));
            irBuilder.add(new JSIr.BinaryOp(count, one, '+', count));
        }
        compute(count, irBuilder) {
            return count;
        }
    }
    ReduceOp.Count = Count;
    class CountDistinct extends AggregationOp {
        constructor(field) {
            super();
            this.field = field;
            this.operator = 'count';
            this.type = type_1.default.Number;
        }
        init(irBuilder) {
            const set = irBuilder.allocRegister();
            irBuilder.add(new JSIr.NewObject('EqualitySet', set));
            return set;
        }
        advance(set, irBuilder, currentScope) {
            irBuilder.add(new JSIr.MethodOp(set, 'add', (0, utils_1.getRegister)('$output', currentScope)));
        }
        compute(set, irBuilder) {
            const count = irBuilder.allocRegister();
            irBuilder.add(new JSIr.GetKey(set, 'size', count));
            return count;
        }
    }
    ReduceOp.CountDistinct = CountDistinct;
    class Average extends AggregationOp {
        constructor(field, type) {
            super();
            this.field = field;
            this.operator = 'avg';
            this.type = type;
        }
        init(irBuilder) {
            const count = irBuilder.allocRegister();
            const sum = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(0), sum));
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(0), count));
            return { count, sum };
        }
        advance({ count, sum }, irBuilder, currentScope) {
            const field = (0, utils_1.getRegister)(this.field, currentScope);
            const one = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(1), one));
            irBuilder.add(new JSIr.BinaryOp(count, one, '+', count));
            irBuilder.add(new JSIr.BinaryOp(sum, field, '+', sum));
        }
        compute({ count, sum }, irBuilder) {
            const value = irBuilder.allocRegister();
            irBuilder.add(new JSIr.BinaryOp(sum, count, '/', value));
            return value;
        }
    }
    ReduceOp.Average = Average;
    class SimpleAggregation extends AggregationOp {
        constructor(operator, field, type) {
            super();
            this.field = field;
            this.operator = operator;
            this.type = type;
        }
        init(irBuilder) {
            const zero = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(AggregationInit[this.operator]), zero));
            return zero;
        }
        advance(value, irBuilder, currentScope) {
            const field = (0, utils_1.getRegister)(this.field, currentScope);
            irBuilder.add(new JSIr.FunctionOp(this.operator, false, value, value, field));
        }
        compute(value, irBuilder) {
            return value;
        }
    }
    ReduceOp.SimpleAggregation = SimpleAggregation;
    class SimpleArgMinMax extends ReduceOp {
        constructor(operator, field) {
            super();
            this.field = field;
            this.operator = operator;
        }
        init(irBuilder) {
            const anyResult = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Boolean(false), anyResult));
            const value = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(AggregationInit[this.operator]), value));
            const tuple = irBuilder.allocRegister();
            const outputType = irBuilder.allocRegister();
            return { anyResult, value, tuple, outputType };
        }
        advance({ anyResult, value: previousValue, tuple, outputType }, irBuilder, currentScope, varScopeNames) {
            const newValue = (0, utils_1.getRegister)(this.field, currentScope);
            const comp = this.operator === 'argmax' ? '<' : '>';
            const isBetter = irBuilder.allocRegister();
            irBuilder.add(new JSIr.BinaryOp(previousValue, newValue, comp, isBetter));
            const ifStmt = new JSIr.IfStatement(isBetter);
            irBuilder.add(ifStmt);
            irBuilder.pushBlock(ifStmt.iftrue);
            irBuilder.add(new JSIr.Copy(newValue, previousValue));
            irBuilder.add(new JSIr.Copy((0, utils_1.getRegister)('$output', currentScope), tuple));
            irBuilder.add(new JSIr.Copy((0, utils_1.getRegister)('$outputType', currentScope), outputType));
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Boolean(true), anyResult));
            irBuilder.popBlock();
        }
        finish({ anyResult, value, tuple, outputType }, irBuilder, currentScope, varScopeNames) {
            const newScope = new scope_1.default(currentScope.parent);
            newScope.set('$outputType', {
                type: 'scalar',
                tt_type: null,
                register: outputType,
                direction: 'special',
                isInVarScopeNames: false
            });
            newScope.set('$output', {
                type: 'scalar',
                tt_type: null,
                register: tuple,
                direction: 'special',
                isInVarScopeNames: false
            });
            const ifStmt = new JSIr.IfStatement(anyResult);
            irBuilder.add(ifStmt);
            irBuilder.pushBlock(ifStmt.iftrue);
            setScopeFromResult(currentScope, newScope, tuple, irBuilder);
            return [newScope, varScopeNames];
        }
    }
    ReduceOp.SimpleArgMinMax = SimpleArgMinMax;
    class ComplexArgMinMax extends ReduceOp {
        constructor(operator, field, base, limit) {
            super();
            this.field = field;
            this.operator = operator;
            this.base = base;
            this.limit = limit;
        }
        init(irBuilder, currentScope, compiler) {
            const base = compiler.compileValue(this.base, currentScope);
            const limit = compiler.compileValue(this.limit, currentScope);
            const operator = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadBuiltin(this.operator, operator));
            const state = irBuilder.allocRegister();
            irBuilder.add(new JSIr.NewObject(`ArgMinMaxState`, state, operator, base, limit));
            return state;
        }
        advance(state, irBuilder, currentScope, varScopeNames, compiler) {
            const field = compiler.compileValue(this.field, currentScope);
            irBuilder.add(new JSIr.MethodOp(state, 'update', (0, utils_1.getRegister)('$output', currentScope), (0, utils_1.getRegister)('$outputType', currentScope), field));
        }
        finish(state, irBuilder, currentScope, varScopeNames) {
            const iterator = irBuilder.allocRegister();
            const loop = new JSIr.ForOfStatement(iterator, state);
            irBuilder.add(loop);
            irBuilder.pushBlock(loop.body);
            const outputType = irBuilder.allocRegister();
            const result = irBuilder.allocRegister();
            irBuilder.add(new JSIr.GetIndex(iterator, 0, outputType));
            irBuilder.add(new JSIr.GetIndex(iterator, 1, result));
            const newScope = new scope_1.default(currentScope.parent);
            newScope.set('$outputType', {
                type: 'scalar',
                tt_type: null,
                register: outputType,
                direction: 'special',
                isInVarScopeNames: false
            });
            newScope.set('$output', {
                type: 'scalar',
                tt_type: null,
                register: result,
                direction: 'special',
                isInVarScopeNames: false
            });
            setScopeFromResult(currentScope, newScope, result, irBuilder);
            return [newScope, varScopeNames];
        }
    }
    ReduceOp.ComplexArgMinMax = ComplexArgMinMax;
    class SimpleIndex extends ReduceOp {
        constructor(index) {
            super();
            this.index = index;
        }
        init(irBuilder, currentScope, compiler) {
            const index = compiler.compileValue(this.index, currentScope);
            const anyResult = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Boolean(false), anyResult));
            const counter = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(0), counter));
            return { anyResult, index, counter };
        }
        advance({ anyResult, index, counter }, irBuilder, currentScope, varScopeNames) {
            const one = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Number(1), one));
            irBuilder.add(new JSIr.BinaryOp(counter, one, '+', counter));
            const isTarget = irBuilder.allocRegister();
            irBuilder.add(new JSIr.BinaryOp(index, counter, '==', isTarget));
            const ifStmt = new JSIr.IfStatement(isTarget);
            irBuilder.add(ifStmt);
            irBuilder.pushBlock(ifStmt.iftrue);
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.Boolean(true), anyResult));
            irBuilder.add(new JSIr.Break());
            irBuilder.popBlock();
        }
        finish({ anyResult, index, counter }, irBuilder, currentScope, varScopeNames) {
            const ifStmt = new JSIr.IfStatement(anyResult);
            irBuilder.add(ifStmt);
            irBuilder.pushBlock(ifStmt.iftrue);
            return [currentScope, varScopeNames];
        }
    }
    ReduceOp.SimpleIndex = SimpleIndex;
    class ArrayReduceOp extends ReduceOp {
        _doInit(irBuilder, currentScope, compiler) {
            const array = irBuilder.allocRegister();
            irBuilder.add(new JSIr.CreateTuple(0, array));
            return array;
        }
        advance({ array }, irBuilder, currentScope, varScopeNames, compiler) {
            const resultAndTypeTuple = irBuilder.allocRegister();
            irBuilder.add(new JSIr.CreateTuple(2, resultAndTypeTuple));
            irBuilder.add(new JSIr.SetIndex(resultAndTypeTuple, 0, (0, utils_1.getRegister)('$output', currentScope)));
            irBuilder.add(new JSIr.SetIndex(resultAndTypeTuple, 1, (0, utils_1.getRegister)('$outputType', currentScope)));
            irBuilder.add(new JSIr.MethodOp(array, 'push', resultAndTypeTuple));
        }
        finish(state, irBuilder, currentScope, varScopeNames) {
            const array = this._doFinish(irBuilder, state);
            const iterator = irBuilder.allocRegister();
            const loop = new JSIr.ForOfStatement(iterator, array);
            irBuilder.add(loop);
            irBuilder.pushBlock(loop.body);
            const outputType = irBuilder.allocRegister();
            const result = irBuilder.allocRegister();
            irBuilder.add(new JSIr.GetIndex(iterator, 0, result));
            irBuilder.add(new JSIr.GetIndex(iterator, 1, outputType));
            const newScope = new scope_1.default(currentScope.parent);
            newScope.set('$outputType', {
                type: 'scalar',
                tt_type: null,
                register: outputType,
                direction: 'special',
                isInVarScopeNames: false
            });
            newScope.set('$output', {
                type: 'scalar',
                tt_type: null,
                register: result,
                direction: 'special',
                isInVarScopeNames: false
            });
            setScopeFromResult(currentScope, newScope, result, irBuilder);
            return [newScope, varScopeNames];
        }
    }
    class SimpleSort extends ArrayReduceOp {
        constructor(field, direction) {
            super();
            this.field = field;
            this.direction = direction;
        }
        init(irBuilder, currentScope, compiler) {
            return { array: this._doInit(irBuilder, currentScope, compiler) };
        }
        _doFinish(irBuilder, { array }) {
            const field = irBuilder.allocRegister();
            irBuilder.add(new JSIr.LoadConstant(new Ast.Value.String(this.field), field));
            irBuilder.add(new JSIr.VoidFunctionOp('sort' + this.direction, array, field));
            return array;
        }
    }
    ReduceOp.SimpleSort = SimpleSort;
    class ComplexSort extends ArrayReduceOp {
        constructor(field, direction) {
            super();
            this.field = field;
            this.direction = direction;
        }
        init(irBuilder, currentScope, compiler) {
            return { array: this._doInit(irBuilder, currentScope, compiler) };
        }
        advance({ array }, irBuilder, currentScope, varScopeNames, compiler) {
            const sortKey = compiler.compileValue(this.field, currentScope);
            const resultAndTypeTuple = irBuilder.allocRegister();
            irBuilder.add(new JSIr.CreateTuple(3, resultAndTypeTuple));
            irBuilder.add(new JSIr.SetIndex(resultAndTypeTuple, 0, (0, utils_1.getRegister)('$output', currentScope)));
            irBuilder.add(new JSIr.SetIndex(resultAndTypeTuple, 1, (0, utils_1.getRegister)('$outputType', currentScope)));
            irBuilder.add(new JSIr.SetIndex(resultAndTypeTuple, 2, sortKey));
            irBuilder.add(new JSIr.MethodOp(array, 'push', resultAndTypeTuple));
        }
        _doFinish(irBuilder, { array }) {
            irBuilder.add(new JSIr.VoidFunctionOp('sortkey' + this.direction, array));
            return array;
        }
    }
    ReduceOp.ComplexSort = ComplexSort;
    class ComplexIndex extends ArrayReduceOp {
        constructor(indices) {
            super();
            this.indices = indices;
        }
        init(irBuilder, currentScope, compiler) {
            const indicesType = this.indices.length === 1 ?
                (0, utils_1.typeForValue)(this.indices[0], currentScope) : type_1.default.Number;
            let indices;
            if (indicesType.isNumber)
                indices = compiler.compileValue(new Ast.Value.Array(this.indices), currentScope);
            else
                indices = compiler.compileValue(this.indices[0], currentScope);
            const state = {
                array: this._doInit(irBuilder, currentScope, compiler),
                indices: indices
            };
            return state;
        }
        _doFinish(irBuilder, { indices, array }) {
            const newArray = irBuilder.allocRegister();
            irBuilder.add(new JSIr.FunctionOp('indexArray', false, newArray, array, indices));
            return newArray;
        }
    }
    ReduceOp.ComplexIndex = ComplexIndex;
    class Slice extends ArrayReduceOp {
        constructor(base, limit) {
            super();
            this.base = base;
            this.limit = limit;
        }
        init(irBuilder, currentScope, compiler) {
            const base = compiler.compileValue(this.base, currentScope);
            const limit = compiler.compileValue(this.limit, currentScope);
            const state = {
                array: this._doInit(irBuilder, currentScope, compiler),
                base: base,
                limit: limit
            };
            return state;
        }
        _doFinish(irBuilder, { base, limit, array }) {
            const newArray = irBuilder.allocRegister();
            irBuilder.add(new JSIr.FunctionOp('sliceArray', false, newArray, array, base, limit));
            return newArray;
        }
    }
    ReduceOp.Slice = Slice;
})(ReduceOp || (ReduceOp = {}));
//# sourceMappingURL=reduceop.js.map