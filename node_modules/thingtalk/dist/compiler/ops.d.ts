import * as Ast from '../ast';
import Type from "../type";
import ReduceOp from './reduceop';
export declare class PointWiseOp {
}
export declare namespace PointWiseOp {
    class Projection extends PointWiseOp {
        args: Set<string>;
        constructor(args: Set<string>);
        toString(): string;
    }
    class Compute extends PointWiseOp {
        expression: Ast.Value;
        alias: string;
        constructor(expression: Ast.Value, alias: string);
        toString(): string;
    }
    class BooleanCompute extends PointWiseOp {
        booleanExpression: Ast.BooleanExpression;
        constructor(booleanExpression: Ast.BooleanExpression);
        toString(): string;
    }
}
declare type SortHint = [string, 'asc' | 'desc'];
export declare class QueryInvocationHints {
    projection: Set<string>;
    filter: Ast.BooleanExpression;
    sort: SortHint | undefined;
    limit: number | undefined;
    constructor(projection: Set<string>, filter?: Ast.BooleanExpression, sort?: SortHint, limit?: number);
    clone(): QueryInvocationHints;
}
/**
 * A low-level operation on streams
 */
export declare abstract class StreamOp {
    abstract ast: Ast.Expression | null;
}
export declare namespace StreamOp {
    class Now extends StreamOp {
        table: TableOp;
        ast: Ast.Expression;
        constructor(table: TableOp, ast: Ast.Expression);
        toString(): string;
    }
    class InvokeVarRef extends StreamOp {
        name: string;
        in_params: Ast.InputParam[];
        ast: Ast.Expression;
        hints: QueryInvocationHints;
        constructor(name: string, in_params: Ast.InputParam[], ast: Ast.Expression, hints: QueryInvocationHints);
        toString(): string;
    }
    class InvokeSubscribe extends StreamOp {
        invocation: Ast.Invocation;
        ast: Ast.Expression;
        hints: QueryInvocationHints;
        constructor(invocation: Ast.Invocation, ast: Ast.Expression, hints: QueryInvocationHints);
        toString(): string;
    }
    class Timer extends StreamOp {
        base: Ast.Value | undefined;
        interval: Ast.Value;
        frequency: Ast.Value | undefined;
        ast: Ast.Expression;
        constructor(base: Ast.Value | undefined, interval: Ast.Value, frequency: Ast.Value | undefined, ast: Ast.Expression);
        toString(): string;
    }
    class AtTimer extends StreamOp {
        time: Ast.Value;
        expiration_date: Ast.Value | undefined;
        ast: Ast.Expression;
        constructor(time: Ast.Value, expiration_date: Ast.Value | undefined, ast: Ast.Expression);
        toString(): string;
    }
    class OnTimer extends StreamOp {
        date: Ast.Value;
        ast: Ast.Expression;
        constructor(date: Ast.Value, ast: Ast.Expression);
        toString(): string;
    }
    class Filter extends StreamOp {
        stream: StreamOp;
        filter: BooleanExpressionOp;
        ast: Ast.Expression;
        constructor(stream: StreamOp, filter: BooleanExpressionOp, ast: Ast.Expression);
        toString(): string;
    }
    class Map extends StreamOp {
        stream: StreamOp;
        op: PointWiseOp;
        ast: Ast.Expression;
        constructor(stream: StreamOp, op: PointWiseOp, ast: Ast.Expression);
        toString(): string;
    }
    class EdgeNew extends StreamOp {
        stream: StreamOp;
        ast: Ast.Expression;
        constructor(stream: StreamOp, ast: Ast.Expression);
        toString(): string;
    }
    class EdgeFilter extends StreamOp {
        stream: StreamOp;
        filter: BooleanExpressionOp;
        ast: Ast.Expression;
        constructor(stream: StreamOp, filter: BooleanExpressionOp, ast: Ast.Expression);
        toString(): string;
    }
    class Union extends StreamOp {
        lhs: StreamOp;
        rhs: StreamOp;
        ast: Ast.Expression;
        constructor(lhs: StreamOp, rhs: StreamOp, ast: Ast.Expression);
        toString(): string;
    }
    /**
      When the stream fires, get the whole table (ignore the stream).
      This is used to implement certain "monitor(table)" where the
      table needs to be recomputed on subscribe.
     */
    class InvokeTable extends StreamOp {
        stream: StreamOp;
        table: TableOp;
        ast: Ast.Expression;
        constructor(stream: StreamOp, table: TableOp, ast: Ast.Expression);
        toString(): string;
    }
    /**
     * When the stream fires, get the whole table and join it.
     */
    class Join extends StreamOp {
        stream: StreamOp;
        table: TableOp;
        ast: Ast.Expression;
        constructor(stream: StreamOp, table: TableOp, ast: Ast.Expression);
        toString(): string;
    }
}
declare type UnaryStreamOp = StreamOp.Filter | StreamOp.Map | StreamOp.EdgeFilter | StreamOp.EdgeNew;
export declare function isUnaryStreamOp(op: StreamOp): op is UnaryStreamOp;
/**
 * A low-level operation on an in-memory table.
 */
export declare abstract class TableOp {
    handle_thingtalk: boolean;
    abstract device: Ast.DeviceSelector | null;
    abstract ast: Ast.Expression;
}
export declare namespace TableOp {
    class InvokeVarRef extends TableOp {
        name: string;
        in_params: Ast.InputParam[];
        ast: Ast.Expression;
        hints: QueryInvocationHints;
        device: null;
        constructor(name: string, in_params: Ast.InputParam[], ast: Ast.Expression, hints: QueryInvocationHints);
        toString(): string;
    }
    class InvokeGet extends TableOp {
        invocation: Ast.Invocation;
        device: Ast.DeviceSelector | null;
        handle_thingtalk: boolean;
        ast: Ast.Expression;
        hints: QueryInvocationHints;
        constructor(invocation: Ast.Invocation, device: Ast.DeviceSelector | null, handle_thingtalk: boolean, ast: Ast.Expression, hints: QueryInvocationHints);
        toString(): string;
    }
    class Filter extends TableOp {
        table: TableOp;
        filter: BooleanExpressionOp;
        device: Ast.DeviceSelector | null;
        handle_thingtalk: boolean;
        ast: Ast.Expression;
        constructor(table: TableOp, filter: BooleanExpressionOp, device: Ast.DeviceSelector | null, handle_thingtalk: boolean, ast: Ast.Expression);
        toString(): string;
    }
    class Map extends TableOp {
        table: TableOp;
        op: PointWiseOp;
        device: Ast.DeviceSelector | null;
        handle_thingtalk: boolean;
        ast: Ast.Expression;
        constructor(table: TableOp, op: PointWiseOp, device: Ast.DeviceSelector | null, handle_thingtalk: boolean, ast: Ast.Expression);
        toString(): string;
    }
    class Reduce extends TableOp {
        table: TableOp;
        op: ReduceOp<unknown>;
        device: Ast.DeviceSelector | null;
        handle_thingtalk: boolean;
        ast: Ast.Expression;
        constructor(table: TableOp, op: ReduceOp<unknown>, device: Ast.DeviceSelector | null, handle_thingtalk: boolean, ast: Ast.Expression);
        toString(): string;
    }
    class Join extends TableOp {
        lhs: TableOp;
        rhs: TableOp;
        device: Ast.DeviceSelector | null;
        handle_thingtalk: boolean;
        ast: Ast.Expression;
        constructor(lhs: TableOp, rhs: TableOp, device: Ast.DeviceSelector | null, handle_thingtalk: boolean, ast: Ast.Expression);
        toString(): string;
    }
    class CrossJoin extends TableOp {
        lhs: TableOp;
        rhs: TableOp;
        device: Ast.DeviceSelector | null;
        handle_thingtalk: boolean;
        ast: Ast.Expression;
        constructor(lhs: TableOp, rhs: TableOp, device: Ast.DeviceSelector | null, handle_thingtalk: boolean, ast: Ast.Expression);
        toString(): string;
    }
    class NestedLoopJoin extends TableOp {
        lhs: TableOp;
        rhs: TableOp;
        device: Ast.DeviceSelector | null;
        handle_thingtalk: boolean;
        ast: Ast.Expression;
        constructor(lhs: TableOp, rhs: TableOp, device: Ast.DeviceSelector | null, handle_thingtalk: boolean, ast: Ast.Expression);
        toString(): string;
    }
}
declare type UnaryTableOp = TableOp.Filter | TableOp.Map | TableOp.Reduce;
export declare function isUnaryTableOp(op: TableOp): op is UnaryTableOp;
export declare abstract class ActionOp {
}
export declare namespace ActionOp {
    class InvokeDo extends ActionOp {
        invocation: Ast.Invocation;
        ast: Ast.Expression;
        constructor(invocation: Ast.Invocation, ast: Ast.Expression);
        toString(): string;
    }
    class InvokeVarRef extends ActionOp {
        name: string;
        in_params: Ast.InputParam[];
        ast: Ast.Expression;
        constructor(name: string, in_params: Ast.InputParam[], ast: Ast.Expression);
        toString(): string;
    }
}
/**
 * The overall structure of the rule.
 * This reflects the overall "when => get* => do" structure of ThingTalk
 * which is what it optimizes for.
 */
export declare class RuleOp {
    stream: StreamOp | null;
    action: ActionOp | null;
    ast: Ast.ExpressionStatement | Ast.ReturnStatement;
    constructor(stream: StreamOp | null, action: ActionOp | null, ast: Ast.ExpressionStatement | Ast.ReturnStatement);
    toString(): string;
}
export declare abstract class BooleanExpressionOp {
    static True: ConstantBooleanExpressionOp;
    static False: ConstantBooleanExpressionOp;
    ast: Ast.BooleanExpression;
    protected constructor(ast: Ast.BooleanExpression);
}
declare class ConstantBooleanExpressionOp extends BooleanExpressionOp {
    readonly value: boolean;
    constructor(value: boolean);
    toString(): string;
}
export declare namespace BooleanExpressionOp {
    class And extends BooleanExpressionOp {
        operands: BooleanExpressionOp[];
        constructor(ast: Ast.AndBooleanExpression, operands: BooleanExpressionOp[]);
        toString(): string;
    }
    class Or extends BooleanExpressionOp {
        operands: BooleanExpressionOp[];
        constructor(ast: Ast.OrBooleanExpression, operands: BooleanExpressionOp[]);
        toString(): string;
    }
    class Not extends BooleanExpressionOp {
        expr: BooleanExpressionOp;
        constructor(ast: Ast.NotBooleanExpression, expr: BooleanExpressionOp);
        toString(): string;
    }
    class Atom extends BooleanExpressionOp {
        lhs: Ast.Value;
        operator: string;
        rhs: Ast.Value;
        overload: Type[] | null;
        constructor(ast: Ast.AtomBooleanExpression | Ast.ComputeBooleanExpression, lhs: Ast.Value, operator: string, rhs: Ast.Value, overload: Type[] | null);
        toString(): string;
    }
    class ExistentialSubquery extends BooleanExpressionOp {
        subquery: TableOp;
        constructor(ast: Ast.ExistentialSubqueryBooleanExpression, subquery: TableOp);
        toString(): string;
    }
    class ComparisonSubquery extends BooleanExpressionOp {
        lhs: Ast.Value;
        operator: string;
        rhs: Ast.Value;
        subquery: TableOp;
        overload: Type[] | null;
        constructor(ast: Ast.ComparisonSubqueryBooleanExpression, lhs: Ast.Value, operator: string, rhs: Ast.Value, subquery: TableOp, overload: Type[] | null);
        toString(): string;
    }
}
export {};
