"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BooleanExpressionOp = exports.RuleOp = exports.ActionOp = exports.isUnaryTableOp = exports.TableOp = exports.isUnaryStreamOp = exports.StreamOp = exports.QueryInvocationHints = exports.PointWiseOp = void 0;
const assert_1 = __importDefault(require("assert"));
const Ast = __importStar(require("../ast"));
// Low-level ThingTalk operations
// Each ThingTalk AST node can be implemented in terms of these low-level ops
// Each of these ops can be compiled into JS code individually
// PointWiseOp : operates on each produced tuple
class PointWiseOp {
}
exports.PointWiseOp = PointWiseOp;
(function (PointWiseOp) {
    class Projection extends PointWiseOp {
        constructor(args) {
            super();
            this.args = args;
        }
        toString() {
            return `PointWiseOp.Projection(${this.args})`;
        }
    }
    PointWiseOp.Projection = Projection;
    class Compute extends PointWiseOp {
        constructor(expression, alias) {
            super();
            this.expression = expression;
            this.alias = alias;
        }
        toString() {
            return `PointWiseOp.Compute(${this.expression} as ${this.alias})`;
        }
    }
    PointWiseOp.Compute = Compute;
    class BooleanCompute extends PointWiseOp {
        constructor(booleanExpression) {
            super();
            this.booleanExpression = booleanExpression;
        }
        toString() {
            return `PointWiseOp.BooleanCompute(${this.booleanExpression})`;
        }
    }
    PointWiseOp.BooleanCompute = BooleanCompute;
})(PointWiseOp = exports.PointWiseOp || (exports.PointWiseOp = {}));
class QueryInvocationHints {
    constructor(projection, filter = Ast.BooleanExpression.True, sort, limit) {
        (0, assert_1.default)(filter instanceof Ast.BooleanExpression);
        (0, assert_1.default)(sort === undefined || Array.isArray(sort));
        (0, assert_1.default)(projection instanceof Set);
        (0, assert_1.default)(limit === undefined || typeof limit === 'number');
        this.filter = filter;
        this.sort = sort;
        this.projection = projection;
        this.limit = limit;
    }
    clone() {
        return new QueryInvocationHints(new Set(this.projection), this.filter, this.sort, this.limit);
    }
}
exports.QueryInvocationHints = QueryInvocationHints;
/**
 * A low-level operation on streams
 */
class StreamOp {
}
exports.StreamOp = StreamOp;
(function (StreamOp) {
    class Now extends StreamOp {
        constructor(table, ast) {
            super();
            this.table = table;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.Now(${this.table})`;
        }
    }
    StreamOp.Now = Now;
    class InvokeVarRef extends StreamOp {
        constructor(name, in_params, ast, hints) {
            super();
            this.name = name;
            this.in_params = in_params;
            this.ast = ast;
            this.hints = hints;
        }
        toString() {
            return `StreamOp.InvokeVarRef(${this.name}, ${this.in_params.map((ip) => ip.prettyprint()).join(', ')})`;
        }
    }
    StreamOp.InvokeVarRef = InvokeVarRef;
    class InvokeSubscribe extends StreamOp {
        constructor(invocation, ast, hints) {
            super();
            this.invocation = invocation;
            this.ast = ast;
            this.hints = hints;
        }
        toString() {
            return `StreamOp.InvokeSubscribe(${this.invocation.prettyprint()})`;
        }
    }
    StreamOp.InvokeSubscribe = InvokeSubscribe;
    class Timer extends StreamOp {
        constructor(base, interval, frequency, ast) {
            super();
            this.base = base;
            this.interval = interval;
            this.frequency = frequency;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.Timer(${this.base}, ${this.interval}, ${this.frequency})`;
        }
    }
    StreamOp.Timer = Timer;
    class AtTimer extends StreamOp {
        constructor(time, expiration_date, ast) {
            super();
            this.time = time;
            this.expiration_date = expiration_date;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.AtTimer(${this.time}, ${this.expiration_date})`;
        }
    }
    StreamOp.AtTimer = AtTimer;
    class OnTimer extends StreamOp {
        constructor(date, ast) {
            super();
            this.date = date;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.OnTimer(${this.date})`;
        }
    }
    StreamOp.OnTimer = OnTimer;
    class Filter extends StreamOp {
        constructor(stream, filter, ast) {
            super();
            this.stream = stream;
            this.filter = filter;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.Filter(${this.stream}, ${this.filter})`;
        }
    }
    StreamOp.Filter = Filter;
    class Map extends StreamOp {
        constructor(stream, op, ast) {
            super();
            this.stream = stream;
            this.op = op;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.Map(${this.stream}, ${this.op})`;
        }
    }
    StreamOp.Map = Map;
    class EdgeNew extends StreamOp {
        constructor(stream, ast) {
            super();
            this.stream = stream;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.EdgeNew(${this.stream})`;
        }
    }
    StreamOp.EdgeNew = EdgeNew;
    class EdgeFilter extends StreamOp {
        constructor(stream, filter, ast) {
            super();
            this.stream = stream;
            this.filter = filter;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.EdgeFilter(${this.stream}, ${this.filter})`;
        }
    }
    StreamOp.EdgeFilter = EdgeFilter;
    class Union extends StreamOp {
        constructor(lhs, rhs, ast) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.Union(${this.lhs}, ${this.rhs})`;
        }
    }
    StreamOp.Union = Union;
    /**
      When the stream fires, get the whole table (ignore the stream).
      This is used to implement certain "monitor(table)" where the
      table needs to be recomputed on subscribe.
     */
    class InvokeTable extends StreamOp {
        constructor(stream, table, ast) {
            super();
            this.stream = stream;
            this.table = table;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.InvokeTable(${this.stream}, ${this.table})`;
        }
    }
    StreamOp.InvokeTable = InvokeTable;
    /**
     * When the stream fires, get the whole table and join it.
     */
    class Join extends StreamOp {
        constructor(stream, table, ast) {
            super();
            this.stream = stream;
            this.table = table;
            this.ast = ast;
        }
        toString() {
            return `StreamOp.Join(${this.stream}, ${this.table})`;
        }
    }
    StreamOp.Join = Join;
})(StreamOp = exports.StreamOp || (exports.StreamOp = {}));
function isUnaryStreamOp(op) {
    return op instanceof StreamOp.Filter ||
        op instanceof StreamOp.Map ||
        op instanceof StreamOp.EdgeFilter ||
        op instanceof StreamOp.EdgeNew;
}
exports.isUnaryStreamOp = isUnaryStreamOp;
/**
 * A low-level operation on an in-memory table.
 */
class TableOp {
    constructor() {
        this.handle_thingtalk = false;
    }
}
exports.TableOp = TableOp;
(function (TableOp) {
    class InvokeVarRef extends TableOp {
        constructor(name, in_params, ast, hints) {
            super();
            this.name = name;
            this.in_params = in_params;
            this.ast = ast;
            this.hints = hints;
            this.device = null;
        }
        toString() {
            return `TableOp.InvokeVarRef(${this.name}, ${this.in_params.map((ip) => ip.prettyprint())})`;
        }
    }
    TableOp.InvokeVarRef = InvokeVarRef;
    class InvokeGet extends TableOp {
        constructor(invocation, device, handle_thingtalk, ast, hints) {
            super();
            this.invocation = invocation;
            this.device = device;
            this.handle_thingtalk = handle_thingtalk;
            this.ast = ast;
            this.hints = hints;
        }
        toString() {
            return `TableOp.InvokeGet(${this.invocation.prettyprint()})`;
        }
    }
    TableOp.InvokeGet = InvokeGet;
    class Filter extends TableOp {
        constructor(table, filter, device, handle_thingtalk, ast) {
            super();
            this.table = table;
            this.filter = filter;
            this.device = device;
            this.handle_thingtalk = handle_thingtalk;
            this.ast = ast;
        }
        toString() {
            return `TableOp.Filter(${this.table}, ${this.filter})`;
        }
    }
    TableOp.Filter = Filter;
    class Map extends TableOp {
        constructor(table, op, device, handle_thingtalk, ast) {
            super();
            this.table = table;
            this.op = op;
            this.device = device;
            this.handle_thingtalk = handle_thingtalk;
            this.ast = ast;
        }
        toString() {
            return `TableOp.Map(${this.table}, ${this.op})`;
        }
    }
    TableOp.Map = Map;
    class Reduce extends TableOp {
        constructor(table, op, device, handle_thingtalk, ast) {
            super();
            this.table = table;
            this.op = op;
            this.device = device;
            this.handle_thingtalk = handle_thingtalk;
            this.ast = ast;
        }
        toString() {
            return `TableOp.Reduce(${this.table}, ${this.op})`;
        }
    }
    TableOp.Reduce = Reduce;
    class Join extends TableOp {
        constructor(lhs, rhs, device, handle_thingtalk, ast) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.device = device;
            this.handle_thingtalk = handle_thingtalk;
            this.ast = ast;
        }
        toString() {
            return `TableOp.Join(${this.lhs}, ${this.rhs})`;
        }
    }
    TableOp.Join = Join;
    class CrossJoin extends TableOp {
        constructor(lhs, rhs, device, handle_thingtalk, ast) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.device = device;
            this.handle_thingtalk = handle_thingtalk;
            this.ast = ast;
        }
        toString() {
            return `TableOp.CrossJoin(${this.lhs}, ${this.rhs})`;
        }
    }
    TableOp.CrossJoin = CrossJoin;
    class NestedLoopJoin extends TableOp {
        constructor(lhs, rhs, device, handle_thingtalk, ast) {
            super();
            this.lhs = lhs;
            this.rhs = rhs;
            this.device = device;
            this.handle_thingtalk = handle_thingtalk;
            this.ast = ast;
        }
        toString() {
            return `TableOp.NestedLoopJoin(${this.lhs}, ${this.rhs})`;
        }
    }
    TableOp.NestedLoopJoin = NestedLoopJoin;
})(TableOp = exports.TableOp || (exports.TableOp = {}));
function isUnaryTableOp(op) {
    return op instanceof TableOp.Filter ||
        op instanceof TableOp.Map ||
        op instanceof TableOp.Reduce;
}
exports.isUnaryTableOp = isUnaryTableOp;
class ActionOp {
}
exports.ActionOp = ActionOp;
(function (ActionOp) {
    class InvokeDo extends ActionOp {
        constructor(invocation, ast) {
            super();
            this.invocation = invocation;
            this.ast = ast;
        }
        toString() {
            return `ActionOp.InvokeDo(${this.invocation.prettyprint()})`;
        }
    }
    ActionOp.InvokeDo = InvokeDo;
    class InvokeVarRef extends ActionOp {
        constructor(name, in_params, ast) {
            super();
            this.name = name;
            this.in_params = in_params;
            this.ast = ast;
        }
        toString() {
            return `ActionOp.InvokeVarRef(${this.name}, ${this.in_params.map((ip) => ip.prettyprint())})`;
        }
    }
    ActionOp.InvokeVarRef = InvokeVarRef;
})(ActionOp = exports.ActionOp || (exports.ActionOp = {}));
/**
 * The overall structure of the rule.
 * This reflects the overall "when => get* => do" structure of ThingTalk
 * which is what it optimizes for.
 */
class RuleOp {
    constructor(stream, action, ast) {
        this.stream = stream;
        this.action = action;
        this.ast = ast;
    }
    toString() {
        return `RuleOp(${this.stream}, ${this.action})`;
    }
}
exports.RuleOp = RuleOp;
class BooleanExpressionOp {
    constructor(ast) {
        this.ast = ast;
    }
}
exports.BooleanExpressionOp = BooleanExpressionOp;
class ConstantBooleanExpressionOp extends BooleanExpressionOp {
    constructor(value) {
        super(value ? Ast.BooleanExpression.True : Ast.BooleanExpression.False);
        this.value = value;
    }
    toString() {
        return `BooleanExpressionOp.Constant(${this.value})`;
    }
}
BooleanExpressionOp.True = new ConstantBooleanExpressionOp(true);
BooleanExpressionOp.False = new ConstantBooleanExpressionOp(false);
(function (BooleanExpressionOp) {
    class And extends BooleanExpressionOp {
        constructor(ast, operands) {
            super(ast);
            this.operands = operands;
        }
        toString() {
            return `BooleanExpressionOp.And(${this.operands.join(', ')})`;
        }
    }
    BooleanExpressionOp.And = And;
    class Or extends BooleanExpressionOp {
        constructor(ast, operands) {
            super(ast);
            this.operands = operands;
        }
        toString() {
            return `BooleanExpressionOp.Or(${this.operands.join(', ')})`;
        }
    }
    BooleanExpressionOp.Or = Or;
    class Not extends BooleanExpressionOp {
        constructor(ast, expr) {
            super(ast);
            this.expr = expr;
        }
        toString() {
            return `BooleanExpressionOp.Not(${this.expr})`;
        }
    }
    BooleanExpressionOp.Not = Not;
    class Atom extends BooleanExpressionOp {
        constructor(ast, lhs, operator, rhs, overload) {
            super(ast);
            this.lhs = lhs;
            this.operator = operator;
            this.rhs = rhs;
            this.overload = overload;
        }
        toString() {
            return `BooleanExpressionOp.Atom(${this.lhs}, ${this.operator}, ${this.rhs})`;
        }
    }
    BooleanExpressionOp.Atom = Atom;
    class ExistentialSubquery extends BooleanExpressionOp {
        constructor(ast, subquery) {
            super(ast);
            this.subquery = subquery;
        }
        toString() {
            return `BooleanExpressionOp.ExistentialSubquery(${this.subquery})`;
        }
    }
    BooleanExpressionOp.ExistentialSubquery = ExistentialSubquery;
    class ComparisonSubquery extends BooleanExpressionOp {
        constructor(ast, lhs, operator, rhs, subquery, overload) {
            super(ast);
            this.lhs = lhs;
            this.operator = operator;
            this.rhs = rhs;
            this.subquery = subquery;
            this.overload = overload;
        }
        toString() {
            return `BooleanExpressionOp.ComparisonSubquery(${this.lhs}, ${this.operator}, ${this.rhs}, ${this.subquery})`;
        }
    }
    BooleanExpressionOp.ComparisonSubquery = ComparisonSubquery;
})(BooleanExpressionOp = exports.BooleanExpressionOp || (exports.BooleanExpressionOp = {}));
//# sourceMappingURL=ops.js.map