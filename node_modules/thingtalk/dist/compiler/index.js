"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const Grammar = __importStar(require("../syntax_api"));
const errors_1 = require("../utils/errors");
const Ast = __importStar(require("../ast"));
const JSIr = __importStar(require("./jsir"));
const ast_to_ops_1 = require("./ast-to-ops");
const ops_1 = require("./ops");
const utils_1 = require("./utils");
const ops_to_jsir_1 = __importDefault(require("./ops-to-jsir"));
const scope_1 = __importDefault(require("./scope"));
const exec_environment_1 = require("../runtime/exec_environment");
class AppCompiler {
    constructor(schemaRetriever, timezone, testMode = false) {
        this._testMode = testMode;
        this._declarations = new scope_1.default;
        this._toplevelscope = {};
        this._schemaRetriever = schemaRetriever;
        this._timezone = timezone;
        this._nextStateVar = 0;
        this._nextProcId = 0;
        this._astVars = [];
    }
    compileCode(code, options = { timezone: undefined }) {
        const parsed = Grammar.parse(code, Grammar.SyntaxType.Normal, options);
        if (!(parsed instanceof Ast.Program))
            throw new Error(`Not an executable program`);
        return this.compileProgram(parsed);
    }
    _allocState() {
        return this._nextStateVar++;
    }
    _allocAst(v) {
        this._astVars.push(v);
        return this._astVars.length - 1;
    }
    _declareArguments(args, scope, irBuilder) {
        const compiledArgs = [];
        for (const name in args) {
            const reg = irBuilder.allocArgument();
            scope.set(name, {
                type: 'scalar',
                tt_type: args[name],
                register: reg,
                direction: 'input',
                isInVarScopeNames: false
            });
            compiledArgs.push(name);
        }
        return compiledArgs;
    }
    _compileAssignment(assignment, irBuilder, { hasAnyStream, forProcedure }) {
        const opCompiler = new ops_to_jsir_1.default(this, this._timezone, this._declarations, irBuilder);
        // at the top level, assignments can be referred to by streams, so
        // they need to be persistent (save to disk) such that when the program
        // is restarted, the result can be reused.
        // (this is only needed in top-level since stream is not allowed within
        // procedures)
        const isPersistent = hasAnyStream;
        let register;
        if (assignment.isAction) {
            const action = (0, ast_to_ops_1.compileActionToOps)(assignment.value, new Set, null);
            register = opCompiler.compileActionAssignment(action, isPersistent);
        }
        else {
            const schema = assignment.value.schema;
            (0, assert_1.default)(schema);
            const hints = new ops_1.QueryInvocationHints(new Set((0, utils_1.getDefaultProjection)(schema)));
            const tableop = (0, ast_to_ops_1.compileTableToOps)(assignment.value, hints);
            register = opCompiler.compileAssignment(tableop, isPersistent);
        }
        const schema = assignment.schema;
        (0, assert_1.default)(schema);
        this._declarations.set(assignment.name, {
            type: 'assignment',
            isPersistent, register, schema
        });
    }
    _compileProcedure(decl, parentIRBuilder) {
        const saveScope = this._declarations;
        const irBuilder = new JSIr.IRBuilder(parentIRBuilder ? parentIRBuilder.nextRegister : 0, ['__emit']);
        const procid = this._nextProcId++;
        irBuilder.setBeginEndHooks(new JSIr.EnterProcedure(procid, decl.name), new JSIr.ExitProcedure(procid, decl.name));
        const procedureScope = new scope_1.default(this._declarations);
        const args = this._declareArguments(decl.args, procedureScope, irBuilder);
        this._declarations = procedureScope;
        this._compileInScope(decl.declarations, decl.statements, irBuilder, {
            hasAnyStream: false,
            forProcedure: true
        });
        let code;
        let register;
        if (parentIRBuilder) {
            parentIRBuilder.skipRegisterRange(irBuilder.registerRange);
            register = parentIRBuilder.allocRegister();
            parentIRBuilder.add(new JSIr.AsyncFunctionDeclaration(register, irBuilder));
            code = null;
        }
        else {
            register = null;
            code = this._testMode ? irBuilder.codegen() : irBuilder.compile(this._toplevelscope, this._astVars);
            this._toplevelscope[decl.name] = code;
        }
        this._declarations = saveScope;
        (0, assert_1.default)(decl.schema);
        this._declarations.set(decl.name, {
            type: 'procedure',
            args, code, register,
            schema: decl.schema,
        });
    }
    _doCompileStatement(stmt, irBuilder, forProcedure, returnResult) {
        const opCompiler = new ops_to_jsir_1.default(this, this._timezone, this._declarations, irBuilder);
        const ruleop = (0, ast_to_ops_1.compileStatementToOp)(stmt);
        if (forProcedure)
            opCompiler.compileProcedureStatement(ruleop, returnResult);
        else
            opCompiler.compileStatement(ruleop);
    }
    _compileRule(rule) {
        // each rule goes into its own JS function
        const irBuilder = new JSIr.IRBuilder();
        this._doCompileStatement(rule, irBuilder, false, false);
        return this._testMode ? irBuilder.codegen()
            : irBuilder.compile(this._toplevelscope, this._astVars);
    }
    _compileInScope(declarations, stmts, irBuilder, { hasAnyStream, forProcedure }) {
        for (const decl of declarations)
            this._compileProcedure(decl, irBuilder);
        if (stmts.length === 0)
            return null;
        // all immediate statements are compiled into a single function, so we
        // create a single irBuilder that we share
        if (!irBuilder) {
            irBuilder = new JSIr.IRBuilder();
            const procid = this._nextProcId++;
            irBuilder.setBeginEndHooks(new JSIr.EnterProcedure(procid), new JSIr.ExitProcedure(procid));
        }
        // compute which statement will produce the procedure return value
        //
        // - if there is an explicit "return" statement, that's the one to use
        //   (this is the "new" way to do things)
        // - if there is a query statement, the last one wins
        // - otherwise, the last statement wins
        let returnStmtIdx = -1, resultStmtIdx = -1;
        for (let i = 0; i < stmts.length; i++) {
            const stmt = stmts[i];
            if (stmt instanceof Ast.ReturnStatement) {
                returnStmtIdx = i;
            }
            else if (stmt instanceof Ast.ExpressionStatement) {
                if (stmt.expression.schema.functionType === 'query') {
                    resultStmtIdx = i;
                }
                else {
                    if (resultStmtIdx < 0)
                        resultStmtIdx = i;
                }
            }
        }
        if (returnStmtIdx < 0)
            returnStmtIdx = resultStmtIdx;
        for (let i = 0; i < stmts.length; i++) {
            // if this is not the first statement, clear the get cache before running it
            if (i !== 0)
                irBuilder.add(new JSIr.ClearGetCache());
            const stmt = stmts[i];
            if (stmt instanceof Ast.Assignment)
                this._compileAssignment(stmt, irBuilder, { hasAnyStream, forProcedure });
            else
                this._doCompileStatement(stmt, irBuilder, forProcedure, i === returnStmtIdx);
        }
        return irBuilder;
    }
    _verifyCompilable(program) {
        if (program.principal !== null)
            throw new errors_1.NotCompilableError(`Remote programs cannot be compiled, they must be sent to a different runtime instead`);
        for (const slot of program.iterateSlots2()) {
            if (slot instanceof Ast.DeviceSelector) {
                if (slot.principal !== null)
                    throw new errors_1.NotCompilableError(`Remote primitives cannot be compiled, they must be lowered and sent to a different runtime instead`);
                continue;
            }
            if (!slot.isCompilable())
                throw new errors_1.NotCompilableError(`Programs with slots or unresolved values cannot be compiled, and must be slot-filled first`);
        }
    }
    async compileProgram(program) {
        await program.typecheck(this._schemaRetriever);
        this._verifyCompilable(program);
        const compiledRules = [];
        const immediate = [];
        const rules = [];
        for (const stmt of program.statements) {
            if (stmt instanceof Ast.Assignment || !stmt.stream)
                immediate.push(stmt);
            else
                rules.push(stmt);
        }
        this._declarations = new scope_1.default;
        const commandIRBuilder = this._compileInScope(program.declarations, immediate, null, {
            hasAnyStream: rules.length > 0,
            forProcedure: false
        });
        let compiledCommand;
        if (commandIRBuilder !== null) {
            // HACK: in test mode, we compile a string instead of a function
            // we use an unsound cast to avoid exposing this in the compiler public API
            if (this._testMode)
                compiledCommand = commandIRBuilder.codegen();
            else
                compiledCommand = commandIRBuilder.compile(this._toplevelscope, this._astVars);
        }
        else {
            compiledCommand = null;
        }
        for (const rule of rules)
            compiledRules.push(this._compileRule(rule));
        return new exec_environment_1.CompiledProgram(this._nextStateVar, compiledCommand, compiledRules);
    }
}
exports.default = AppCompiler;
//# sourceMappingURL=index.js.map