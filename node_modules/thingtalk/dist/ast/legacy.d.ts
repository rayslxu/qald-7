import Node, { SourceRange } from './base';
import { FunctionDef } from './function_def';
import { Invocation, DeviceSelector, InputParam } from './invocation';
import { BooleanExpression } from './boolean_expression';
import { Expression, FunctionCallExpression, InvocationExpression, FilterExpression, ProjectionExpression, AliasExpression, SortExpression, IndexExpression, SliceExpression, AggregationExpression, MonitorExpression, ChainExpression } from './expression';
import { Value } from './values';
import { AbstractSlot, OldSlot, ScopeMap, InvocationLike } from './slots';
import Type from '../type';
import NodeVisitor from './visitor';
import { TokenStream } from '../new-syntax/tokenstream';
/**
 * The base class of all ThingTalk query expressions.
 *
 * @deprecated This class is part of ThingTalk 1.0. Use {@link Ast.Expression} in ThingTalk 2.0.
 */
export declare abstract class Table extends Node {
    static VarRef: typeof VarRefTable;
    isVarRef: boolean;
    static Invocation: typeof InvocationTable;
    isInvocation: boolean;
    static Filter: typeof FilteredTable;
    isFilter: boolean;
    static Projection: typeof ProjectionTable;
    isProjection: boolean;
    static Compute: typeof ComputeTable;
    isCompute: boolean;
    static Alias: typeof AliasTable;
    isAlias: boolean;
    static Aggregation: typeof AggregationTable;
    isAggregation: boolean;
    static Sort: typeof SortedTable;
    isSort: boolean;
    static Index: typeof IndexTable;
    isIndex: boolean;
    static Slice: typeof SlicedTable;
    isSlice: boolean;
    static Join: typeof JoinTable;
    isJoin: boolean;
    schema: FunctionDef | null;
    /**
     * Construct a new table node.
     *
     * @param location - the position of this node in the source code
     * @param schema - type signature of the invoked function
     */
    constructor(location: SourceRange | null, schema: FunctionDef | null);
    toSource(): TokenStream;
    abstract toExpression(extra_in_params: InputParam[]): Expression;
    abstract clone(): Table;
    /**
     * Iterate all slots (scalar value nodes) in this table.
     *
     * @param scope - available names for parameter passing
     * @deprecated Use {@link Table.iterateSlots2} instead.
     */
    abstract iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    /**
     * Iterate all slots (scalar value nodes) in this table.
     *
     * @param scope - available names for parameter passing
     */
    abstract iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class VarRefTable extends Table {
    name: string;
    in_params: InputParam[];
    constructor(location: SourceRange | null, name: string, in_params: InputParam[], schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): FunctionCallExpression;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    clone(): VarRefTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class InvocationTable extends Table {
    invocation: Invocation;
    constructor(location: SourceRange | null, invocation: Invocation, schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): InvocationExpression;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    clone(): InvocationTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class FilteredTable extends Table {
    table: Table;
    filter: BooleanExpression;
    constructor(location: SourceRange | null, table: Table, filter: BooleanExpression, schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): FilterExpression;
    visit(visitor: NodeVisitor): void;
    clone(): FilteredTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class ProjectionTable extends Table {
    table: Table;
    args: string[];
    constructor(location: SourceRange | null, table: Table, args: string[], schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): ProjectionExpression;
    visit(visitor: NodeVisitor): void;
    clone(): ProjectionTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class ComputeTable extends Table {
    table: Table;
    expression: Value;
    alias: string | null;
    type: Type | null;
    constructor(location: SourceRange | null, table: Table, expression: Value, alias: string | null, schema: FunctionDef | null, type?: Type | null);
    toExpression(extra_in_params: InputParam[]): ProjectionExpression;
    visit(visitor: NodeVisitor): void;
    clone(): ComputeTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class AliasTable extends Table {
    table: Table;
    name: string;
    constructor(location: SourceRange | null, table: Table, name: string, schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): AliasExpression;
    visit(visitor: NodeVisitor): void;
    clone(): AliasTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class AggregationTable extends Table {
    table: Table;
    field: string;
    operator: string;
    alias: string | null;
    overload: Type[] | null;
    constructor(location: SourceRange | null, table: Table, field: string, operator: string, alias: string | null, schema: FunctionDef | null, overload?: Type[] | null);
    toExpression(extra_in_params: InputParam[]): AggregationExpression;
    visit(visitor: NodeVisitor): void;
    clone(): AggregationTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class SortedTable extends Table {
    table: Table;
    field: string;
    direction: 'asc' | 'desc';
    constructor(location: SourceRange | null, table: Table, field: string, direction: 'asc' | 'desc', schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): SortExpression;
    visit(visitor: NodeVisitor): void;
    clone(): SortedTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class IndexTable extends Table {
    table: Table;
    indices: Value[];
    constructor(location: SourceRange | null, table: Table, indices: Value[], schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): IndexExpression;
    visit(visitor: NodeVisitor): void;
    clone(): IndexTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class SlicedTable extends Table {
    table: Table;
    base: Value;
    limit: Value;
    constructor(location: SourceRange | null, table: Table, base: Value, limit: Value, schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): SliceExpression;
    visit(visitor: NodeVisitor): void;
    clone(): SlicedTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class JoinTable extends Table {
    lhs: Table;
    rhs: Table;
    in_params: InputParam[];
    constructor(location: SourceRange | null, lhs: Table, rhs: Table, in_params: InputParam[], schema: FunctionDef | null);
    toExpression(extra_in_params: InputParam[]): ChainExpression;
    visit(visitor: NodeVisitor): void;
    clone(): JoinTable;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
/**
 * The base class of all ThingTalk stream expressions.
 *
 * @deprecated This class is part of ThingTalk 1.0. Use {@link Ast.Expression} in ThingTalk 2.0.
 */
export declare abstract class Stream extends Node {
    static VarRef: typeof VarRefStream;
    isVarRef: boolean;
    static Timer: typeof TimerStream;
    isTimer: boolean;
    static AtTimer: typeof AtTimerStream;
    isAtTimer: boolean;
    static Monitor: typeof MonitorStream;
    isMonitor: boolean;
    static EdgeNew: typeof EdgeNewStream;
    isEdgeNew: boolean;
    static EdgeFilter: typeof EdgeFilterStream;
    isEdgeFilter: boolean;
    static Filter: typeof FilteredStream;
    isFilter: boolean;
    static Projection: typeof ProjectionStream;
    isProjection: boolean;
    static Compute: typeof ComputeStream;
    isCompute: boolean;
    static Alias: typeof AliasStream;
    isAlias: boolean;
    static Join: typeof JoinStream;
    isJoin: boolean;
    schema: FunctionDef | null;
    /**
     * Construct a new stream node.
     *
     * @param location - the position of this node in the source code
     * @param schema - type signature of the stream expression
     */
    constructor(location: SourceRange | null, schema: FunctionDef | null);
    toSource(): TokenStream;
    abstract toExpression(): Expression;
    abstract clone(): Stream;
    /**
     * Iterate all slots (scalar value nodes) in this stream.
     *
     * @param scope - available names for parameter passing
     * @deprecated Use {@link Ast.Stream.iterateSlots2} instead.
     */
    abstract iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    /**
     * Iterate all slots (scalar value nodes) in this stream.
     *
     * @param scope - available names for parameter passing
     */
    abstract iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class VarRefStream extends Stream {
    name: string;
    in_params: InputParam[];
    constructor(location: SourceRange | null, name: string, in_params: InputParam[], schema: FunctionDef | null);
    toExpression(): FunctionCallExpression;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    clone(): VarRefStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class TimerStream extends Stream {
    base: Value;
    interval: Value;
    frequency: Value | null;
    constructor(location: SourceRange | null, base: Value, interval: Value, frequency: Value | null, schema: FunctionDef | null);
    toExpression(): FunctionCallExpression;
    visit(visitor: NodeVisitor): void;
    clone(): TimerStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class AtTimerStream extends Stream {
    time: Value[];
    expiration_date: Value | null;
    constructor(location: SourceRange | null, time: Value[], expiration_date: Value | null, schema: FunctionDef | null);
    toExpression(): FunctionCallExpression;
    visit(visitor: NodeVisitor): void;
    clone(): AtTimerStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class MonitorStream extends Stream {
    table: Table;
    args: string[] | null;
    constructor(location: SourceRange | null, table: Table, args: string[] | null, schema: FunctionDef | null);
    toExpression(): MonitorExpression;
    visit(visitor: NodeVisitor): void;
    clone(): MonitorStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class EdgeNewStream extends Stream {
    stream: Stream;
    constructor(location: SourceRange | null, stream: Stream, schema: FunctionDef | null);
    toExpression(): never;
    visit(visitor: NodeVisitor): void;
    clone(): EdgeNewStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class EdgeFilterStream extends Stream {
    stream: Stream;
    filter: BooleanExpression;
    constructor(location: SourceRange | null, stream: Stream, filter: BooleanExpression, schema: FunctionDef | null);
    toExpression(): FilterExpression;
    visit(visitor: NodeVisitor): void;
    clone(): EdgeFilterStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class FilteredStream extends Stream {
    stream: Stream;
    filter: BooleanExpression;
    constructor(location: SourceRange | null, stream: Stream, filter: BooleanExpression, schema: FunctionDef | null);
    toExpression(): Expression;
    visit(visitor: NodeVisitor): void;
    clone(): FilteredStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class ProjectionStream extends Stream {
    stream: Stream;
    args: string[];
    constructor(location: SourceRange | null, stream: Stream, args: string[], schema: FunctionDef | null);
    toExpression(): ProjectionExpression;
    visit(visitor: NodeVisitor): void;
    clone(): ProjectionStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class ComputeStream extends Stream {
    stream: Stream;
    expression: Value;
    alias: string | null;
    type: Type | null;
    constructor(location: SourceRange | null, stream: Stream, expression: Value, alias: string | null, schema: FunctionDef | null, type?: Type | null);
    toExpression(): ProjectionExpression;
    visit(visitor: NodeVisitor): void;
    clone(): ComputeStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class AliasStream extends Stream {
    stream: Stream;
    name: string;
    constructor(location: SourceRange | null, stream: Stream, name: string, schema: FunctionDef | null);
    toExpression(): AliasExpression;
    visit(visitor: NodeVisitor): void;
    clone(): AliasStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class JoinStream extends Stream {
    stream: Stream;
    table: Table;
    in_params: InputParam[];
    constructor(location: SourceRange | null, stream: Stream, table: Table, in_params: InputParam[], schema: FunctionDef | null);
    toExpression(): ChainExpression;
    visit(visitor: NodeVisitor): void;
    clone(): JoinStream;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
/**
 * Base class for all expressions that invoke an action.
 *
 * @deprecated This class is part of ThingTalk 1.0. Use {@link Ast.Expression} in ThingTalk 2.0.
 */
export declare abstract class Action extends Node {
    static VarRef: typeof VarRefAction;
    isVarRef: boolean;
    static Invocation: typeof InvocationAction;
    isInvocation: boolean;
    static Notify: typeof NotifyAction;
    isNotify: boolean;
    /**
     * Type signature of this action.
     * This property is guaranteed not `null` after type-checking.
     */
    schema: FunctionDef | null;
    /**
     * Construct a new action expression node.
     *
     * @param location - the position of this node in the source code
     * @param schema - type signature of this action
     */
    constructor(location: SourceRange | null, schema: FunctionDef | null);
    /**
     * Utility function to create a `notify` or `return` action.
     *
     * @param {string} [what=notify] - what action to create
     * @return {Ast.Action} the action node
     */
    static notifyAction(what?: 'notify'): NotifyAction;
    abstract toExpression(): Expression;
    abstract clone(): Action;
    /**
     * Iterate all slots (scalar value nodes) in this action.
     *
     * @param scope - available names for parameter passing
     * @deprecated Use {@link Ast.Action.iterateSlots2} instead.
     */
    abstract iterateSlots(scope: ScopeMap): Generator<OldSlot, void>;
    /**
     * Iterate all slots (scalar value nodes) in this action.
     *
     * @param scope - available names for parameter passing
     */
    abstract iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * An invocation of a locally defined action (i.e. one defined with
 * a `let` statement).
 *
 */
export declare class VarRefAction extends Action {
    /**
     * The name of the action to invoke.
     */
    name: string;
    /**
     * The input parameters to pass.
     */
    in_params: InputParam[];
    /**
     * Construct a new var ref action.
     *
     * @param location - the position of this node in the source code
     * @param name - the name of the action to invoke
     * @param in_params - the input parameters to pass
     * @param schema - type signature of this action
     */
    constructor(location: SourceRange | null, name: string, in_params: InputParam[], schema: FunctionDef | null);
    toExpression(): FunctionCallExpression;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    clone(): VarRefAction;
    toString(): string;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * An invocation of an action in Thingpedia.
 *
 */
export declare class InvocationAction extends Action {
    /**
     * The actual invocation expression.
     */
    invocation: Invocation;
    /**
     * Construct a new invocation action.
     *
     * @param location - the position of this node in the source code
     * @param invocation - the function invocation
     * @param schema - type signature of this action
     */
    constructor(location: SourceRange | null, invocation: Invocation, schema: FunctionDef | null);
    toExpression(): InvocationExpression;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    clone(): InvocationAction;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A `notify`, `return` or `save` clause.
 *
 */
export declare class NotifyAction extends Action {
    name: 'notify';
    /**
     * Construct a new notify action.
     *
     * @param location - the position of this node in the source code
     * @param name - the clause name
     * @param schema - type signature of this action
     */
    constructor(location: SourceRange | null, name: 'notify', schema?: FunctionDef | null);
    toExpression(): never;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    clone(): NotifyAction;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
