import Type from '../type';
import { Value } from './values';
import { Invocation, DeviceSelector, InputParam } from './invocation';
import { AtomBooleanExpression } from './boolean_expression';
import { ArgumentDef, FunctionDef } from './function_def';
export interface ScopeEntry {
    type: Type;
    value: Value;
    argcanonical?: string;
    _prim?: InvocationLike | null;
    kind?: string | null;
    kind_canonical?: string;
}
export declare type ScopeMap = {
    [key: string]: ScopeEntry;
};
interface ExternalBooleanExpressionLike {
    selector: DeviceSelector;
    channel: string;
    in_params: InputParam[];
    schema: FunctionDef | null;
}
interface PermissionFunctionLike {
    kind: string;
    channel: string;
    schema: FunctionDef | null;
}
interface VarRefLike {
    name: string;
    in_params: InputParam[];
    schema: FunctionDef | null;
}
export declare type InvocationLike = Invocation | ExternalBooleanExpressionLike | VarRefLike | PermissionFunctionLike;
/**
 * The abstract representation of a slot.
 *
 * A slot is a placeholder for a value that can be replaced or changed by
 * API user. This API is used to iterate all values (parameters and filters)
 * in a program.
 *
 */
export declare abstract class AbstractSlot {
    private _prim;
    protected _scope: ScopeMap;
    protected _options: ScopeEntry[] | undefined;
    /**
     * Construct a new abstract slot.
     *
     * @param prim - the primitive associated with this slot, if any
     * @param scope - available names for parameter passing
     */
    protected constructor(prim: InvocationLike | null, scope: ScopeMap);
    /**
     * The primitive associated with this slot, if any.
     */
    get primitive(): InvocationLike | null;
    /**
     * The function argument associated with this slot, if any.
     */
    get arg(): ArgumentDef | null;
    /**
     * Names which are available for parameter passing into this slot.
     */
    get scope(): ScopeMap;
    /**
     * The available options to parameter pass from.
     *
     * This is the subset of {@link AbstractSlot.scope} whose type matches
     * that of this slot.
     */
    get options(): ScopeEntry[];
    /**
     * The type of this slot.
     */
    abstract get type(): Type;
    abstract get tag(): string;
    abstract get(): Value;
    abstract set(value: Value): void;
    get _argcanonical(): string;
    isUndefined(): boolean;
    isConcrete(): boolean;
    isCompilable(): boolean;
}
export declare class InputParamSlot extends AbstractSlot {
    private _arg;
    private _slot;
    constructor(prim: InvocationLike | null, scope: ScopeMap, arg: ArgumentDef | null, slot: InputParam);
    toString(): string;
    get _argcanonical(): string;
    get arg(): ArgumentDef | null;
    get type(): Type;
    get tag(): string;
    get(): Value;
    set(value: Value): void;
}
export declare class ResultSlot extends AbstractSlot {
    private _arg;
    private _object;
    private _key;
    constructor(prim: Invocation | null, scope: ScopeMap, arg: ArgumentDef | null, object: unknown, key: string);
    toString(): string;
    get _argcanonical(): string;
    get arg(): ArgumentDef | null;
    get type(): Type;
    get tag(): string;
    get(): Value;
    set(value: Value): void;
}
export declare class DeviceAttributeSlot extends AbstractSlot {
    private _slot;
    constructor(prim: Invocation | null, attr: InputParam);
    toString(): string;
    get type(): Type;
    get tag(): string;
    get(): Value;
    set(value: Value): void;
}
export declare class FilterSlot extends AbstractSlot {
    private _arg;
    private _filter;
    constructor(prim: InvocationLike | null, scope: ScopeMap, arg: ArgumentDef | null, filter: AtomBooleanExpression);
    toString(): string;
    get _argcanonical(): string;
    get options(): ScopeEntry[];
    get arg(): ArgumentDef | null;
    get type(): Type;
    get tag(): string;
    get(): Value;
    set(value: Value): void;
}
export declare class ArrayIndexSlot extends AbstractSlot {
    private _type;
    private _array;
    private _parent;
    private _baseTag;
    private _index;
    constructor(prim: InvocationLike | null, scope: ScopeMap, type: Type, array: Value[], parent: AbstractSlot | string, index: number);
    toString(): string;
    get _argcanonical(): string;
    get arg(): ArgumentDef | null;
    get type(): Type;
    get tag(): string;
    get(): Value;
    set(value: Value): void;
}
export declare class ComputationOperandSlot extends AbstractSlot {
    private _type;
    private _operator;
    private _operands;
    private _parent;
    private _baseTag;
    private _index;
    constructor(prim: InvocationLike | null, scope: ScopeMap, type: Type, operator: string, operands: Value[], parent: AbstractSlot | string, index: number);
    toString(): string;
    get _argcanonical(): string;
    get arg(): ArgumentDef | null;
    get type(): Type;
    get tag(): string;
    get(): Value;
    set(value: Value): void;
}
export declare class FieldSlot extends AbstractSlot {
    private _type;
    private _container;
    private _tag;
    private _field;
    constructor(prim: InvocationLike | null, scope: ScopeMap, type: Type, container: unknown, baseTag: string, field: string);
    toString(): string;
    get type(): Type;
    get tag(): string;
    get(): Value;
    set(value: Value): void;
}
export declare function makeScope(invocation: InvocationLike): ScopeMap;
export declare function recursiveYieldArraySlots(slot: AbstractSlot): Generator<AbstractSlot>;
export declare function iterateSlots2InputParams(prim: Invocation | VarRefLike | ExternalBooleanExpressionLike, scope: ScopeMap): Generator<AbstractSlot, [InvocationLike, ScopeMap]>;
/**
 * Type used by the old slot iteration API.
 *
 * @deprecated Use {@link Ast~AbstractSlot} and the new slot iteration API
 */
export declare type OldSlot = [FunctionDef | null, (InputParam | AtomBooleanExpression | DeviceSelector), InvocationLike | null, ScopeMap];
export {};
