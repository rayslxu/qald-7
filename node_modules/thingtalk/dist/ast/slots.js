"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterateSlots2InputParams = exports.recursiveYieldArraySlots = exports.makeScope = exports.FieldSlot = exports.ComputationOperandSlot = exports.ArrayIndexSlot = exports.FilterSlot = exports.DeviceAttributeSlot = exports.ResultSlot = exports.InputParamSlot = exports.AbstractSlot = void 0;
const assert_1 = __importDefault(require("assert"));
const type_1 = __importDefault(require("../type"));
const utils_1 = require("../utils");
const values_1 = require("./values");
/**
 * The abstract representation of a slot.
 *
 * A slot is a placeholder for a value that can be replaced or changed by
 * API user. This API is used to iterate all values (parameters and filters)
 * in a program.
 *
 */
class AbstractSlot {
    /**
     * Construct a new abstract slot.
     *
     * @param prim - the primitive associated with this slot, if any
     * @param scope - available names for parameter passing
     */
    constructor(prim, scope) {
        (0, assert_1.default)(prim || prim === null);
        this._prim = prim;
        this._scope = scope;
        this._options = undefined;
    }
    /**
     * The primitive associated with this slot, if any.
     */
    get primitive() {
        return this._prim;
    }
    /**
     * The function argument associated with this slot, if any.
     */
    get arg() {
        return null;
    }
    /**
     * Names which are available for parameter passing into this slot.
     */
    get scope() {
        return this._scope;
    }
    /**
     * The available options to parameter pass from.
     *
     * This is the subset of {@link AbstractSlot.scope} whose type matches
     * that of this slot.
     */
    get options() {
        // this is computed lazily because it needs this.type, which
        // is not available in the constructor
        if (this._options)
            return this._options;
        const options = [];
        const slotType = this.type;
        for (const vname in this._scope) {
            const option = this._scope[vname];
            if (type_1.default.isAssignable(option.type, slotType))
                options.push(option);
        }
        return this._options = options;
    }
    get _argcanonical() {
        return '';
    }
    isUndefined() {
        return this.get().isUndefined;
    }
    isConcrete() {
        return this.get().isConcrete();
    }
    isCompilable() {
        const value = this.get();
        if (value.isUndefined)
            return false;
        if (!value.isConcrete())
            return false;
        const valueType = value.getType();
        const slotType = this.type;
        if (valueType instanceof type_1.default.Entity && slotType instanceof type_1.default.Entity &&
            valueType.type === 'tt:username' && slotType.type !== 'tt:username')
            return false;
        return true;
    }
}
exports.AbstractSlot = AbstractSlot;
class InputParamSlot extends AbstractSlot {
    constructor(prim, scope, arg, slot) {
        super(prim, scope);
        this._arg = arg;
        this._slot = slot;
    }
    toString() {
        return `InputParamSlot(${this._slot.name} : ${this.type})`;
    }
    get _argcanonical() {
        return this._arg ? this._arg.canonical : (0, utils_1.clean)(this._slot.name);
    }
    get arg() {
        return this._arg || null;
    }
    get type() {
        if (this._arg)
            return this._arg.type;
        else
            return type_1.default.Any;
    }
    get tag() {
        return `in_param.${this._slot.name}`;
    }
    get() {
        return this._slot.value;
    }
    set(value) {
        this._slot.value = value;
    }
}
exports.InputParamSlot = InputParamSlot;
class ResultSlot extends AbstractSlot {
    constructor(prim, scope, arg, object, key) {
        super(prim, scope);
        this._arg = arg;
        this._object = object;
        this._key = key;
    }
    toString() {
        return `ResultSlot(${this._key} : ${this.type})`;
    }
    get _argcanonical() {
        return this._arg ? this._arg.canonical : (0, utils_1.clean)(this._key);
    }
    get arg() {
        return this._arg || null;
    }
    get type() {
        if (this._arg)
            return this._arg.type;
        else
            return this.get().getType();
    }
    get tag() {
        return `result.${this._key}`;
    }
    get() {
        return this._object[this._key];
    }
    set(value) {
        this._object[this._key] = value;
    }
}
exports.ResultSlot = ResultSlot;
class DeviceAttributeSlot extends AbstractSlot {
    constructor(prim, attr) {
        super(prim, {});
        this._slot = attr;
        (0, assert_1.default)(this._slot.name === 'name');
    }
    toString() {
        return `DeviceAttributeSlot(${this._slot.name} : ${this.type})`;
    }
    get type() {
        return type_1.default.String;
    }
    get tag() {
        return `attribute.${this._slot.name}`;
    }
    get() {
        return this._slot.value;
    }
    set(value) {
        this._slot.value = value;
    }
}
exports.DeviceAttributeSlot = DeviceAttributeSlot;
class FilterSlot extends AbstractSlot {
    constructor(prim, scope, arg, filter) {
        super(prim, scope);
        this._arg = arg;
        this._filter = filter;
    }
    toString() {
        return `FilterSlot(${this._filter.name} ${this._filter.operator} : ${this.type})`;
    }
    get _argcanonical() {
        return this._arg ? this._arg.canonical : (0, utils_1.clean)(this._filter.name);
    }
    // overidde the default option handling to filter out non-sensical filters such as "x == x"
    get options() {
        if (this._options)
            return this._options;
        const options = [];
        const slotType = this.type;
        for (const vname in this._scope) {
            const option = this._scope[vname];
            if (type_1.default.isAssignable(option.type, slotType)) {
                if (option.value instanceof values_1.VarRefValue && option.value.name === this._filter.name &&
                    option._prim === this.primitive)
                    continue;
                if (option.value.isEvent)
                    continue;
                options.push(option);
            }
        }
        return this._options = options;
    }
    get arg() {
        return this._arg || null;
    }
    get type() {
        if (this._arg) {
            switch (this._filter.operator) {
                case 'contains':
                    return this._arg.type.elem;
                case 'contains~':
                    return type_1.default.String;
                case '~contains':
                    return type_1.default.String;
                case 'in_array':
                    return new type_1.default.Array(this._arg.type);
                case 'in_array~':
                    return new type_1.default.Array(type_1.default.String);
                case '~in_array':
                    return type_1.default.String;
                default:
                    return this._arg.type;
            }
        }
        else {
            return type_1.default.Any;
        }
    }
    get tag() {
        return `filter.${this._filter.operator}.${this._filter.name}`;
    }
    get() {
        return this._filter.value;
    }
    set(value) {
        this._filter.value = value;
    }
}
exports.FilterSlot = FilterSlot;
class ArrayIndexSlot extends AbstractSlot {
    constructor(prim, scope, type, array, parent, index) {
        super(prim, scope);
        this._type = type;
        this._array = array;
        if (typeof parent === 'string') {
            this._baseTag = parent;
            this._parent = null;
        }
        else {
            this._baseTag = parent.tag;
            this._parent = parent;
        }
        this._index = index;
    }
    toString() {
        return `ArrayIndexSlot([${this._index}] : ${this.type})`;
    }
    get _argcanonical() {
        if (this._parent)
            return this._parent._argcanonical;
        return '';
    }
    get arg() {
        return this._parent ? this._parent.arg : null;
    }
    get type() {
        return this._type;
    }
    get tag() {
        return `${this._baseTag}.${this._index}`;
    }
    get() {
        return this._array[this._index];
    }
    set(value) {
        this._array[this._index] = value;
    }
}
exports.ArrayIndexSlot = ArrayIndexSlot;
class ComputationOperandSlot extends AbstractSlot {
    constructor(prim, scope, type, operator, operands, parent, index) {
        super(prim, scope);
        this._type = type;
        this._operator = operator;
        this._operands = operands;
        if (typeof parent === 'string') {
            this._baseTag = parent;
            this._parent = null;
        }
        else {
            this._baseTag = parent.tag;
            this._parent = parent;
        }
        this._index = index;
    }
    toString() {
        return `ComputationOperandSlot(${this._operator}[${this._index}] : ${this.type})`;
    }
    get _argcanonical() {
        if (this._parent)
            return this._parent._argcanonical;
        return '';
    }
    get arg() {
        return this._parent ? this._parent.arg : null;
    }
    get type() {
        return this._type;
    }
    get tag() {
        return `${this._baseTag}.${this._operator}.${this._index}`;
    }
    get() {
        return this._operands[this._index];
    }
    set(value) {
        this._operands[this._index] = value;
    }
}
exports.ComputationOperandSlot = ComputationOperandSlot;
class FieldSlot extends AbstractSlot {
    constructor(prim, scope, type, container, baseTag, field) {
        super(prim, scope);
        this._type = type;
        this._container = container;
        this._tag = baseTag + '.' + field;
        this._field = field;
    }
    toString() {
        return `FieldSlot(${this._field} : ${this.type})`;
    }
    get type() {
        return this._type;
    }
    get tag() {
        return this._tag;
    }
    get() {
        return this._container[this._field];
    }
    set(value) {
        this._container[this._field] = value;
    }
}
exports.FieldSlot = FieldSlot;
function makeScope(invocation) {
    // make out parameters available in the "scope", which puts
    // them as possible options for a later slot fill
    const schema = invocation.schema;
    if (!schema)
        return {};
    const scope = {};
    for (const argname in schema.out) {
        const argcanonical = schema.getArgCanonical(argname);
        let kind = null;
        if (invocation.selector)
            kind = invocation.selector.kind;
        else
            kind = null;
        scope[argname] = {
            value: new values_1.Value.VarRef(argname),
            type: schema.out[argname],
            argcanonical: argcanonical,
            _prim: invocation,
            kind: kind,
            kind_canonical: schema.class ? (schema.class.metadata.canonical || null) : null,
        };
    }
    scope['$event'] = {
        value: new values_1.Value.Event(null),
        type: type_1.default.String,
    };
    return scope;
}
exports.makeScope = makeScope;
function* recursiveYieldArraySlots(slot) {
    // despite the name, this function also handles computation
    yield slot;
    const value = slot.get();
    if (value instanceof values_1.ArrayValue) {
        const type = slot.type;
        (0, assert_1.default)(type instanceof type_1.default.Array);
        for (let i = 0; i < value.value.length; i++)
            yield* recursiveYieldArraySlots(new ArrayIndexSlot(slot.primitive, slot.scope, type.elem, value.value, slot, i));
    }
    else if (value instanceof values_1.ComputationValue) {
        const overload = value.overload || [];
        if (overload.length !== value.operands.length + 1)
            console.error('Missing overload on computation value: ' + value);
        for (let i = 0; i < value.operands.length; i++)
            yield* recursiveYieldArraySlots(new ComputationOperandSlot(slot.primitive, slot.scope, overload[i] || type_1.default.Any, value.op, value.operands, slot, i));
    }
}
exports.recursiveYieldArraySlots = recursiveYieldArraySlots;
function* iterateSlots2InputParams(prim, scope) {
    for (const in_param of prim.in_params) {
        const arg = (prim.schema ? prim.schema.getArgument(in_param.name) : null) || null;
        yield* recursiveYieldArraySlots(new InputParamSlot(prim, scope, arg, in_param));
    }
    return [prim, makeScope(prim)];
}
exports.iterateSlots2InputParams = iterateSlots2InputParams;
//# sourceMappingURL=slots.js.map