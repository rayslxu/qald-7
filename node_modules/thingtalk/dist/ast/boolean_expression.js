"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PropertyPathBooleanExpression = exports.PropertyPathElement = exports.ComputeBooleanExpression = exports.FalseBooleanExpression = exports.TrueBooleanExpression = exports.DontCareBooleanExpression = exports.ComparisonSubqueryBooleanExpression = exports.ExistentialSubqueryBooleanExpression = exports.ExternalBooleanExpression = exports.NotBooleanExpression = exports.AtomBooleanExpression = exports.OrBooleanExpression = exports.AndBooleanExpression = exports.BooleanExpression = void 0;
const assert_1 = __importDefault(require("assert"));
const base_1 = __importDefault(require("./base"));
const function_def_1 = require("./function_def");
const values_1 = require("./values");
const expression_1 = require("./expression");
const Optimizer = __importStar(require("../optimize"));
const slots_1 = require("./slots");
const invocation_1 = require("./invocation");
const list_1 = __importDefault(require("../utils/list"));
const errors_1 = require("../utils/errors");
const syntax_priority_1 = require("./syntax_priority");
const array_equals_1 = __importDefault(require("./array_equals"));
/**
 * An expression that computes a boolean predicate.
 * This AST node is used in filter expressions.
 */
class BooleanExpression extends base_1.default {
    optimize() {
        return Optimizer.optimizeFilter(this);
    }
}
exports.BooleanExpression = BooleanExpression;
BooleanExpression.prototype.isAnd = false;
BooleanExpression.prototype.isOr = false;
BooleanExpression.prototype.isAtom = false;
BooleanExpression.prototype.isNot = false;
BooleanExpression.prototype.isExternal = false;
BooleanExpression.prototype.isExistentialSubquery = false;
BooleanExpression.prototype.isComparisonSubquery = false;
BooleanExpression.prototype.isTrue = false;
BooleanExpression.prototype.isFalse = false;
BooleanExpression.prototype.isCompute = false;
BooleanExpression.prototype.isDontCare = false;
BooleanExpression.prototype.isPropertyPath = false;
/**
 * A conjunction boolean expression (ThingTalk operator `&&`)
 */
class AndBooleanExpression extends BooleanExpression {
    /**
     * Construct a new And expression.
     *
     * @param location - the position of this node in the source code
     * @param operands - the expression operands
     */
    constructor(location, operands) {
        super(location);
        (0, assert_1.default)(Array.isArray(operands));
        this.operands = operands;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.And;
    }
    toSource() {
        return list_1.default.join(this.operands.map((op) => (0, syntax_priority_1.addParenthesis)(this.priority, op.priority, op.toSource())), '&&');
    }
    toLegacy() {
        return new AndBooleanExpression(null, this.operands.map((op) => op.toLegacy()));
    }
    equals(other) {
        return other instanceof AndBooleanExpression &&
            (0, array_equals_1.default)(this.operands, other.operands);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAndBooleanExpression(this)) {
            for (const operand of this.operands)
                operand.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new AndBooleanExpression(this.location, this.operands.map((operand) => operand.clone()));
    }
    *iterateSlots(schema, prim, scope) {
        for (const op of this.operands)
            yield* op.iterateSlots(schema, prim, scope);
    }
    *iterateSlots2(schema, prim, scope) {
        for (const op of this.operands)
            yield* op.iterateSlots2(schema, prim, scope);
    }
}
exports.AndBooleanExpression = AndBooleanExpression;
BooleanExpression.And = AndBooleanExpression;
BooleanExpression.And.prototype.isAnd = true;
/**
 * A disjunction boolean expression (ThingTalk operator `||`)
 */
class OrBooleanExpression extends BooleanExpression {
    /**
     * Construct a new Or expression.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {Ast.BooleanExpression[]} operands - the expression operands
     */
    constructor(location, operands) {
        super(location);
        (0, assert_1.default)(Array.isArray(operands));
        this.operands = operands;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Or;
    }
    toSource() {
        return list_1.default.join(this.operands.map((op) => (0, syntax_priority_1.addParenthesis)(this.priority, op.priority, op.toSource())), '||');
    }
    toLegacy() {
        return new OrBooleanExpression(null, this.operands.map((op) => op.toLegacy()));
    }
    equals(other) {
        return other instanceof OrBooleanExpression &&
            (0, array_equals_1.default)(this.operands, other.operands);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitOrBooleanExpression(this)) {
            for (const operand of this.operands)
                operand.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new OrBooleanExpression(this.location, this.operands.map((operand) => operand.clone()));
    }
    *iterateSlots(schema, prim, scope) {
        for (const op of this.operands)
            yield* op.iterateSlots(schema, prim, scope);
    }
    *iterateSlots2(schema, prim, scope) {
        for (const op of this.operands)
            yield* op.iterateSlots2(schema, prim, scope);
    }
}
exports.OrBooleanExpression = OrBooleanExpression;
BooleanExpression.Or = OrBooleanExpression;
BooleanExpression.Or.prototype.isOr = true;
const INFIX_COMPARISON_OPERATORS = new Set(['==', '>=', '<=', '>', '<', '=~', '~=']);
/**
 * A comparison expression (predicate atom)
 */
class AtomBooleanExpression extends BooleanExpression {
    /**
     * Construct a new atom boolean expression.
     *
     * @param location - the position of this node in the source code
     * @param name - the parameter name to compare
     * @param operator - the comparison operator
     * @param value - the value being compared against
     */
    constructor(location, name, operator, value, overload) {
        super(location);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(typeof operator === 'string');
        this.operator = operator;
        (0, assert_1.default)(value instanceof values_1.Value);
        this.value = value;
        this.overload = overload;
    }
    get priority() {
        return INFIX_COMPARISON_OPERATORS.has(this.operator) ? syntax_priority_1.SyntaxPriority.Comp : syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        const name = list_1.default.join(this.name.split('.').map((n) => list_1.default.singleton(n)), '.');
        if (INFIX_COMPARISON_OPERATORS.has(this.operator)) {
            return list_1.default.concat(name, this.operator, (0, syntax_priority_1.addParenthesis)(syntax_priority_1.SyntaxPriority.Add, this.value.priority, this.value.toSource()));
        }
        else {
            return list_1.default.concat(this.operator, '(', name, ',', this.value.toSource(), ')');
        }
    }
    toLegacy() {
        return this;
    }
    equals(other) {
        return other instanceof AtomBooleanExpression &&
            this.name === other.name &&
            this.operator === other.operator &&
            this.value.equals(other.value);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAtomBooleanExpression(this))
            this.value.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new AtomBooleanExpression(this.location, this.name, this.operator, this.value.clone(), this.overload);
    }
    toString() {
        return `Atom(${this.name}, ${this.operator}, ${this.value})`;
    }
    *iterateSlots(schema, prim, scope) {
        yield [schema, this, prim, scope];
    }
    *iterateSlots2(schema, prim, scope) {
        const arg = (schema ? schema.getArgument(this.name) : null) || null;
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FilterSlot(prim, scope, arg, this));
    }
}
exports.AtomBooleanExpression = AtomBooleanExpression;
BooleanExpression.Atom = AtomBooleanExpression;
BooleanExpression.Atom.prototype.isAtom = true;
/**
 * A negation boolean expression (ThingTalk operator `!`)
 */
class NotBooleanExpression extends BooleanExpression {
    /**
     * Construct a new Not expression.
     *
     * @param location - the position of this node in the source code
     * @param expr - the expression being negated
     */
    constructor(location, expr) {
        super(location);
        (0, assert_1.default)(expr instanceof BooleanExpression);
        this.expr = expr;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Not;
    }
    toSource() {
        return list_1.default.concat('!', (0, syntax_priority_1.addParenthesis)(this.priority, this.expr.priority, this.expr.toSource()));
    }
    toLegacy() {
        return new NotBooleanExpression(null, this.expr.toLegacy());
    }
    equals(other) {
        return other instanceof NotBooleanExpression &&
            this.expr.equals(other.expr);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitNotBooleanExpression(this))
            this.expr.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new NotBooleanExpression(this.location, this.expr.clone());
    }
    *iterateSlots(schema, prim, scope) {
        yield* this.expr.iterateSlots(schema, prim, scope);
    }
    *iterateSlots2(schema, prim, scope) {
        yield* this.expr.iterateSlots2(schema, prim, scope);
    }
}
exports.NotBooleanExpression = NotBooleanExpression;
BooleanExpression.Not = NotBooleanExpression;
BooleanExpression.Not.prototype.isNot = true;
/**
 * A boolean expression that calls a Thingpedia query function
 * and filters the result.
 *
 * The boolean expression is true if at least one result from the function
 * call satisfies the filter.
 *
 * @deprecated Use {@link ComparisonSubqueryBooleanExpression} or {@link ExistentialSubqueryBooleanExpression} instead.
 */
class ExternalBooleanExpression extends BooleanExpression {
    /**
     * Construct a new external boolean expression.
     *
     * @param {Ast.Selector.Device} selector - the selector choosing where the function is invoked
     * @param {string} channel - the function name
     * @param {Ast.InputParam[]} in_params - input parameters passed to the function
     * @param {Ast.BooleanExpression} filter - the filter to apply on the invocation's results
     * @param {Ast.FunctionDef|null} schema - type signature of the invoked function
     */
    constructor(location, selector, channel, in_params, filter, schema) {
        super(location);
        this.__effectiveSelector = null;
        (0, assert_1.default)(selector instanceof invocation_1.DeviceSelector);
        this.selector = selector;
        (0, assert_1.default)(typeof channel === 'string');
        this.channel = channel;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
        (0, assert_1.default)(filter instanceof BooleanExpression);
        this.filter = filter;
        (0, assert_1.default)(schema === null || schema instanceof function_def_1.FunctionDef);
        this.schema = schema;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        const inv = new invocation_1.Invocation(null, this.selector, this.channel, this.in_params, this.schema);
        return list_1.default.concat('any', '(', inv.toSource(), 'filter', this.filter.toSource(), ')');
    }
    toString() {
        return `External(${this.selector}, ${this.channel}, ${this.in_params}, ${this.filter})`;
    }
    toLegacy() {
        return this;
    }
    equals(other) {
        return other instanceof ExternalBooleanExpression &&
            this.selector.equals(other.selector) &&
            this.channel === other.channel &&
            (0, array_equals_1.default)(this.in_params, other.in_params) &&
            this.filter.equals(other.filter);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitExternalBooleanExpression(this)) {
            this.selector.visit(visitor);
            for (const in_param of this.in_params)
                in_param.visit(visitor);
            this.filter.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new ExternalBooleanExpression(this.location, this.selector.clone(), this.channel, this.in_params.map((p) => p.clone()), this.filter.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(schema, prim, scope) {
        yield* invocation_1.Invocation.prototype.iterateSlots.call(this, scope);
        yield* this.filter.iterateSlots(this.schema, prim, (0, slots_1.makeScope)(this));
    }
    *iterateSlots2(schema, prim, scope) {
        yield this.selector;
        yield* (0, slots_1.iterateSlots2InputParams)(this, scope);
        yield* this.filter.iterateSlots2(this.schema, this, (0, slots_1.makeScope)(this));
    }
}
exports.ExternalBooleanExpression = ExternalBooleanExpression;
BooleanExpression.External = ExternalBooleanExpression;
BooleanExpression.External.prototype.isExternal = true;
/**
 * A boolean expression that calls a Thingpedia query function
 * and filters the result.
 *
 * The boolean expression is true if at least one result from the function
 * call satisfies the filter.
 *
 */
class ExistentialSubqueryBooleanExpression extends BooleanExpression {
    /**
     * Construct a new existential subquery boolean expression.
     *
     * @param location
     * @param subquery: the query used for check existence of result
     */
    constructor(location, subquery) {
        super(location);
        this.subquery = subquery;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        return list_1.default.concat('any', '(', this.subquery.toSource(), ')');
    }
    toString() {
        return `ExistentialSubquery(${this.subquery})`;
    }
    toLegacy() {
        if (this.subquery instanceof expression_1.FilterExpression && this.subquery.expression instanceof expression_1.InvocationExpression) {
            const invocation = this.subquery.expression.invocation;
            return new ExternalBooleanExpression(null, invocation.selector, invocation.channel, invocation.in_params, this.subquery.filter.toLegacy(), this.subquery.schema);
        }
        throw new errors_1.UnserializableError('Existential Subquery');
    }
    equals(other) {
        return other instanceof ExistentialSubqueryBooleanExpression &&
            this.subquery.equals(other.subquery);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitExistentialSubqueryBooleanExpression(this))
            this.subquery.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new ExistentialSubqueryBooleanExpression(this.location, this.subquery.clone());
    }
    *iterateSlots(schema, prim, scope) {
        yield* this.subquery.iterateSlots(scope);
    }
    *iterateSlots2(schema, prim, scope) {
        yield* this.subquery.iterateSlots2(scope);
    }
}
exports.ExistentialSubqueryBooleanExpression = ExistentialSubqueryBooleanExpression;
BooleanExpression.ExistentialSubquery = ExistentialSubqueryBooleanExpression;
BooleanExpression.ExistentialSubquery.prototype.isExistentialSubquery = true;
/**
 * A boolean expression that calls a Thingpedia query function
 * and compares the result with another value.
 *
 */
class ComparisonSubqueryBooleanExpression extends BooleanExpression {
    /**
     * Construct a new comparison subquery boolean expression.
     *
     * @param location
     * @param lhs - the parameter name to compare
     * @param operator - the comparison operator
     * @param rhs - a projection subquery which returns one field
     * @param overload - type overload
     */
    constructor(location, lhs, operator, rhs, overload) {
        super(location);
        this.lhs = lhs;
        this.rhs = rhs;
        this.operator = operator;
        this.overload = overload;
    }
    get priority() {
        return INFIX_COMPARISON_OPERATORS.has(this.operator) ? syntax_priority_1.SyntaxPriority.Comp : syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        if (INFIX_COMPARISON_OPERATORS.has(this.operator))
            return list_1.default.concat((0, syntax_priority_1.addParenthesis)(syntax_priority_1.SyntaxPriority.Add, this.lhs.priority, this.lhs.toSource()), this.operator, 'any', '(', this.rhs.toSource(), ')');
        else
            return list_1.default.concat(this.operator, '(', this.lhs.toSource(), ',', 'any', '(', this.rhs.toSource(), ')', ')');
    }
    toString() {
        return `ComparisonSubquery(${this.lhs}, ${this.operator}, ${this.rhs})`;
    }
    toLegacy() {
        if (this.rhs instanceof expression_1.ProjectionExpression && this.rhs.args.length + this.rhs.computations.length === 1) {
            const expr = this.rhs.expression;
            if (expr instanceof expression_1.FilterExpression && expr.expression instanceof expression_1.InvocationExpression) {
                const invocation = expr.expression.invocation;
                const extraFilter = new ComputeBooleanExpression(null, this.lhs, this.operator, this.rhs.args.length ? new values_1.Value.VarRef(this.rhs.args[0]) : this.rhs.computations[0]);
                const filter = new AndBooleanExpression(null, [expr.filter.toLegacy(), extraFilter]);
                return new ExternalBooleanExpression(null, invocation.selector, invocation.channel, invocation.in_params, filter, invocation.schema);
            }
        }
        throw new errors_1.UnserializableError('Comparison Subquery');
    }
    equals(other) {
        return other instanceof ComparisonSubqueryBooleanExpression &&
            this.lhs.equals(other.lhs) &&
            this.operator === other.operator &&
            this.rhs.equals(other.rhs);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitComparisonSubqueryBooleanExpression(this)) {
            this.lhs.visit(visitor);
            this.rhs.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new ComparisonSubqueryBooleanExpression(this.location, this.lhs.clone(), this.operator, this.rhs.clone(), this.overload);
    }
    *iterateSlots(schema, prim, scope) {
        // XXX this API cannot support comparison subquery expressions
    }
    *iterateSlots2(schema, prim, scope) {
        const [resolvedLhs,] = this.overload || [null, null];
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, scope, resolvedLhs || this.lhs.getType(), this, 'comparison_subquery_filter', 'lhs'));
        yield* this.rhs.iterateSlots2(scope);
    }
}
exports.ComparisonSubqueryBooleanExpression = ComparisonSubqueryBooleanExpression;
BooleanExpression.ComparisonSubquery = ComparisonSubqueryBooleanExpression;
BooleanExpression.ComparisonSubquery.prototype.isComparisonSubquery = true;
/**
 * A boolean expression that expresses that the user does not care about a specific parameter.
 *
 * It is essentially the same as "true", but it has a parameter attached to it.
 */
class DontCareBooleanExpression extends BooleanExpression {
    constructor(location, name) {
        super(location);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        return list_1.default.concat('true', '(', this.name, ')');
    }
    toLegacy() {
        return this;
    }
    equals(other) {
        return other instanceof DontCareBooleanExpression && this.name === other.name;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitDontCareBooleanExpression(this);
        visitor.exit(this);
    }
    clone() {
        return new DontCareBooleanExpression(this.location, this.name);
    }
    *iterateSlots(schema, prim, scope) {
    }
    *iterateSlots2(schema, prim, scope) {
    }
}
exports.DontCareBooleanExpression = DontCareBooleanExpression;
BooleanExpression.DontCare = DontCareBooleanExpression;
DontCareBooleanExpression.prototype.isDontCare = true;
class TrueBooleanExpression extends BooleanExpression {
    constructor() {
        super(null);
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        return list_1.default.singleton('true');
    }
    toLegacy() {
        return this;
    }
    equals(other) {
        return this === other;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitTrueBooleanExpression(this);
        visitor.exit(this);
    }
    clone() {
        return this;
    }
    *iterateSlots(schema, prim, scope) {
    }
    *iterateSlots2(schema, prim, scope) {
    }
}
exports.TrueBooleanExpression = TrueBooleanExpression;
TrueBooleanExpression.prototype.isTrue = true;
BooleanExpression.True = new TrueBooleanExpression();
class FalseBooleanExpression extends BooleanExpression {
    constructor() {
        super(null);
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        return list_1.default.singleton('false');
    }
    toLegacy() {
        return this;
    }
    equals(other) {
        return this === other;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitFalseBooleanExpression(this);
        visitor.exit(this);
    }
    clone() {
        return this;
    }
    *iterateSlots(schema, prim, scope) {
    }
    *iterateSlots2(schema, prim, scope) {
    }
}
exports.FalseBooleanExpression = FalseBooleanExpression;
FalseBooleanExpression.prototype.isFalse = true;
BooleanExpression.False = new FalseBooleanExpression();
/**
 * A boolean expression that computes a scalar expression and then does a comparison
 *
 */
class ComputeBooleanExpression extends BooleanExpression {
    /**
     * Construct a new compute boolean expression.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {Ast.ScalarExpression} lhs - the scalar expression to compute
     * @param {string} operator - the comparison operator
     * @param {Ast.Value} value - the value being compared against
     */
    constructor(location, lhs, operator, rhs, overload = null) {
        super(location);
        (0, assert_1.default)(lhs instanceof values_1.Value);
        this.lhs = lhs;
        (0, assert_1.default)(typeof operator === 'string');
        this.operator = operator;
        (0, assert_1.default)(rhs instanceof values_1.Value);
        this.rhs = rhs;
        this.overload = overload;
    }
    get priority() {
        return INFIX_COMPARISON_OPERATORS.has(this.operator) ? syntax_priority_1.SyntaxPriority.Comp : syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        if (INFIX_COMPARISON_OPERATORS.has(this.operator)) {
            return list_1.default.concat(
            // force parenthesis around constants on the LHS of the filter, because it will be ambiguous otherwise
            this.lhs.isConstant() ?
                list_1.default.concat('(', this.lhs.toSource(), ')') :
                (0, syntax_priority_1.addParenthesis)(syntax_priority_1.SyntaxPriority.Add, this.lhs.priority, this.lhs.toSource()), this.operator, (0, syntax_priority_1.addParenthesis)(syntax_priority_1.SyntaxPriority.Add, this.rhs.priority, this.rhs.toSource()));
        }
        else {
            return list_1.default.concat(this.operator, '(', this.lhs.toSource(), ',', this.rhs.toSource(), ')');
        }
    }
    toLegacy() {
        return this;
    }
    equals(other) {
        return other instanceof ComputeBooleanExpression &&
            this.lhs.equals(other.lhs) &&
            this.operator === other.operator &&
            this.rhs.equals(other.rhs);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitComputeBooleanExpression(this)) {
            this.lhs.visit(visitor);
            this.rhs.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new ComputeBooleanExpression(this.location, this.lhs.clone(), this.operator, this.rhs.clone(), this.overload);
    }
    *iterateSlots(schema, prim, scope) {
        // XXX this API cannot support Compute expressions
    }
    *iterateSlots2(schema, prim, scope) {
        const [resolvedLhs, resolvedRhs] = this.overload || [null, null];
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, scope, resolvedLhs || this.lhs.getType(), this, 'compute_filter', 'lhs'));
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, scope, resolvedRhs || this.rhs.getType(), this, 'compute_filter', 'rhs'));
    }
    toString() {
        return `Compute(${this.lhs}, ${this.operator}, ${this.rhs})`;
    }
}
exports.ComputeBooleanExpression = ComputeBooleanExpression;
BooleanExpression.Compute = ComputeBooleanExpression;
BooleanExpression.Compute.prototype.isCompute = true;
class PropertyPathElement extends base_1.default {
    constructor(property, quantifier) {
        super();
        this.property = property;
        this.quantifier = quantifier;
    }
    equals(other) {
        return this.property === other.property && this.quantifier === other.quantifier;
    }
    clone() {
        return new PropertyPathElement(this.property, this.quantifier);
    }
    toSource() {
        return this.quantifier ? list_1.default.concat(this.property, this.quantifier) : list_1.default.singleton(this.property);
    }
    toString() {
        return this.quantifier ? this.property + this.quantifier : this.property;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitPropertyPathElement(this);
        visitor.exit(this);
    }
}
exports.PropertyPathElement = PropertyPathElement;
/**
 * A boolean expression with SPARQL-style property path
 * this is only meaningful for knowledge graph such as wikidata
 */
class PropertyPathBooleanExpression extends BooleanExpression {
    /**
     * Construct a new atom boolean expression.
     *
     * @param location - the position of this node in the source code
     * @param path - the property path to compare
     * @param operator - the comparison operator
     * @param value - the value being compared against
     */
    constructor(location, path, operator, value, overload) {
        super(location);
        this.path = path;
        (0, assert_1.default)(typeof operator === 'string');
        this.operator = operator;
        (0, assert_1.default)(value instanceof values_1.Value);
        this.value = value;
        this.overload = overload;
    }
    get priority() {
        return INFIX_COMPARISON_OPERATORS.has(this.operator) ? syntax_priority_1.SyntaxPriority.Comp : syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        const path = list_1.default.join(this.path.map((elem) => elem.toSource()), '/');
        if (INFIX_COMPARISON_OPERATORS.has(this.operator)) {
            return list_1.default.concat('<', path, '>', this.operator, (0, syntax_priority_1.addParenthesis)(syntax_priority_1.SyntaxPriority.Add, this.value.priority, this.value.toSource()));
        }
        else {
            return list_1.default.concat(this.operator, '(', '<', path, '>', ',', this.value.toSource(), ')');
        }
    }
    toLegacy() {
        throw new errors_1.UnserializableError('Property path boolean expression');
    }
    equals(other) {
        return other instanceof PropertyPathBooleanExpression &&
            (0, array_equals_1.default)(this.path, other.path) &&
            this.operator === other.operator &&
            this.value.equals(other.value);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitPropertyPathBooleanExpression(this))
            this.value.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new PropertyPathBooleanExpression(this.location, this.path.map((elem) => elem.clone()), this.operator, this.value.clone(), this.overload);
    }
    toString() {
        return `PropertyPath(${this.path.map((elem) => elem.toString()).join('/')}, ${this.operator}, ${this.value})`;
    }
    *iterateSlots(schema, prim, scope) {
        // TODO
    }
    *iterateSlots2(schema, prim, scope) {
        // TODO
    }
}
exports.PropertyPathBooleanExpression = PropertyPathBooleanExpression;
BooleanExpression.PropertyPath = PropertyPathBooleanExpression;
BooleanExpression.PropertyPath.prototype.ifPropertyPath = true;
//# sourceMappingURL=boolean_expression.js.map