import Type from '../type';
import Node, { SourceRange, NLAnnotationMap, AnnotationMap, AnnotationSpec } from './base';
import NodeVisitor from './visitor';
import { DeviceSelector } from './invocation';
import { Stream, Table, Action } from './legacy';
import { Expression, ChainExpression } from './expression';
import { FunctionDef } from './function_def';
import { ClassDef } from './class_def';
import { Program } from './program';
import { AbstractSlot, OldSlot } from './slots';
import SchemaRetriever from '../schema';
import { TokenStream } from '../new-syntax/tokenstream';
/**
 * The base class of all AST nodes that represent complete ThingTalk
 * statements.
 *
 */
export declare abstract class Statement extends Node {
    /**
     * Iterate all slots (scalar value nodes) in this statement.
     *
     * @deprecated This method is only appropriate for filters and input parameters.
     *   You should use {@link Ast.Statement.iterateSlots2} instead.
     */
    abstract iterateSlots(): Generator<OldSlot, void>;
    /**
     * Iterate all slots (scalar value nodes) in this statement.
     */
    abstract iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    /**
     * Clone this statement.
     */
    abstract clone(): Statement;
}
/**
 * A ThingTalk function declaration.
 *
 * A declaration statement creates a new, locally scoped, function
 * implemented as ThingTalk expression. The name can then be invoked
 * in subsequent statements.
 *
 */
export declare class FunctionDeclaration extends Statement {
    /**
     * The name of the declared function.
     */
    name: string;
    /**
     * Arguments available to the function.
     */
    args: Type.TypeMap;
    declarations: FunctionDeclaration[];
    statements: ExecutableStatement[];
    /**
     * The declaration natural language annotations (translatable annotations).
     */
    nl_annotations: NLAnnotationMap;
    /**
     * The declaration annotations.
     */
    impl_annotations: AnnotationMap;
    /**
     * The type definition corresponding to this function.
     *
     * This property is guaranteed not `null` after type-checking.
     */
    schema: FunctionDef | null;
    /**
     * Construct a new declaration statement.
     *
     * @param location - the position of this node in the source code
     * @param name - the name being bound by this statement
     * @param type - what type of function is being declared,
     *                        either `stream`, `query`, `action`, `program` or `procedure`
     * @param args - any arguments available to the function
     * @param value - the declaration body
     * @param metadata - declaration metadata (translatable annotations)
     * @param annotations - declaration annotations
     * @param schema - the type definition corresponding to this declaration
     */
    constructor(location: SourceRange | null, name: string, args: Type.TypeMap, declarations: FunctionDeclaration[], statements: ExecutableStatement[], annotations?: AnnotationSpec, schema?: FunctionDef | null);
    optimize(): this;
    toSource(): TokenStream;
    get metadata(): NLAnnotationMap;
    get annotations(): AnnotationMap;
    visit(visitor: NodeVisitor): void;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    clone(): FunctionDeclaration;
    /**
     * Convert a declaration to a program.
     *
     * This will create a program that invokes the same code as the declaration value,
     * and will replace all parameters with slots.
     *
     * @return {Ast.Program} the new program
     */
    toProgram(): Program;
}
/**
 * `let result` statements, that assign the value of a ThingTalk expression to a name.
 *
 * Assignment statements are executable statements that evaluate the ThingTalk expression
 * and assign the result to the name, which becomes available for later use in the program.
 *
 */
export declare class Assignment extends Statement {
    /**
     * The name being assigned to.
     */
    name: string;
    /**
     * The expression being assigned.
     */
    value: Expression;
    /**
     * The signature corresponding to this assignment.
     *
     * This is the type that the assigned name has after the assignment statement.
     * This property is guaranteed not `null` after type-checking.
     */
    schema: FunctionDef | null;
    /**
     * Construct a new assignment statement.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {string} name - the name being assigned to
     * @param {Ast.Table} value - the expression being assigned
     * @param {Ast.FunctionDef | null} schema - the signature corresponding to this assignment
     */
    constructor(location: SourceRange | null, name: string, value: Expression, schema?: FunctionDef | null);
    toSource(): TokenStream;
    /**
     * Whether this assignment calls an action or executes a query.
     *
     * This will be `undefined` before typechecking, and then either `true` or `false`.
     */
    get isAction(): boolean;
    visit(visitor: NodeVisitor): void;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    clone(): Assignment;
}
/**
 * @deprecated Use {@link ExpressionStatement} instead.
 */
export declare class Rule extends Statement {
    stream: Stream;
    actions: Action[];
    isRule: boolean;
    /**
     * Construct a new rule statement.
     *
     * @param location - the position of this node
     *        in the source code
     * @param stream - the stream to react to
     * @param actions - the actions to execute
     */
    constructor(location: SourceRange | null, stream: Stream, actions: Action[]);
    toSource(): TokenStream;
    toExpression(): ExpressionStatement;
    visit(visitor: NodeVisitor): void;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    clone(): Rule;
}
/**
 * @deprecated Use {@link ExpressionStatement} instead.
 */
export declare class Command extends Statement {
    table: Table | null;
    actions: Action[];
    isCommand: boolean;
    /**
     * Construct a new command statement.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {Ast.Table|null} table - the table to read from
     * @param {Ast.Action[]} actions - the actions to execute
     */
    constructor(location: SourceRange | null, table: Table | null, actions: Action[]);
    toExpression(): ExpressionStatement;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    clone(): Command;
}
/**
 * A statement that evaluates an expression and presents the results
 * to the user.
 */
export declare class ExpressionStatement extends Statement {
    expression: ChainExpression;
    constructor(location: SourceRange | null, expression: Expression);
    get first(): Expression;
    get last(): Expression;
    get stream(): Expression | null;
    get lastQuery(): Expression | null;
    toLegacy(scope_params?: string[]): Rule | Command;
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    clone(): ExpressionStatement;
    isExecutable(): boolean;
}
/**
 * A statement that explicitly sets the result of the current function.
 *
 * Only available inside a user-defined function.
 */
export declare class ReturnStatement extends Statement {
    expression: Expression;
    constructor(location: SourceRange | null, expression: Expression);
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    clone(): ReturnStatement;
    toLegacy(scope_params?: string[]): Command;
}
export declare type ExecutableStatement = Assignment | ExpressionStatement | ReturnStatement;
export declare type TopLevelStatement = ClassDef | Dataset | FunctionDeclaration | TopLevelExecutableStatement;
export declare type TopLevelExecutableStatement = Assignment | ExpressionStatement;
/**
 * A single example (primitive template) in a ThingTalk dataset
 *
 */
export declare class Example extends Node {
    isExample: boolean;
    id: number;
    type: string;
    args: Type.TypeMap;
    value: Expression;
    utterances: string[];
    preprocessed: string[];
    annotations: AnnotationMap;
    /**
     * Construct a new example.
     *
     * @param location - the position of this node in the source code
     * @param id - the ID of the example, or -1 if the example has no ID
     * @param {string} type - the type of this example, one of `stream`, `query`,
     *        `action`, or `program`
     * @param {Ast.Stream|Ast.Table|Ast.Action|Ast.Program} - the code this example
     *        maps to
     * @param {string[]} utterances - raw, unprocessed utterances for this example
     * @param {string[]} preprocessed - preprocessed (tokenized) utterances for this example
     * @param {Object.<string, any>} annotations - other annotations for this example
     */
    constructor(location: SourceRange | null, id: number, type: string, args: Type.TypeMap, value: Expression, utterances: string[], preprocessed: string[], annotations: AnnotationMap);
    toSource(): TokenStream;
    visit(visitor: NodeVisitor): void;
    clone(): Example;
    /**
     * Typecheck this example.
     *
     * This method can be used to typecheck an example is isolation,
     * outside of a ThingTalk program. This is useful to typecheck a dataset
     * and discard examples that do not typecheck without failing the whole dataset.
     *
     * @param schemas - schema retriever object to retrieve Thingpedia information
     * @param [getMeta=false] - retrieve natural language metadata during typecheck
     */
    typecheck(schemas: SchemaRetriever, getMeta?: boolean): Promise<this>;
    /**
     * Iterate all slots (scalar value nodes) in this example.
     * @deprecated Use {@link Ast.Example.iterateSlots2} instead.
     */
    iterateSlots(): Generator<OldSlot, void>;
    /**
     * Iterate all slots (scalar value nodes) in this example.
     */
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    /**
     * Convert a dataset example to a program.
     *
     * This will create a program that invokes the same code as the example value,
     * and will replace all parameters with slots.
     *
     * @return {Ast.Program} the new program
     */
    toProgram(): Program;
}
/**
 * A statement that declares a ThingTalk dataset (collection of primitive
 * templates).
 *
 */
export declare class Dataset extends Statement {
    name: string;
    examples: Example[];
    nl_annotations: NLAnnotationMap;
    impl_annotations: AnnotationMap;
    /**
     * Construct a new dataset.
     *
     * @param location - the position of this node in the source code
     * @param name - the name of this dataset
     * @param language - the language code of this dataset, as 2 letter ISO code
     * @param examples - the examples in this dataset
     * @param [annotations={}]- dataset annotations
     */
    constructor(location: SourceRange | null, name: string, examples: Example[], annotations?: AnnotationSpec);
    toSource(): TokenStream;
    get language(): string | undefined;
    visit(visitor: NodeVisitor): void;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    optimize(): Dataset;
    clone(): Dataset;
}
