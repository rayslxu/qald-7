import Type from '../type';
import AstNode from './base';
import NodeVisitor from './visitor';
import { BooleanExpression } from './boolean_expression';
import type { ArgumentDef } from './function_def';
import { TokenStream } from '../new-syntax/tokenstream';
import { SyntaxPriority } from './syntax_priority';
import { MeasureEntity, LocationEntity, TimeEntity, GenericEntity, AnyEntity } from '../entities';
import * as builtin from '../runtime/values';
export declare abstract class Location {
    static Absolute: typeof AbsoluteLocation;
    isAbsolute: boolean;
    static Relative: typeof RelativeLocation;
    isRelative: boolean;
    static Unresolved: typeof UnresolvedLocation;
    isUnresolved: boolean;
    abstract clone(): Location;
    abstract equals(x: unknown): boolean;
    abstract toEntity(): LocationEntity;
    abstract toSource(): TokenStream;
}
export declare class AbsoluteLocation extends Location {
    lat: number;
    lon: number;
    display: string | null;
    constructor(lat: number, lon: number, display?: string | null);
    get latitude(): number;
    get longitude(): number;
    toEntity(): LocationEntity;
    toSource(): TokenStream;
    toString(): string;
    clone(): AbsoluteLocation;
    equals(other: unknown): boolean;
}
export declare class RelativeLocation extends Location {
    relativeTag: string;
    constructor(relativeTag: string);
    toEntity(): LocationEntity;
    toSource(): TokenStream;
    toString(): string;
    clone(): RelativeLocation;
    equals(other: unknown): boolean;
}
export declare class UnresolvedLocation extends Location {
    name: string;
    constructor(name: string);
    toEntity(): LocationEntity;
    toSource(): TokenStream;
    toString(): string;
    clone(): UnresolvedLocation;
    equals(other: unknown): boolean;
}
export declare class DateEdge {
    isDateEdge: boolean;
    edge: ('start_of' | 'end_of');
    unit: string;
    constructor(edge: ('start_of' | 'end_of'), unit: string);
    toSource(): TokenStream;
    equals(other: unknown): boolean;
}
export declare class DatePiece {
    isDatePiece: boolean;
    year: number | null;
    month: number | null;
    day: number | null;
    time: AbsoluteTime | null;
    constructor(year: number | null, month: number | null, day: number | null, time: AbsoluteTime | null);
    toSource(): TokenStream;
    equals(other: unknown): boolean;
}
export declare type WeekDay = ('monday' | 'tuesday' | 'wednesday' | 'thursday' | 'friday' | 'saturday' | 'sunday');
export declare class WeekDayDate {
    isWeekDayDate: boolean;
    weekday: WeekDay;
    time: AbsoluteTime | null;
    constructor(weekday: string, time: AbsoluteTime | null);
    toSource(): TokenStream;
    equals(other: unknown): boolean;
}
export declare abstract class Time {
    static Absolute: typeof AbsoluteTime;
    isAbsolute: boolean;
    static Relative: typeof RelativeTime;
    isRelative: boolean;
    abstract clone(): Time;
    abstract equals(x: unknown): boolean;
    abstract toEntity(): TimeEntity;
    abstract toSource(): TokenStream;
}
interface TimeLike {
    hour: number;
    minute: number;
    second: number;
}
export declare class AbsoluteTime extends Time {
    hour: number;
    minute: number;
    second: number;
    constructor(hour: number, minute: number, second: number);
    toEntity(): TimeEntity;
    toSource(): TokenStream;
    clone(): AbsoluteTime;
    equals(other: unknown): boolean;
    static fromJS(v: string | TimeLike): AbsoluteTime;
    toJS(): builtin.Time;
}
export declare class RelativeTime extends Time {
    relativeTag: string;
    constructor(relativeTag: string);
    toEntity(): TimeEntity;
    toSource(): TokenStream;
    clone(): RelativeTime;
    equals(other: unknown): boolean;
}
/**
 * An AST node that represents a scalar value.
 *
 * This could be a constant, a slot-filling placeholder, the name of a variable in scope,
 * a compound type expression (array or object literal) or a computation expression.
 *
 * Note that AST node representations are different from runtime representations
 * (in {@link Builtin}. AST nodes carry type information, can carry
 * additional information that might not be available at runtime, and can represent
 * unspecified or unresolved values. Code using the library to manipulate programs statically
 * will make use of this class, while code using the library to implement or call Thingpedia
 * functions will make use of the runtime representations.
 *
 */
export declare abstract class Value extends AstNode {
    static Boolean: typeof BooleanValue;
    isBoolean: boolean;
    static String: typeof StringValue;
    isString: boolean;
    static Number: typeof NumberValue;
    isNumber: boolean;
    static Currency: typeof CurrencyValue;
    isCurrency: boolean;
    static Entity: typeof EntityValue;
    isEntity: boolean;
    static Measure: typeof MeasureValue;
    isMeasure: boolean;
    static Enum: typeof EnumValue;
    isEnum: boolean;
    static Time: typeof TimeValue;
    isTime: boolean;
    static Date: typeof DateValue;
    isDate: boolean;
    static Location: typeof LocationValue;
    isLocation: boolean;
    static RecurrentTimeSpecification: typeof RecurrentTimeSpecificationValue;
    isRecurrentTimeSpecification: boolean;
    static ArgMap: typeof ArgMapValue;
    isArgMap: boolean;
    static Array: typeof ArrayValue;
    isArray: boolean;
    static Object: typeof ObjectValue;
    isObject: boolean;
    static VarRef: typeof VarRefValue;
    isVarRef: boolean;
    static Event: typeof EventValue;
    isEvent: boolean;
    static ContextRef: typeof ContextRefValue;
    isContextRef: boolean;
    static Undefined: typeof UndefinedValue;
    isUndefined: boolean;
    static Filter: typeof FilterValue;
    isFilter: boolean;
    static ArrayField: typeof ArrayFieldValue;
    isArrayField: boolean;
    static Computation: typeof ComputationValue;
    isComputation: boolean;
    get priority(): SyntaxPriority;
    abstract clone(): Value;
    /**
     * Check if two Value nodes represent the same ThingTalk value.
     *
     * It is an error to call this method with a parameter that is not an Ast.Value
     *
     * @param other - the other value to compare
     * @return true if equal, false otherwise
     */
    abstract equals(other: Value): boolean;
    /**
     * Convert a normalized JS value to the corresponding AST node.
     *
     * This is the inverse operation of {@link Ast.Value.toJS}.
     *
     * @param type - the ThingTalk type
     * @param v - the JS value to convert
     * @return the converted value
     */
    static fromJS(type: Type, v: unknown): Value;
    /**
     * Convert a normalized JSON value to the corresponding AST node.
     *
     * This is similar to {@link Ast.Value.fromJS} but handles JSON
     * serialization of Date values.
     *
     * @param type - the ThingTalk type
     * @param v - the JSON value to convert
     * @return the converted value
     */
    static fromJSON(type: Type, v: unknown): Value;
    /**
     * Retrieve the ThingTalk type of this value.
     *
     * @return the type
     */
    abstract getType(): Type;
    /**
     * Check if this AST node represent concrete (compilable) value.
     *
     * Values that are not concrete require normalization by the dialog agent
     * (such as entity or location resolution) before a program using them
     * is compiled and executed.
     *
     * @return {boolean} whether the value is concrete
     */
    isConcrete(): boolean;
    /**
     * Check if this AST node represent a compile-time constant value.
     *
     * Certain expressions in ThingTalk must be constant.
     *
     * @return {boolean} whether the value is constant
     */
    isConstant(): boolean;
    /**
     * Normalize this AST value and convert it to JS-friendly representation.
     *
     * This converts the AST representation to something that can be passed to
     * a Thingpedia function. Note that the conversion is lossy and loses type
     * information.
     *
     * @return {any} the normlized value
     */
    toJS(): unknown;
    /**
     * Convert this AST node to an entity that can be extracted from a sentence.
     */
    toEntity(): AnyEntity;
}
export declare class ArrayValue extends Value {
    value: Value[];
    type: Type | null;
    constructor(value: Value[], type?: Type | null);
    toSource(): TokenStream;
    toString(): string;
    clone(): ArrayValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    toJS(): unknown[];
    getType(): Type;
}
export declare class VarRefValue extends Value {
    name: string;
    type: Type | null;
    constructor(name: string, type?: Type | null);
    toSource(): TokenStream;
    toString(): string;
    clone(): VarRefValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    getType(): Type;
}
export declare class ComputationValue extends Value {
    op: string;
    operands: Value[];
    overload: Type[] | null;
    type: Type | null;
    constructor(op: string, operands: Value[], overload?: Type[] | null, type?: Type | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toString(): string;
    clone(): ComputationValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    getType(): Type;
}
export declare class ArrayFieldValue extends Value {
    value: Value;
    field: string;
    type: Type | null;
    arg: ArgumentDef | null;
    constructor(value: Value, field: string, type?: Type | null, arg?: ArgumentDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toString(): string;
    clone(): ArrayFieldValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    toJS(): unknown[];
    getType(): Type;
}
export declare class FilterValue extends Value {
    value: Value;
    filter: BooleanExpression;
    type: Type | null;
    constructor(value: Value, filter: BooleanExpression, type?: Type | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toString(): string;
    clone(): FilterValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    getType(): Type;
}
/**
 * A special placeholder for values that must be slot-filled.
 */
export declare class UndefinedValue extends Value {
    local: boolean;
    constructor(local?: boolean);
    toSource(): TokenStream;
    toString(): string;
    clone(): UndefinedValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    getType(): Type;
}
export declare class ContextRefValue extends Value {
    name: string;
    type: Type;
    constructor(name: string, type: Type);
    toSource(): TokenStream;
    toString(): string;
    clone(): ContextRefValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    isConcrete(): boolean;
    getType(): Type;
}
export declare class BooleanValue extends Value {
    value: boolean;
    constructor(value: boolean);
    toSource(): TokenStream;
    toString(): string;
    clone(): BooleanValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    toJS(): boolean;
    getType(): Type;
}
export declare class StringValue extends Value {
    value: string;
    constructor(value: string);
    toEntity(): string;
    toSource(): TokenStream;
    toString(): string;
    clone(): StringValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    toJS(): string;
    getType(): Type;
}
export declare class NumberValue extends Value {
    value: number;
    constructor(value: number);
    toEntity(): number;
    toSource(): TokenStream;
    toString(): string;
    clone(): NumberValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    toJS(): number;
    getType(): Type;
}
export declare class MeasureValue extends Value {
    value: number;
    unit: string;
    constructor(value: number, unit: string);
    toEntity(): MeasureEntity;
    toSource(): TokenStream;
    toString(): string;
    clone(): MeasureValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConcrete(): boolean;
    toJS(): number;
    getType(): Type;
}
export declare class CurrencyValue extends Value {
    value: number;
    code: string;
    constructor(value: number, code: string);
    toEntity(): MeasureEntity;
    toSource(): TokenStream;
    toString(): string;
    clone(): CurrencyValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    toJS(): builtin.Currency;
    getType(): Type;
}
export declare class LocationValue extends Value {
    value: Location;
    constructor(value: Location);
    toEntity(): LocationEntity;
    toSource(): TokenStream;
    toString(): string;
    clone(): LocationValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    isConcrete(): boolean;
    toJS(): builtin.Location;
    getType(): Type;
}
declare type DateLike = Date | DateEdge | DatePiece | WeekDayDate;
export declare class DateValue extends Value {
    value: DateLike | null;
    constructor(value: DateLike | null);
    static now(): DateValue;
    toEntity(): Date;
    toSource(): TokenStream;
    toString(): string;
    clone(): DateValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    normalize(timezone: string): DateValue;
    toJS(): Date;
    getType(): Type;
}
export declare class TimeValue extends Value {
    value: Time;
    constructor(value: Time);
    toEntity(): TimeEntity;
    toSource(): TokenStream;
    toString(): string;
    clone(): TimeValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    isConcrete(): boolean;
    toJS(): builtin.Time;
    getType(): Type;
}
interface RecurrentTimeRuleLike {
    beginTime: AbsoluteTime;
    endTime: AbsoluteTime;
    interval: MeasureValue;
    frequency: number;
    dayOfWeek: string | null;
    beginDate: DateLike | null;
    endDate: DateLike | null;
    subtract: boolean;
}
/**
 * An AST node representing a single rule for a recurrent event.
 *
 */
export declare class RecurrentTimeRule extends AstNode {
    beginTime: AbsoluteTime;
    endTime: AbsoluteTime;
    interval: MeasureValue;
    frequency: number;
    dayOfWeek: string | null;
    beginDate: DateLike | null;
    endDate: DateLike | null;
    subtract: boolean;
    constructor({ beginTime, endTime, interval, frequency, dayOfWeek, beginDate, endDate, subtract }: RecurrentTimeRuleLike);
    toSource(): TokenStream;
    toString(): string;
    clone(): RecurrentTimeRule;
    equals(other: RecurrentTimeRule): boolean;
    visit(visitor: NodeVisitor): void;
    static fromJS(v: builtin.RecurrentTimeRuleLike): RecurrentTimeRule;
    normalize(timezone: string): RecurrentTimeRule;
    toJS(): builtin.RecurrentTimeRule;
}
export declare class RecurrentTimeSpecificationValue extends Value {
    rules: RecurrentTimeRule[];
    constructor(rules: RecurrentTimeRule[]);
    toSource(): TokenStream;
    toString(): string;
    clone(): RecurrentTimeSpecificationValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    normalize(timezone: string): RecurrentTimeSpecificationValue;
    toJS(): builtin.RecurrentTimeRule[];
    getType(): Type;
}
export declare class EntityValue extends Value {
    value: string | null;
    type: string;
    display: string | null;
    constructor(value: string | null, type: string, display?: string | null);
    toEntity(): GenericEntity | string;
    toSource(): TokenStream;
    toString(): string;
    clone(): EntityValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConcrete(): boolean;
    toJS(): builtin.Entity;
    getType(): Type;
}
export declare class EnumValue extends Value {
    value: string;
    constructor(value: string);
    toSource(): TokenStream;
    toString(): string;
    clone(): EnumValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    toJS(): string;
    getType(): Type;
}
export declare class EventValue extends Value {
    name: string | null;
    constructor(name: string | null);
    toSource(): TokenStream;
    toString(): string;
    clone(): EventValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    getType(): Type;
}
export declare class ArgMapValue extends Value {
    value: Type.TypeMap;
    constructor(value: Type.TypeMap);
    toSource(): TokenStream;
    toString(): string;
    clone(): ArgMapValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    toJS(): Type.TypeMap;
    getType(): Type;
}
export declare class ObjectValue extends Value {
    value: ({
        [key: string]: Value;
    });
    type: Type | null;
    constructor(value: ({
        [key: string]: Value;
    }), type?: Type | null);
    toSource(): TokenStream;
    toString(): string;
    clone(): ObjectValue;
    equals(other: Value): boolean;
    visit(visitor: NodeVisitor): void;
    isConstant(): boolean;
    toJS(): ({
        [key: string]: unknown;
    });
    getType(): Type;
}
export {};
