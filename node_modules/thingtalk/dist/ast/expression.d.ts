import Node, { SourceRange } from './base';
import { FunctionDef } from './function_def';
import { Invocation, DeviceSelector, InputParam } from './invocation';
import { BooleanExpression, PropertyPathSequence } from './boolean_expression';
import * as legacy from './legacy';
import { Value } from './values';
import { AbstractSlot, OldSlot, ScopeMap, InvocationLike } from './slots';
import Type from '../type';
import NodeVisitor from './visitor';
import { TokenStream } from '../new-syntax/tokenstream';
import { SyntaxPriority } from './syntax_priority';
/**
 * A stream, table, or action expression.
 */
export declare abstract class Expression extends Node {
    schema: FunctionDef | null;
    constructor(location: SourceRange | null, schema: FunctionDef | null);
    abstract get priority(): SyntaxPriority;
    abstract toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.Stream | legacy.Table | legacy.Action;
    abstract clone(): Expression;
    abstract toSource(): TokenStream;
    abstract equals(other: Expression): boolean;
    optimize(): Expression;
    /**
     * Iterate all slots (scalar value nodes) in this expression.
     *
     * @param scope - available names for parameter passing
     * @deprecated Use {@link Ast.Table.iterateSlots2} instead.
     */
    abstract iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    /**
     * Iterate all slots (scalar value nodes) in this expression.
     *
     * @param scope - available names for parameter passing
     */
    abstract iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class FunctionCallExpression extends Expression {
    name: string;
    in_params: InputParam[];
    constructor(location: SourceRange | null, name: string, in_params: InputParam[], schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toString(): string;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.VarRefTable | legacy.VarRefStream | legacy.TimerStream | legacy.AtTimerStream | legacy.VarRefAction;
    visit(visitor: NodeVisitor): void;
    clone(): FunctionCallExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class InvocationExpression extends Expression {
    invocation: Invocation;
    constructor(location: SourceRange | null, invocation: Invocation, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.InvocationTable | legacy.InvocationAction;
    visit(visitor: NodeVisitor): void;
    clone(): InvocationExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class FilterExpression extends Expression {
    expression: Expression;
    filter: BooleanExpression;
    constructor(location: SourceRange | null, expression: Expression, filter: BooleanExpression, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.FilteredTable | legacy.EdgeFilterStream;
    visit(visitor: NodeVisitor): void;
    clone(): FilterExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class MonitorExpression extends Expression {
    expression: Expression;
    args: string[] | null;
    constructor(location: SourceRange | null, expression: Expression, args: string[] | null, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.MonitorStream;
    visit(visitor: NodeVisitor): void;
    clone(): MonitorExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class BooleanQuestionExpression extends Expression {
    expression: Expression;
    booleanExpression: BooleanExpression;
    constructor(location: SourceRange | null, expression: Expression, booleanExpression: BooleanExpression, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    visit(visitor: NodeVisitor): void;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.Table | legacy.Stream;
    clone(): BooleanQuestionExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class ProjectionExpression extends Expression {
    expression: Expression;
    args: string[];
    computations: Value[];
    aliases: Array<string | null>;
    constructor(location: SourceRange | null, expression: Expression, args: string[], computations: Value[], aliases: Array<string | null>, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.Table | legacy.Stream;
    visit(visitor: NodeVisitor): void;
    clone(): ProjectionExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class ProjectionElement extends Node {
    value: string | Value | PropertyPathSequence;
    alias: string | null;
    types: Type[];
    constructor(value: string | Value | PropertyPathSequence, alias: string | null, types: Type[]);
    clone(): ProjectionElement;
    toSource(): TokenStream;
    equals(other: ProjectionElement): boolean;
    visit(visitor: NodeVisitor): void;
}
export declare class ProjectionExpression2 extends Expression {
    expression: Expression;
    projections: ProjectionElement[];
    constructor(location: SourceRange | null, expression: Expression, projections: ProjectionElement[], schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.Table | legacy.Stream;
    visit(visitor: NodeVisitor): void;
    clone(): ProjectionExpression2;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class AliasExpression extends Expression {
    expression: Expression;
    name: string;
    constructor(location: SourceRange | null, expression: Expression, name: string, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.AliasTable | legacy.AliasStream;
    visit(visitor: NodeVisitor): void;
    clone(): AliasExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class AggregationExpression extends Expression {
    expression: Expression;
    field: string;
    operator: string;
    overload: Type[] | null;
    groupBy: string | null;
    alias: null;
    constructor(location: SourceRange | null, expression: Expression, field: string, operator: string, schema: FunctionDef | null, overload?: Type[] | null, groupBy?: string | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.AggregationTable;
    visit(visitor: NodeVisitor): void;
    clone(): AggregationExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class SortExpression extends Expression {
    expression: Expression;
    value: Value;
    direction: 'asc' | 'desc';
    constructor(location: SourceRange | null, expression: Expression, value: Value, direction: 'asc' | 'desc', schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.SortedTable;
    visit(visitor: NodeVisitor): void;
    clone(): SortExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class IndexExpression extends Expression {
    expression: Expression;
    indices: Value[];
    constructor(location: SourceRange | null, expression: Expression, indices: Value[], schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.IndexTable;
    visit(visitor: NodeVisitor): void;
    clone(): IndexExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class SliceExpression extends Expression {
    expression: Expression;
    base: Value;
    limit: Value;
    constructor(location: SourceRange | null, expression: Expression, base: Value, limit: Value, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.SlicedTable;
    visit(visitor: NodeVisitor): void;
    clone(): SliceExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
/**
 * Evaluates a list of expressions, passing the result of the previous one
 * to the next.
 *
 * In syntax, the expressions are separated by "=>"
 */
export declare class ChainExpression extends Expression {
    expressions: Expression[];
    constructor(location: SourceRange | null, expressions: Expression[], schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    get first(): Expression;
    set first(expr: Expression);
    get last(): Expression;
    set last(expr: Expression);
    get lastQuery(): Expression | null;
    setLastQuery(expr: Expression): void;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.Stream | legacy.Table | legacy.Action;
    visit(visitor: NodeVisitor): void;
    clone(): ChainExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
export declare class JoinExpression extends Expression {
    lhs: Expression;
    rhs: Expression;
    constructor(location: SourceRange | null, left: Expression, right: Expression, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    equals(other: Expression): boolean;
    toLegacy(into_params?: InputParam[], scope_params?: string[]): legacy.Table;
    visit(visitor: NodeVisitor): void;
    clone(): JoinExpression;
    iterateSlots(scope: ScopeMap): Generator<OldSlot, [InvocationLike | null, ScopeMap]>;
    iterateSlots2(scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, [InvocationLike | null, ScopeMap]>;
}
