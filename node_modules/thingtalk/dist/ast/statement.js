"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2021 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//         Silei Xu <silei@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dataset = exports.Example = exports.ReturnStatement = exports.ExpressionStatement = exports.Command = exports.Rule = exports.Assignment = exports.FunctionDeclaration = exports.Statement = void 0;
const assert_1 = __importDefault(require("assert"));
const base_1 = __importStar(require("./base"));
const visitor_1 = __importDefault(require("./visitor"));
const values_1 = require("./values");
const legacy_1 = require("./legacy");
const expression_1 = require("./expression");
const function_def_1 = require("./function_def");
const program_1 = require("./program");
const typecheck_1 = __importDefault(require("../typecheck"));
const Optimizer = __importStar(require("../optimize"));
const list_1 = __importDefault(require("../utils/list"));
/**
 * The base class of all AST nodes that represent complete ThingTalk
 * statements.
 *
 */
class Statement extends base_1.default {
}
exports.Statement = Statement;
function declarationLikeToProgram(self) {
    const nametoslot = {};
    let i = 0;
    for (const name in self.args)
        nametoslot[name] = i++;
    let declarations, statements;
    if (self instanceof Example) {
        declarations = [];
        statements = [new ExpressionStatement(null, self.value.clone())];
    }
    else {
        declarations = self.declarations.map((d) => d.clone());
        statements = self.statements.map((s) => {
            if (s instanceof ReturnStatement)
                return new ExpressionStatement(s.location, s.expression.clone());
            else
                return s.clone();
        });
    }
    const program = new program_1.Program(null, [], declarations, statements);
    program.visit(new class extends visitor_1.default {
        visitVarRefValue(value) {
            if (value.name in nametoslot)
                value.name = '__const_SLOT_' + nametoslot[value.name];
            return true;
        }
    });
    return program;
}
/**
 * A ThingTalk function declaration.
 *
 * A declaration statement creates a new, locally scoped, function
 * implemented as ThingTalk expression. The name can then be invoked
 * in subsequent statements.
 *
 */
class FunctionDeclaration extends Statement {
    /**
     * Construct a new declaration statement.
     *
     * @param location - the position of this node in the source code
     * @param name - the name being bound by this statement
     * @param type - what type of function is being declared,
     *                        either `stream`, `query`, `action`, `program` or `procedure`
     * @param args - any arguments available to the function
     * @param value - the declaration body
     * @param metadata - declaration metadata (translatable annotations)
     * @param annotations - declaration annotations
     * @param schema - the type definition corresponding to this declaration
     */
    constructor(location, name, args, declarations, statements, annotations = {}, schema = null) {
        super(location);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(typeof args === 'object');
        this.args = args;
        this.declarations = declarations;
        this.statements = statements;
        this.nl_annotations = annotations.nl || {};
        this.impl_annotations = annotations.impl || {};
        this.schema = schema;
    }
    optimize() {
        return Optimizer.optimizeProgram(this);
    }
    toSource() {
        let list = list_1.default.concat('function', this.name, '(', '\t=+');
        let first = true;
        for (const argname in this.args) {
            const argtype = this.args[argname];
            if (first)
                first = false;
            else
                list = list_1.default.concat(list, ',', '\n');
            list = list_1.default.concat(list, argname, ':', argtype.toSource());
        }
        list = list_1.default.concat(list, ')', '\t=-', ' ', '{', '\t+', '\n');
        for (const stmt of this.declarations)
            list = list_1.default.concat(list, stmt.toSource(), '\n');
        for (const stmt of this.statements)
            list = list_1.default.concat(list, stmt.toSource(), '\n');
        list = list_1.default.concat(list, '\t-', '}');
        return list;
    }
    get metadata() {
        return this.nl_annotations;
    }
    get annotations() {
        return this.impl_annotations;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitFunctionDeclaration(this)) {
            for (const decl of this.declarations)
                decl.visit(visitor);
            for (const stmt of this.statements)
                stmt.visit(visitor);
        }
        visitor.exit(this);
    }
    *iterateSlots() {
        // the declaration refers to a nested scope, we don't need to
        // slot fill it now
    }
    *iterateSlots2() {
        // the declaration refers to a nested scope, we don't need to
        // slot fill it now
    }
    clone() {
        const newArgs = {};
        Object.assign(newArgs, this.args);
        const newMetadata = {};
        Object.assign(newMetadata, this.nl_annotations);
        const newAnnotations = {};
        Object.assign(newAnnotations, this.impl_annotations);
        return new FunctionDeclaration(this.location, this.name, newArgs, this.declarations.map((d) => d.clone()), this.statements.map((s) => s.clone()), { nl: newMetadata, impl: newAnnotations }, this.schema);
    }
    /**
     * Convert a declaration to a program.
     *
     * This will create a program that invokes the same code as the declaration value,
     * and will replace all parameters with slots.
     *
     * @return {Ast.Program} the new program
     */
    toProgram() {
        return declarationLikeToProgram(this);
    }
}
exports.FunctionDeclaration = FunctionDeclaration;
/**
 * `let result` statements, that assign the value of a ThingTalk expression to a name.
 *
 * Assignment statements are executable statements that evaluate the ThingTalk expression
 * and assign the result to the name, which becomes available for later use in the program.
 *
 */
class Assignment extends Statement {
    /**
     * Construct a new assignment statement.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {string} name - the name being assigned to
     * @param {Ast.Table} value - the expression being assigned
     * @param {Ast.FunctionDef | null} schema - the signature corresponding to this assignment
     */
    constructor(location, name, value, schema = null) {
        super(location);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(value instanceof expression_1.Expression);
        this.value = value;
        this.schema = schema;
    }
    toSource() {
        return list_1.default.concat('let', this.name, ' ', '=', ' ', this.value.toSource(), ';');
    }
    /**
     * Whether this assignment calls an action or executes a query.
     *
     * This will be `undefined` before typechecking, and then either `true` or `false`.
     */
    get isAction() {
        return this.schema.functionType === 'action';
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAssignment(this))
            this.value.visit(visitor);
        visitor.exit(this);
    }
    *iterateSlots() {
        yield* this.value.iterateSlots({});
    }
    *iterateSlots2() {
        yield* this.value.iterateSlots2({});
    }
    clone() {
        return new Assignment(this.location, this.name, this.value.clone(), this.schema);
    }
}
exports.Assignment = Assignment;
/**
 * @deprecated Use {@link ExpressionStatement} instead.
 */
class Rule extends Statement {
    /**
     * Construct a new rule statement.
     *
     * @param location - the position of this node
     *        in the source code
     * @param stream - the stream to react to
     * @param actions - the actions to execute
     */
    constructor(location, stream, actions) {
        super(location);
        this.isRule = true;
        (0, assert_1.default)(stream instanceof legacy_1.Stream);
        this.stream = stream;
        (0, assert_1.default)(Array.isArray(actions));
        this.actions = actions;
    }
    toSource() {
        (0, assert_1.default)(this.actions.length === 1);
        return list_1.default.concat(this.stream.toSource(), '=>', this.actions[0].toSource(), ';');
    }
    toExpression() {
        const exprs = [this.stream.toExpression()].concat(this.actions.filter((a) => !a.isNotify).map((a) => a.toExpression()));
        return new ExpressionStatement(this.location, new expression_1.ChainExpression(this.location, exprs, null));
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitRule(this)) {
            this.stream.visit(visitor);
            for (const action of this.actions)
                action.visit(visitor);
        }
        visitor.exit(this);
    }
    *iterateSlots() {
        const [, scope] = yield* this.stream.iterateSlots({});
        for (const action of this.actions)
            yield* action.iterateSlots(scope);
    }
    *iterateSlots2() {
        const [, scope] = yield* this.stream.iterateSlots2({});
        for (const action of this.actions)
            yield* action.iterateSlots2(scope);
    }
    clone() {
        return new Rule(this.location, this.stream.clone(), this.actions.map((a) => a.clone()));
    }
}
exports.Rule = Rule;
/**
 * @deprecated Use {@link ExpressionStatement} instead.
 */
class Command extends Statement {
    /**
     * Construct a new command statement.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {Ast.Table|null} table - the table to read from
     * @param {Ast.Action[]} actions - the actions to execute
     */
    constructor(location, table, actions) {
        super(location);
        this.isCommand = true;
        (0, assert_1.default)(table === null || table instanceof legacy_1.Table);
        this.table = table;
        (0, assert_1.default)(Array.isArray(actions));
        this.actions = actions;
    }
    toExpression() {
        const exprs = [];
        if (this.table)
            exprs.push(this.table.toExpression([]));
        exprs.push(...this.actions.filter((a) => !a.isNotify).map((a) => a.toExpression()));
        return new ExpressionStatement(this.location, new expression_1.ChainExpression(this.location, exprs, null));
    }
    toSource() {
        (0, assert_1.default)(this.actions.length === 1);
        if (this.table)
            return list_1.default.concat(this.table.toSource(), '=>', this.actions[0].toSource(), ';');
        else
            return list_1.default.concat(this.actions[0].toSource(), ';');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitCommand(this)) {
            if (this.table !== null)
                this.table.visit(visitor);
            for (const action of this.actions)
                action.visit(visitor);
        }
        visitor.exit(this);
    }
    *iterateSlots() {
        let scope = {};
        if (this.table)
            [, scope] = yield* this.table.iterateSlots({});
        for (const action of this.actions)
            yield* action.iterateSlots(scope);
    }
    *iterateSlots2() {
        let scope = {};
        if (this.table)
            [, scope] = yield* this.table.iterateSlots2({});
        for (const action of this.actions)
            yield* action.iterateSlots2(scope);
    }
    clone() {
        return new Command(this.location, this.table !== null ? this.table.clone() : null, this.actions.map((a) => a.clone()));
    }
}
exports.Command = Command;
class IsExecutableVisitor extends visitor_1.default {
    constructor() {
        super(...arguments);
        this.isExecutable = true;
    }
    visitInvocation(invocation) {
        const schema = invocation.schema;
        (0, assert_1.default)(schema instanceof function_def_1.FunctionDef);
        const params = new Map();
        for (const in_param of invocation.in_params)
            params.set(in_param.name, in_param.value);
        const requireEither = schema.getImplementationAnnotation('require_either');
        if (requireEither) {
            for (const requirement of requireEither) {
                let satisfied = false;
                for (const option of requirement) {
                    if (params.has(option)) {
                        satisfied = true;
                        break;
                    }
                }
                if (!satisfied)
                    this.isExecutable = false;
            }
        }
        for (const arg of schema.iterateArguments()) {
            const requiredIf = arg.getImplementationAnnotation('required_if');
            if (requiredIf && !params.has(arg.name)) {
                let required = false;
                for (const requirement of requiredIf) {
                    const [param, value] = requirement.split('=');
                    const current = params.get(param);
                    if (!current)
                        continue;
                    if ((current instanceof values_1.EnumValue && current.value === value) ||
                        (current instanceof values_1.BooleanValue && current.value === (value === 'true'))) {
                        required = true;
                        break;
                    }
                }
                if (required)
                    this.isExecutable = false;
            }
        }
        return true;
    }
    visitValue(value) {
        if (value.isUndefined || !value.isConcrete())
            this.isExecutable = false;
        return true;
    }
}
/**
 * A statement that evaluates an expression and presents the results
 * to the user.
 */
class ExpressionStatement extends Statement {
    constructor(location, expression) {
        super(location);
        if (!(expression instanceof expression_1.ChainExpression))
            this.expression = new expression_1.ChainExpression(location, [expression], expression.schema);
        else
            this.expression = expression;
        (0, assert_1.default)(this.expression.expressions.length > 0);
    }
    get first() {
        return this.expression.first;
    }
    get last() {
        return this.expression.last;
    }
    get stream() {
        const first = this.first;
        if (first.schema.functionType === 'stream')
            return first;
        else
            return null;
    }
    get lastQuery() {
        return this.expression.lastQuery;
    }
    toLegacy(scope_params = []) {
        const last = this.last;
        const action = last.schema.functionType === 'action' ? last : null;
        let head = null;
        if (action) {
            const remaining = this.expression.expressions.slice(0, this.expression.expressions.length - 1);
            if (remaining.length > 0) {
                const converted = new expression_1.ChainExpression(null, remaining, null).toLegacy([], scope_params);
                (0, assert_1.default)(converted instanceof legacy_1.Stream || converted instanceof legacy_1.Table);
                head = converted;
            }
        }
        else {
            const converted = this.expression.toLegacy([], scope_params);
            (0, assert_1.default)(converted instanceof legacy_1.Stream || converted instanceof legacy_1.Table);
            head = converted;
        }
        const actionIntoParams = [];
        const convertedAction = action ? action.toLegacy(actionIntoParams, scope_params) : null;
        (0, assert_1.default)(convertedAction === null || convertedAction instanceof legacy_1.Action);
        if (convertedAction && convertedAction instanceof legacy_1.VarRefAction)
            convertedAction.in_params.push(...actionIntoParams);
        if (head instanceof legacy_1.Stream)
            return new Rule(this.location, head, convertedAction ? [convertedAction] : [legacy_1.Action.notifyAction()]);
        else
            return new Command(this.location, head, convertedAction ? [convertedAction] : [legacy_1.Action.notifyAction()]);
    }
    toSource() {
        return list_1.default.concat(this.expression.toSource(), ';');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitExpressionStatement(this))
            this.expression.visit(visitor);
        visitor.exit(this);
    }
    *iterateSlots() {
        yield* this.expression.iterateSlots({});
    }
    *iterateSlots2() {
        yield* this.expression.iterateSlots2({});
    }
    clone() {
        return new ExpressionStatement(this.location, this.expression.clone());
    }
    isExecutable() {
        const visitor = new IsExecutableVisitor;
        this.visit(visitor);
        return visitor.isExecutable;
    }
}
exports.ExpressionStatement = ExpressionStatement;
/**
 * A statement that explicitly sets the result of the current function.
 *
 * Only available inside a user-defined function.
 */
class ReturnStatement extends Statement {
    constructor(location, expression) {
        super(location);
        this.expression = expression;
    }
    toSource() {
        return list_1.default.concat('return', this.expression.toSource(), ';');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitReturnStatement(this))
            this.expression.visit(visitor);
        visitor.exit(this);
    }
    *iterateSlots() {
        yield* this.expression.iterateSlots({});
    }
    *iterateSlots2() {
        yield* this.expression.iterateSlots2({});
    }
    clone() {
        return new ReturnStatement(this.location, this.expression.clone());
    }
    toLegacy(scope_params = []) {
        const chain = this.expression instanceof expression_1.ChainExpression ? this.expression : new expression_1.ChainExpression(null, [this.expression], this.expression.schema);
        const last = chain.last;
        const action = last.schema.functionType === 'action' ? last : null;
        let head = null;
        if (action) {
            const remaining = chain.expressions.slice(0, chain.expressions.length - 1);
            if (remaining.length > 0) {
                const converted = new expression_1.ChainExpression(null, remaining, null).toLegacy([], scope_params);
                (0, assert_1.default)(converted instanceof legacy_1.Table);
                head = converted;
            }
        }
        else {
            const converted = chain.toLegacy([], scope_params);
            (0, assert_1.default)(converted instanceof legacy_1.Table);
            head = converted;
        }
        const convertedAction = action ? action.toLegacy([], scope_params) : null;
        (0, assert_1.default)(convertedAction === null || convertedAction instanceof legacy_1.Action);
        return new Command(this.location, head, convertedAction ? [convertedAction] : [legacy_1.Action.notifyAction()]);
    }
}
exports.ReturnStatement = ReturnStatement;
/**
 * A single example (primitive template) in a ThingTalk dataset
 *
 */
class Example extends base_1.default {
    /**
     * Construct a new example.
     *
     * @param location - the position of this node in the source code
     * @param id - the ID of the example, or -1 if the example has no ID
     * @param {string} type - the type of this example, one of `stream`, `query`,
     *        `action`, or `program`
     * @param {Ast.Stream|Ast.Table|Ast.Action|Ast.Program} - the code this example
     *        maps to
     * @param {string[]} utterances - raw, unprocessed utterances for this example
     * @param {string[]} preprocessed - preprocessed (tokenized) utterances for this example
     * @param {Object.<string, any>} annotations - other annotations for this example
     */
    constructor(location, id, type, args, value, utterances, preprocessed, annotations) {
        super(location);
        this.isExample = true;
        (0, assert_1.default)(typeof id === 'number');
        this.id = id;
        this.type = type;
        (0, assert_1.default)(typeof args === 'object');
        this.args = args;
        (0, assert_1.default)(value instanceof expression_1.Expression);
        this.value = value;
        (0, assert_1.default)(Array.isArray(utterances) && Array.isArray(preprocessed));
        this.utterances = utterances;
        this.preprocessed = preprocessed;
        (0, assert_1.default)(typeof annotations === 'object');
        this.annotations = annotations;
    }
    toSource() {
        const annotations = {};
        if (this.id >= 0)
            annotations.id = new values_1.Value.Number(this.id);
        Object.assign(annotations, this.annotations);
        const metadata = {};
        if (this.utterances.length > 0)
            metadata.utterances = this.utterances;
        if (this.preprocessed.length > 0)
            metadata.preprocessed = this.preprocessed;
        let args = list_1.default.Nil;
        let first = true;
        for (const argname in this.args) {
            const argtype = this.args[argname];
            if (first)
                first = false;
            else
                args = list_1.default.concat(args, ',');
            args = list_1.default.concat(args, argname, ':', argtype.toSource());
        }
        let list = list_1.default.singleton(this.type);
        if (args !== list_1.default.Nil)
            list = list_1.default.concat(list, ' ', '(', args, ')');
        list = list_1.default.concat(list, ' ', '=', ' ', this.value.toSource(), (0, base_1.nlAnnotationsToSource)(metadata), (0, base_1.implAnnotationsToSource)(annotations), ';');
        return list;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitExample(this))
            this.value.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new Example(this.location, this.id, this.type, Object.assign({}, this.args), this.value.clone(), this.utterances.slice(0), this.preprocessed.slice(0), Object.assign({}, this.annotations));
    }
    /**
     * Typecheck this example.
     *
     * This method can be used to typecheck an example is isolation,
     * outside of a ThingTalk program. This is useful to typecheck a dataset
     * and discard examples that do not typecheck without failing the whole dataset.
     *
     * @param schemas - schema retriever object to retrieve Thingpedia information
     * @param [getMeta=false] - retrieve natural language metadata during typecheck
     */
    async typecheck(schemas, getMeta = false) {
        const typeChecker = new typecheck_1.default(schemas, getMeta);
        await typeChecker.typeCheckExample(this);
        return this;
    }
    /**
     * Iterate all slots (scalar value nodes) in this example.
     * @deprecated Use {@link Ast.Example.iterateSlots2} instead.
     */
    *iterateSlots() {
        yield* this.value.iterateSlots({});
    }
    /**
     * Iterate all slots (scalar value nodes) in this example.
     */
    *iterateSlots2() {
        yield* this.value.iterateSlots2({});
    }
    /**
     * Convert a dataset example to a program.
     *
     * This will create a program that invokes the same code as the example value,
     * and will replace all parameters with slots.
     *
     * @return {Ast.Program} the new program
     */
    toProgram() {
        return declarationLikeToProgram(this);
    }
}
exports.Example = Example;
/**
 * A statement that declares a ThingTalk dataset (collection of primitive
 * templates).
 *
 */
class Dataset extends Statement {
    /**
     * Construct a new dataset.
     *
     * @param location - the position of this node in the source code
     * @param name - the name of this dataset
     * @param language - the language code of this dataset, as 2 letter ISO code
     * @param examples - the examples in this dataset
     * @param [annotations={}]- dataset annotations
     */
    constructor(location, name, examples, annotations = {}) {
        super(location);
        (0, assert_1.default)(typeof name === 'string');
        (0, assert_1.default)(!name.startsWith('@'));
        this.name = name;
        (0, assert_1.default)(Array.isArray(examples)); // of Example
        this.examples = examples;
        this.impl_annotations = annotations.impl || {};
        this.nl_annotations = annotations.nl || {};
    }
    toSource() {
        let list = list_1.default.concat('dataset', '@' + this.name, (0, base_1.nlAnnotationsToSource)(this.nl_annotations), (0, base_1.implAnnotationsToSource)(this.impl_annotations), ' ', '{', '\n', '\t+');
        let first = true;
        for (const ex of this.examples) {
            // force an additional \n between examples
            if (first)
                first = false;
            else
                list = list_1.default.concat(list, '\n');
            list = list_1.default.concat(list, ex.toSource(), '\n');
        }
        list = list_1.default.concat(list, '\t-', '}');
        return list;
    }
    get language() {
        const language = this.impl_annotations.language;
        if (language)
            return String(language.toJS());
        else
            return undefined;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitDataset(this)) {
            for (const example of this.examples)
                example.visit(visitor);
        }
        visitor.exit(this);
    }
    *iterateSlots() {
        for (const ex of this.examples)
            yield* ex.iterateSlots();
    }
    *iterateSlots2() {
        for (const ex of this.examples)
            yield* ex.iterateSlots2();
    }
    optimize() {
        return Optimizer.optimizeDataset(this);
    }
    clone() {
        const newMetadata = {};
        Object.assign(newMetadata, this.nl_annotations);
        const newAnnotations = {};
        Object.assign(newAnnotations, this.impl_annotations);
        return new Dataset(this.location, this.name, this.examples.map((e) => e.clone()), { nl: newMetadata, impl: newAnnotations });
    }
}
exports.Dataset = Dataset;
//# sourceMappingURL=statement.js.map