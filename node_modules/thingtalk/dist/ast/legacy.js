"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotifyAction = exports.InvocationAction = exports.VarRefAction = exports.Action = exports.JoinStream = exports.AliasStream = exports.ComputeStream = exports.ProjectionStream = exports.FilteredStream = exports.EdgeFilterStream = exports.EdgeNewStream = exports.MonitorStream = exports.AtTimerStream = exports.TimerStream = exports.VarRefStream = exports.Stream = exports.JoinTable = exports.SlicedTable = exports.IndexTable = exports.SortedTable = exports.AggregationTable = exports.AliasTable = exports.ComputeTable = exports.ProjectionTable = exports.FilteredTable = exports.InvocationTable = exports.VarRefTable = exports.Table = void 0;
const assert_1 = __importDefault(require("assert"));
const base_1 = __importDefault(require("./base"));
const function_def_1 = require("./function_def");
const invocation_1 = require("./invocation");
const boolean_expression_1 = require("./boolean_expression");
const expression_1 = require("./expression");
const values_1 = require("./values");
const slots_1 = require("./slots");
const type_1 = __importDefault(require("../type"));
const list_1 = __importDefault(require("../utils/list"));
/**
 * The base class of all ThingTalk query expressions.
 *
 * @deprecated This class is part of ThingTalk 1.0. Use {@link Ast.Expression} in ThingTalk 2.0.
 */
class Table extends base_1.default {
    /**
     * Construct a new table node.
     *
     * @param location - the position of this node in the source code
     * @param schema - type signature of the invoked function
     */
    constructor(location, schema) {
        super(location);
        (0, assert_1.default)(schema === null || schema instanceof function_def_1.FunctionDef);
        this.schema = schema;
    }
    toSource() {
        throw new Error(`Legacy AST node cannot be converted to source, convert to Expression first`);
    }
}
exports.Table = Table;
Table.prototype.isVarRef = false;
Table.prototype.isInvocation = false;
Table.prototype.isFilter = false;
Table.prototype.isProjection = false;
Table.prototype.isCompute = false;
Table.prototype.isAlias = false;
Table.prototype.isAggregation = false;
Table.prototype.isSort = false;
Table.prototype.isIndex = false;
Table.prototype.isSlice = false;
Table.prototype.isJoin = false;
class VarRefTable extends Table {
    constructor(location, name, in_params, schema) {
        super(location, schema);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
    }
    toExpression(extra_in_params) {
        return new expression_1.FunctionCallExpression(this.location, this.name, this.in_params.concat(extra_in_params), this.schema);
    }
    toSource() {
        return list_1.default.concat(this.name, '(', list_1.default.join(this.in_params.map((ip) => ip.toSource()), ','), ')');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitVarRefTable(this)) {
            for (const in_param of this.in_params)
                in_param.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new VarRefTable(this.location, this.name, this.in_params.map((p) => p.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        for (const in_param of this.in_params)
            yield [this.schema, in_param, this, scope];
        return [this, (0, slots_1.makeScope)(this)];
    }
    *iterateSlots2(scope) {
        return yield* (0, slots_1.iterateSlots2InputParams)(this, scope);
    }
}
exports.VarRefTable = VarRefTable;
Table.VarRef = VarRefTable;
Table.VarRef.prototype.isVarRef = true;
class InvocationTable extends Table {
    constructor(location, invocation, schema) {
        super(location, schema);
        (0, assert_1.default)(invocation instanceof invocation_1.Invocation);
        this.invocation = invocation;
    }
    toExpression(extra_in_params) {
        const invocation = this.invocation.clone();
        invocation.in_params.push(...extra_in_params);
        return new expression_1.InvocationExpression(this.location, invocation, this.schema);
    }
    toSource() {
        return this.invocation.toSource();
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitInvocationTable(this))
            this.invocation.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new InvocationTable(this.location, this.invocation.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.invocation.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.invocation.iterateSlots2(scope);
    }
}
exports.InvocationTable = InvocationTable;
Table.Invocation = InvocationTable;
Table.Invocation.prototype.isInvocation = true;
class FilteredTable extends Table {
    constructor(location, table, filter, schema) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(filter instanceof boolean_expression_1.BooleanExpression);
        this.filter = filter;
    }
    toExpression(extra_in_params) {
        return new expression_1.FilterExpression(this.location, this.table.toExpression(extra_in_params), this.filter, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitFilteredTable(this)) {
            this.table.visit(visitor);
            this.filter.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new FilteredTable(this.location, this.table.clone(), this.filter.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, newScope] = yield* this.table.iterateSlots(scope);
        yield* this.filter.iterateSlots(this.table.schema, prim, newScope);
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, newScope] = yield* this.table.iterateSlots2(scope);
        yield* this.filter.iterateSlots2(this.table.schema, prim, newScope);
        return [prim, newScope];
    }
}
exports.FilteredTable = FilteredTable;
Table.Filter = FilteredTable;
Table.Filter.prototype.isFilter = true;
class ProjectionTable extends Table {
    constructor(location, table, args, schema) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(Array.isArray(args));
        this.args = args;
    }
    toExpression(extra_in_params) {
        return new expression_1.ProjectionExpression(this.location, this.table.toExpression(extra_in_params), this.args, [], [], this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitProjectionTable(this))
            this.table.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new ProjectionTable(this.location, this.table.clone(), this.args.map((a) => (a)), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, nestedScope] = yield* this.table.iterateSlots(scope);
        const newScope = {};
        for (const name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, nestedScope] = yield* this.table.iterateSlots2(scope);
        const newScope = {};
        for (const name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
}
exports.ProjectionTable = ProjectionTable;
Table.Projection = ProjectionTable;
Table.Projection.prototype.isProjection = true;
class ComputeTable extends Table {
    constructor(location, table, expression, alias, schema, type = null) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(expression instanceof values_1.Value);
        this.expression = expression;
        (0, assert_1.default)(alias === null || typeof alias === 'string');
        this.alias = alias;
        this.type = type;
    }
    toExpression(extra_in_params) {
        return new expression_1.ProjectionExpression(this.location, this.table.toExpression(extra_in_params), ['*'], [this.expression], [this.alias], this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitComputeTable(this)) {
            this.table.visit(visitor);
            this.expression.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new ComputeTable(this.location, this.table.clone(), this.expression.clone(), this.alias, this.schema ? this.schema.clone() : null, this.type);
    }
    *iterateSlots(scope) {
        return yield* this.table.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        const [prim, innerScope] = yield* this.table.iterateSlots2(scope);
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, innerScope, this.type, this, 'compute', 'expression'));
        return [prim, innerScope];
    }
}
exports.ComputeTable = ComputeTable;
Table.Compute = ComputeTable;
Table.Compute.prototype.isCompute = true;
class AliasTable extends Table {
    constructor(location, table, name, schema) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
    }
    toExpression(extra_in_params) {
        return new expression_1.AliasExpression(this.location, this.table.toExpression(extra_in_params), this.name, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAliasTable(this))
            this.table.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new AliasTable(this.location, this.table.clone(), this.name, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.table.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.table.iterateSlots2(scope);
    }
}
exports.AliasTable = AliasTable;
Table.Alias = AliasTable;
Table.Alias.prototype.isAlias = true;
class AggregationTable extends Table {
    constructor(location, table, field, operator, alias, schema, overload = null) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(typeof field === 'string');
        this.field = field;
        (0, assert_1.default)(typeof operator === 'string');
        this.operator = operator;
        (0, assert_1.default)(alias === null || typeof alias === 'string');
        this.alias = alias;
        this.overload = overload;
    }
    toExpression(extra_in_params) {
        return new expression_1.AggregationExpression(this.location, this.table.toExpression(extra_in_params), this.field, this.operator, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAggregationTable(this))
            this.table.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new AggregationTable(this.location, this.table.clone(), this.field, this.operator, this.alias, this.schema ? this.schema.clone() : null, this.overload);
    }
    *iterateSlots(scope) {
        return yield* this.table.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.table.iterateSlots2(scope);
    }
}
exports.AggregationTable = AggregationTable;
Table.Aggregation = AggregationTable;
Table.Aggregation.prototype.isAggregation = true;
class SortedTable extends Table {
    constructor(location, table, field, direction, schema) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(typeof field === 'string');
        this.field = field;
        (0, assert_1.default)(direction === 'asc' || direction === 'desc');
        this.direction = direction;
    }
    toExpression(extra_in_params) {
        return new expression_1.SortExpression(this.location, this.table.toExpression(extra_in_params), new values_1.Value.VarRef(this.field), this.direction, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitSortedTable(this))
            this.table.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new SortedTable(this.location, this.table.clone(), this.field, this.direction, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.table.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.table.iterateSlots2(scope);
    }
}
exports.SortedTable = SortedTable;
Table.Sort = SortedTable;
Table.Sort.prototype.isSort = true;
class IndexTable extends Table {
    constructor(location, table, indices, schema) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(Array.isArray(indices));
        this.indices = indices;
    }
    toExpression(extra_in_params) {
        return new expression_1.IndexExpression(this.location, this.table.toExpression(extra_in_params), this.indices, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitIndexTable(this)) {
            this.table.visit(visitor);
            for (const index of this.indices)
                index.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new IndexTable(this.location, this.table.clone(), this.indices.map((i) => i.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.table.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        const [prim, innerScope] = yield* this.table.iterateSlots2(scope);
        for (let i = 0; i < this.indices.length; i++)
            yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.ArrayIndexSlot(prim, innerScope, type_1.default.Number, this.indices, 'table.index', i));
        return [prim, innerScope];
    }
}
exports.IndexTable = IndexTable;
Table.Index = IndexTable;
Table.Index.prototype.isIndex = true;
class SlicedTable extends Table {
    constructor(location, table, base, limit, schema) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(base instanceof values_1.Value);
        this.base = base;
        (0, assert_1.default)(limit instanceof values_1.Value);
        this.limit = limit;
    }
    toExpression(extra_in_params) {
        return new expression_1.SliceExpression(this.location, this.table.toExpression(extra_in_params), this.base, this.limit, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitSlicedTable(this)) {
            this.table.visit(visitor);
            this.base.visit(visitor);
            this.limit.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new SlicedTable(this.location, this.table.clone(), this.base.clone(), this.limit.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.table.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        const [prim, innerScope] = yield* this.table.iterateSlots2(scope);
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, innerScope, type_1.default.Number, this, 'slice', 'base'));
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, innerScope, type_1.default.Number, this, 'slice', 'limit'));
        return [prim, innerScope];
    }
}
exports.SlicedTable = SlicedTable;
Table.Slice = SlicedTable;
Table.Slice.prototype.isSlice = true;
class JoinTable extends Table {
    constructor(location, lhs, rhs, in_params, schema) {
        super(location, schema);
        (0, assert_1.default)(lhs instanceof Table);
        this.lhs = lhs;
        (0, assert_1.default)(rhs instanceof Table);
        this.rhs = rhs;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
    }
    toExpression(extra_in_params) {
        // we need typechecking to implement this correctly, but typechecking
        // happens after the conversion so it is too late
        if (extra_in_params.length > 0)
            throw new Error(`Cannot carry extra_in_params across a join`);
        return new expression_1.ChainExpression(this.location, [this.lhs.toExpression([]), this.rhs.toExpression(this.in_params)], this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitJoinTable(this)) {
            this.lhs.visit(visitor);
            this.rhs.visit(visitor);
            for (const in_param of this.in_params)
                in_param.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new JoinTable(this.location, this.lhs.clone(), this.rhs.clone(), this.in_params.map((p) => p.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [, leftScope] = yield* this.lhs.iterateSlots(scope);
        const [, rightScope] = yield* this.rhs.iterateSlots(scope);
        const newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    }
    *iterateSlots2(scope) {
        const [, leftScope] = yield* this.lhs.iterateSlots2(scope);
        const [, rightScope] = yield* this.rhs.iterateSlots2(scope);
        const newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    }
}
exports.JoinTable = JoinTable;
Table.Join = JoinTable;
Table.Join.prototype.isJoin = true;
/**
 * The base class of all ThingTalk stream expressions.
 *
 * @deprecated This class is part of ThingTalk 1.0. Use {@link Ast.Expression} in ThingTalk 2.0.
 */
class Stream extends base_1.default {
    /**
     * Construct a new stream node.
     *
     * @param location - the position of this node in the source code
     * @param schema - type signature of the stream expression
     */
    constructor(location, schema) {
        super(location);
        (0, assert_1.default)(schema === null || schema instanceof function_def_1.FunctionDef);
        this.schema = schema;
    }
    toSource() {
        throw new Error(`Legacy AST node cannot be converted to source, convert to Expression first`);
    }
}
exports.Stream = Stream;
Stream.prototype.isVarRef = false;
Stream.prototype.isTimer = false;
Stream.prototype.isAtTimer = false;
Stream.prototype.isMonitor = false;
Stream.prototype.isEdgeNew = false;
Stream.prototype.isEdgeFilter = false;
Stream.prototype.isFilter = false;
Stream.prototype.isProjection = false;
Stream.prototype.isCompute = false;
Stream.prototype.isAlias = false;
Stream.prototype.isJoin = false;
class VarRefStream extends Stream {
    constructor(location, name, in_params, schema) {
        super(location, schema);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
    }
    toExpression() {
        return new expression_1.FunctionCallExpression(this.location, this.name, this.in_params, this.schema);
    }
    toSource() {
        return list_1.default.concat(this.name, '(', list_1.default.join(this.in_params.map((ip) => ip.toSource()), ','), ')');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitVarRefStream(this)) {
            for (const in_param of this.in_params)
                in_param.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new VarRefStream(this.location, this.name, this.in_params.map((p) => p.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        for (const in_param of this.in_params)
            yield [this.schema, in_param, this, scope];
        return [this, (0, slots_1.makeScope)(this)];
    }
    *iterateSlots2(scope) {
        return yield* (0, slots_1.iterateSlots2InputParams)(this, scope);
    }
}
exports.VarRefStream = VarRefStream;
Stream.VarRef = VarRefStream;
Stream.VarRef.prototype.isVarRef = true;
class TimerStream extends Stream {
    constructor(location, base, interval, frequency, schema) {
        super(location, schema);
        (0, assert_1.default)(base instanceof values_1.Value);
        this.base = base;
        (0, assert_1.default)(interval instanceof values_1.Value);
        this.interval = interval;
        (0, assert_1.default)(frequency === null || frequency instanceof values_1.Value);
        this.frequency = frequency;
    }
    toExpression() {
        const args = [new invocation_1.InputParam(null, 'base', this.base),
            new invocation_1.InputParam(null, 'interval', this.interval)];
        if (this.frequency)
            args.push(new invocation_1.InputParam(null, 'frequency', this.frequency));
        return new expression_1.FunctionCallExpression(this.location, 'timer', args, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitTimerStream(this)) {
            this.base.visit(visitor);
            this.interval.visit(visitor);
            if (this.frequency !== null)
                this.frequency.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new TimerStream(this.location, this.base.clone(), this.interval.clone(), this.frequency ? this.frequency.clone() : null, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        // no primitive here
        return [null, {}];
    }
    *iterateSlots2(scope) {
        // no primitive here
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(null, scope, type_1.default.Date, this, 'timer', 'base'));
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(null, scope, new type_1.default.Measure('ms'), this, 'timer', 'interval'));
        return [null, {}];
    }
}
exports.TimerStream = TimerStream;
Stream.Timer = TimerStream;
Stream.Timer.prototype.isTimer = true;
class AtTimerStream extends Stream {
    constructor(location, time, expiration_date, schema) {
        super(location, schema);
        (0, assert_1.default)(Array.isArray(time));
        this.time = time;
        (0, assert_1.default)(expiration_date === null || expiration_date instanceof values_1.Value);
        this.expiration_date = expiration_date;
    }
    toExpression() {
        const in_params = [new invocation_1.InputParam(null, 'time', new values_1.Value.Array(this.time))];
        if (this.expiration_date)
            in_params.push(new invocation_1.InputParam(null, 'expiration_date', this.expiration_date));
        return new expression_1.FunctionCallExpression(this.location, 'attimer', in_params, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAtTimerStream(this)) {
            for (const time of this.time)
                time.visit(visitor);
            if (this.expiration_date !== null)
                this.expiration_date.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new AtTimerStream(this.location, this.time.map((t) => t.clone()), this.expiration_date ? this.expiration_date.clone() : null, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        // no primitive here
        return [null, {}];
    }
    *iterateSlots2(scope) {
        for (let i = 0; i < this.time.length; i++)
            yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.ArrayIndexSlot(null, scope, type_1.default.Time, this.time, 'attimer.time', i));
        if (this.expiration_date !== null)
            yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(null, scope, type_1.default.Date, this, 'attimer', 'expiration_date'));
        return [null, {}];
    }
}
exports.AtTimerStream = AtTimerStream;
Stream.AtTimer = AtTimerStream;
Stream.AtTimer.prototype.isAtTimer = true;
class MonitorStream extends Stream {
    constructor(location, table, args, schema) {
        super(location, schema);
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(args === null || Array.isArray(args));
        this.args = args;
    }
    toExpression() {
        return new expression_1.MonitorExpression(this.location, this.table.toExpression([]), this.args, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitMonitorStream(this))
            this.table.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new MonitorStream(this.location, this.table.clone(), this.args ? this.args.map((a) => a) : null, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.table.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.table.iterateSlots2(scope);
    }
}
exports.MonitorStream = MonitorStream;
Stream.Monitor = MonitorStream;
Stream.Monitor.prototype.isMonitor = true;
class EdgeNewStream extends Stream {
    constructor(location, stream, schema) {
        super(location, schema);
        (0, assert_1.default)(stream instanceof Stream);
        this.stream = stream;
    }
    toExpression() {
        throw new Error('`edge on new` is not supported in the new syntax');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitEdgeNewStream(this))
            this.stream.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new EdgeNewStream(this.location, this.stream.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.stream.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.stream.iterateSlots2(scope);
    }
}
exports.EdgeNewStream = EdgeNewStream;
Stream.EdgeNew = EdgeNewStream;
Stream.EdgeNew.prototype.isEdgeNew = true;
class EdgeFilterStream extends Stream {
    constructor(location, stream, filter, schema) {
        super(location, schema);
        (0, assert_1.default)(stream instanceof Stream);
        this.stream = stream;
        (0, assert_1.default)(filter instanceof boolean_expression_1.BooleanExpression);
        this.filter = filter;
    }
    toExpression() {
        return new expression_1.FilterExpression(this.location, this.stream.toExpression(), this.filter, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitEdgeFilterStream(this)) {
            this.stream.visit(visitor);
            this.filter.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new EdgeFilterStream(this.location, this.stream.clone(), this.filter.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, newScope] = yield* this.stream.iterateSlots(scope);
        yield* this.filter.iterateSlots(this.stream.schema, prim, newScope);
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, newScope] = yield* this.stream.iterateSlots2(scope);
        yield* this.filter.iterateSlots2(this.stream.schema, prim, newScope);
        return [prim, newScope];
    }
}
exports.EdgeFilterStream = EdgeFilterStream;
Stream.EdgeFilter = EdgeFilterStream;
Stream.EdgeFilter.prototype.isEdgeFilter = true;
class FilteredStream extends Stream {
    constructor(location, stream, filter, schema) {
        super(location, schema);
        (0, assert_1.default)(stream instanceof Stream);
        this.stream = stream;
        (0, assert_1.default)(filter instanceof boolean_expression_1.BooleanExpression);
        this.filter = filter;
    }
    toExpression() {
        // catch a common case that we can handle before bailing
        if (this.stream instanceof MonitorStream) {
            return new expression_1.MonitorExpression(this.location, new expression_1.FilterExpression(this.location, this.stream.table.toExpression([]), this.filter, this.schema), this.stream.args, this.stream.schema);
        }
        throw new Error('stream filter is not supported in the new syntax (push the filter down inside the monitor)');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitFilteredStream(this)) {
            this.stream.visit(visitor);
            this.filter.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new FilteredStream(this.location, this.stream.clone(), this.filter.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, newScope] = yield* this.stream.iterateSlots(scope);
        yield* this.filter.iterateSlots(this.stream.schema, prim, newScope);
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, newScope] = yield* this.stream.iterateSlots2(scope);
        yield* this.filter.iterateSlots2(this.stream.schema, prim, newScope);
        return [prim, newScope];
    }
}
exports.FilteredStream = FilteredStream;
Stream.Filter = FilteredStream;
Stream.Filter.prototype.isFilter = true;
class ProjectionStream extends Stream {
    constructor(location, stream, args, schema) {
        super(location, schema);
        (0, assert_1.default)(stream instanceof Stream);
        this.stream = stream;
        (0, assert_1.default)(Array.isArray(args));
        this.args = args;
    }
    toExpression() {
        return new expression_1.ProjectionExpression(this.location, this.stream.toExpression(), this.args, [], [], this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitProjectionStream(this))
            this.stream.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new ProjectionStream(this.location, this.stream.clone(), this.args.map((a) => a), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, nestedScope] = yield* this.stream.iterateSlots(scope);
        const newScope = {};
        for (const name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, nestedScope] = yield* this.stream.iterateSlots2(scope);
        const newScope = {};
        for (const name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
}
exports.ProjectionStream = ProjectionStream;
Stream.Projection = ProjectionStream;
Stream.Projection.prototype.isProjection = true;
class ComputeStream extends Stream {
    constructor(location, stream, expression, alias, schema, type = null) {
        super(location, schema);
        (0, assert_1.default)(stream instanceof Stream);
        this.stream = stream;
        (0, assert_1.default)(expression instanceof values_1.Value);
        this.expression = expression;
        (0, assert_1.default)(alias === null || typeof alias === 'string');
        this.alias = alias;
        this.type = type;
    }
    toExpression() {
        return new expression_1.ProjectionExpression(this.location, this.stream.toExpression(), [], [this.expression], [this.alias], this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitComputeStream(this)) {
            this.stream.visit(visitor);
            this.expression.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new ComputeStream(this.location, this.stream.clone(), this.expression.clone(), this.alias, this.schema ? this.schema.clone() : null, this.type);
    }
    *iterateSlots(scope) {
        return yield* this.stream.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        const [prim, innerScope] = yield* this.stream.iterateSlots2(scope);
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, innerScope, this.type, this, 'compute', 'expression'));
        return [prim, innerScope];
    }
}
exports.ComputeStream = ComputeStream;
Stream.Compute = ComputeStream;
Stream.Compute.prototype.isCompute = true;
class AliasStream extends Stream {
    constructor(location, stream, name, schema) {
        super(location, schema);
        (0, assert_1.default)(stream instanceof Stream);
        this.stream = stream;
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
    }
    toExpression() {
        return new expression_1.AliasExpression(this.location, this.stream.toExpression(), this.name, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAliasStream(this))
            this.stream.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new AliasStream(this.location, this.stream.clone(), this.name, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.stream.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.stream.iterateSlots2(scope);
    }
}
exports.AliasStream = AliasStream;
Stream.Alias = AliasStream;
Stream.Alias.prototype.isAlias = true;
class JoinStream extends Stream {
    constructor(location, stream, table, in_params, schema) {
        super(location, schema);
        (0, assert_1.default)(stream instanceof Stream);
        this.stream = stream;
        (0, assert_1.default)(table instanceof Table);
        this.table = table;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
    }
    toExpression() {
        const lhs = this.stream.toExpression();
        // flatten chain expressions, or typechecking will fail
        if (lhs instanceof expression_1.ChainExpression)
            return new expression_1.ChainExpression(this.location, [...lhs.expressions, this.table.toExpression(this.in_params)], this.schema);
        else
            return new expression_1.ChainExpression(this.location, [lhs, this.table.toExpression(this.in_params)], this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitJoinStream(this)) {
            this.stream.visit(visitor);
            this.table.visit(visitor);
            for (const in_param of this.in_params)
                in_param.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new JoinStream(this.location, this.stream.clone(), this.table.clone(), this.in_params.map((p) => p.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [, leftScope] = yield* this.stream.iterateSlots(scope);
        const [, rightScope] = yield* this.table.iterateSlots(scope);
        const newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    }
    *iterateSlots2(scope) {
        const [, leftScope] = yield* this.stream.iterateSlots2(scope);
        const [, rightScope] = yield* this.table.iterateSlots2(scope);
        const newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    }
}
exports.JoinStream = JoinStream;
Stream.Join = JoinStream;
Stream.Join.prototype.isJoin = true;
/**
 * Base class for all expressions that invoke an action.
 *
 * @deprecated This class is part of ThingTalk 1.0. Use {@link Ast.Expression} in ThingTalk 2.0.
 */
class Action extends base_1.default {
    /**
     * Construct a new action expression node.
     *
     * @param location - the position of this node in the source code
     * @param schema - type signature of this action
     */
    constructor(location, schema) {
        super(location);
        (0, assert_1.default)(schema === null || schema instanceof function_def_1.FunctionDef);
        this.schema = schema;
    }
    /**
     * Utility function to create a `notify` or `return` action.
     *
     * @param {string} [what=notify] - what action to create
     * @return {Ast.Action} the action node
     */
    static notifyAction(what = 'notify') {
        return new NotifyAction(null, what, null);
    }
}
exports.Action = Action;
Action.prototype.isVarRef = false;
Action.prototype.isInvocation = false;
Action.prototype.isNotify = false;
/**
 * An invocation of a locally defined action (i.e. one defined with
 * a `let` statement).
 *
 */
class VarRefAction extends Action {
    /**
     * Construct a new var ref action.
     *
     * @param location - the position of this node in the source code
     * @param name - the name of the action to invoke
     * @param in_params - the input parameters to pass
     * @param schema - type signature of this action
     */
    constructor(location, name, in_params, schema) {
        super(location, schema);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
    }
    toExpression() {
        return new expression_1.FunctionCallExpression(this.location, this.name, this.in_params, this.schema);
    }
    toSource() {
        return list_1.default.concat(this.name, '(', list_1.default.join(this.in_params.map((ip) => ip.toSource()), ','), ')');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitVarRefAction(this)) {
            for (const in_param of this.in_params)
                in_param.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new VarRefAction(this.location, this.name, this.in_params.map((p) => p.clone()), this.schema ? this.schema.clone() : null);
    }
    toString() {
        return `VarRef(${this.name}, ${this.in_params.toString()}, )`;
    }
    *iterateSlots(scope) {
        for (const in_param of this.in_params)
            yield [this.schema, in_param, this, scope];
    }
    *iterateSlots2(scope) {
        yield* (0, slots_1.iterateSlots2InputParams)(this, scope);
    }
}
exports.VarRefAction = VarRefAction;
Action.VarRef = VarRefAction;
Action.VarRef.prototype.isVarRef = true;
/**
 * An invocation of an action in Thingpedia.
 *
 */
class InvocationAction extends Action {
    /**
     * Construct a new invocation action.
     *
     * @param location - the position of this node in the source code
     * @param invocation - the function invocation
     * @param schema - type signature of this action
     */
    constructor(location, invocation, schema) {
        super(location, schema);
        (0, assert_1.default)(invocation instanceof invocation_1.Invocation);
        this.invocation = invocation;
    }
    toExpression() {
        return new expression_1.InvocationExpression(this.location, this.invocation, this.schema);
    }
    toSource() {
        return this.invocation.toSource();
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitInvocationAction(this))
            this.invocation.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new InvocationAction(this.location, this.invocation.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        yield* this.invocation.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        yield* this.invocation.iterateSlots2(scope);
    }
}
exports.InvocationAction = InvocationAction;
Action.Invocation = InvocationAction;
Action.Invocation.prototype.isInvocation = true;
/**
 * A `notify`, `return` or `save` clause.
 *
 */
class NotifyAction extends Action {
    /**
     * Construct a new notify action.
     *
     * @param location - the position of this node in the source code
     * @param name - the clause name
     * @param schema - type signature of this action
     */
    constructor(location, name, schema = null) {
        super(location, schema);
        // we used to support "return" and "save", but those are gone
        // in new syntax so let's make sure we don't create ASTs for them
        // (or we'll lose information when we convert)
        (0, assert_1.default)(name === 'notify');
        this.name = name;
    }
    toExpression() {
        throw new Error(`notify actions no longer exist`);
    }
    toSource() {
        return list_1.default.singleton(this.name);
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitNotifyAction(this);
        visitor.exit(this);
    }
    clone() {
        return new NotifyAction(this.location, this.name, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
    }
    *iterateSlots2(scope) {
    }
}
exports.NotifyAction = NotifyAction;
Action.Notify = NotifyAction;
Action.Notify.prototype.isNotify = true;
//# sourceMappingURL=legacy.js.map