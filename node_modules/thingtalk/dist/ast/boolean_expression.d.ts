import Node, { SourceRange } from './base';
import NodeVisitor from './visitor';
import { FunctionDef } from './function_def';
import { Value } from './values';
import { Expression } from './expression';
import Type from '../type';
import { AbstractSlot, OldSlot, ScopeMap, InvocationLike } from './slots';
import { DeviceSelector, InputParam } from './invocation';
import { TokenStream } from '../new-syntax/tokenstream';
import { SyntaxPriority } from './syntax_priority';
/**
 * An expression that computes a boolean predicate.
 * This AST node is used in filter expressions.
 */
export declare abstract class BooleanExpression extends Node {
    static And: any;
    isAnd: boolean;
    static Or: any;
    isOr: boolean;
    static Atom: any;
    isAtom: boolean;
    static Not: any;
    isNot: boolean;
    static External: any;
    isExternal: boolean;
    static ExistentialSubquery: any;
    isExistentialSubquery: boolean;
    static ComparisonSubquery: any;
    isComparisonSubquery: boolean;
    /**
     * The constant `true` boolean expression.
     *
     * This is a singleton, not a class.
     */
    static True: BooleanExpression;
    isTrue: boolean;
    /**
     * The constant `false` boolean expression.
     *
     * This is a singleton, not a class.
     */
    static False: BooleanExpression;
    isFalse: boolean;
    static Compute: any;
    isCompute: boolean;
    static DontCare: any;
    isDontCare: boolean;
    static PropertyPath: any;
    isPropertyPath: boolean;
    optimize(): BooleanExpression;
    abstract get priority(): SyntaxPriority;
    abstract clone(): BooleanExpression;
    abstract equals(other: BooleanExpression): boolean;
    abstract toLegacy(): BooleanExpression;
    /**
     * Iterate all slots (scalar value nodes) in this boolean expression.
     *
     * @deprecated Use {@link Ast.BooleanExpression.iterateSlots2} instead.
     */
    abstract iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    /**
     * Iterate all slots (scalar value nodes) in this boolean expression.
     */
    abstract iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A conjunction boolean expression (ThingTalk operator `&&`)
 */
export declare class AndBooleanExpression extends BooleanExpression {
    /**
     * The expression operands.
     */
    operands: BooleanExpression[];
    /**
     * Construct a new And expression.
     *
     * @param location - the position of this node in the source code
     * @param operands - the expression operands
     */
    constructor(location: SourceRange | null, operands: BooleanExpression[]);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): AndBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): AndBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A disjunction boolean expression (ThingTalk operator `||`)
 */
export declare class OrBooleanExpression extends BooleanExpression {
    /**
     * The expression operands.
     */
    operands: BooleanExpression[];
    /**
     * Construct a new Or expression.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {Ast.BooleanExpression[]} operands - the expression operands
     */
    constructor(location: SourceRange | null, operands: BooleanExpression[]);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): OrBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): OrBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A comparison expression (predicate atom)
 */
export declare class AtomBooleanExpression extends BooleanExpression {
    /**
     * The parameter name to compare.
     */
    name: string;
    /**
     * The comparison operator.
     */
    operator: string;
    /**
      * The value being compared against.
      */
    value: Value;
    overload: Type[] | null;
    /**
     * Construct a new atom boolean expression.
     *
     * @param location - the position of this node in the source code
     * @param name - the parameter name to compare
     * @param operator - the comparison operator
     * @param value - the value being compared against
     */
    constructor(location: SourceRange | null, name: string, operator: string, value: Value, overload: Type[] | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): AtomBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): AtomBooleanExpression;
    toString(): string;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A negation boolean expression (ThingTalk operator `!`)
 */
export declare class NotBooleanExpression extends BooleanExpression {
    /**
     * The expression being negated.
     */
    expr: BooleanExpression;
    /**
     * Construct a new Not expression.
     *
     * @param location - the position of this node in the source code
     * @param expr - the expression being negated
     */
    constructor(location: SourceRange | null, expr: BooleanExpression);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): NotBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): NotBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A boolean expression that calls a Thingpedia query function
 * and filters the result.
 *
 * The boolean expression is true if at least one result from the function
 * call satisfies the filter.
 *
 * @deprecated Use {@link ComparisonSubqueryBooleanExpression} or {@link ExistentialSubqueryBooleanExpression} instead.
 */
export declare class ExternalBooleanExpression extends BooleanExpression {
    /**
     * The selector choosing where the function is invoked.
     */
    selector: DeviceSelector;
    /**
     * The function name being invoked.
     */
    channel: string;
    /**
     * The input parameters passed to the function.
     */
    in_params: InputParam[];
    /**
     * The predicate to apply on the invocation's results.
     */
    filter: BooleanExpression;
    /**
     * Type signature of the invoked function.
     * This property is guaranteed not `null` after type-checking.
     */
    schema: FunctionDef | null;
    __effectiveSelector: DeviceSelector | null;
    /**
     * Construct a new external boolean expression.
     *
     * @param {Ast.Selector.Device} selector - the selector choosing where the function is invoked
     * @param {string} channel - the function name
     * @param {Ast.InputParam[]} in_params - input parameters passed to the function
     * @param {Ast.BooleanExpression} filter - the filter to apply on the invocation's results
     * @param {Ast.FunctionDef|null} schema - type signature of the invoked function
     */
    constructor(location: SourceRange | null, selector: DeviceSelector, channel: string, in_params: InputParam[], filter: BooleanExpression, schema: FunctionDef | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toString(): string;
    toLegacy(): ExternalBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): ExternalBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A boolean expression that calls a Thingpedia query function
 * and filters the result.
 *
 * The boolean expression is true if at least one result from the function
 * call satisfies the filter.
 *
 */
export declare class ExistentialSubqueryBooleanExpression extends BooleanExpression {
    subquery: Expression;
    /**
     * Construct a new existential subquery boolean expression.
     *
     * @param location
     * @param subquery: the query used for check existence of result
     */
    constructor(location: SourceRange | null, subquery: Expression);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toString(): string;
    toLegacy(): ExternalBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): ExistentialSubqueryBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A boolean expression that calls a Thingpedia query function
 * and compares the result with another value.
 *
 */
export declare class ComparisonSubqueryBooleanExpression extends BooleanExpression {
    lhs: Value;
    rhs: Expression;
    operator: string;
    overload: Type[] | null;
    /**
     * Construct a new comparison subquery boolean expression.
     *
     * @param location
     * @param lhs - the parameter name to compare
     * @param operator - the comparison operator
     * @param rhs - a projection subquery which returns one field
     * @param overload - type overload
     */
    constructor(location: SourceRange | null, lhs: Value, operator: string, rhs: Expression, overload: Type[] | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toString(): string;
    toLegacy(): ExternalBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): ComparisonSubqueryBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A boolean expression that expresses that the user does not care about a specific parameter.
 *
 * It is essentially the same as "true", but it has a parameter attached to it.
 */
export declare class DontCareBooleanExpression extends BooleanExpression {
    name: string;
    constructor(location: SourceRange | null, name: string);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): DontCareBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): DontCareBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
export declare class TrueBooleanExpression extends BooleanExpression {
    constructor();
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): TrueBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): TrueBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
export declare class FalseBooleanExpression extends BooleanExpression {
    constructor();
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): FalseBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): FalseBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
/**
 * A boolean expression that computes a scalar expression and then does a comparison
 *
 */
export declare class ComputeBooleanExpression extends BooleanExpression {
    /**
     * The scalar expression being compared.
     */
    lhs: Value;
    /**
     * The comparison operator.
     */
    operator: string;
    /**
     * The value being compared against.
     */
    rhs: Value;
    overload: Type[] | null;
    /**
     * Construct a new compute boolean expression.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {Ast.ScalarExpression} lhs - the scalar expression to compute
     * @param {string} operator - the comparison operator
     * @param {Ast.Value} value - the value being compared against
     */
    constructor(location: SourceRange | null, lhs: Value, operator: string, rhs: Value, overload?: Type[] | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): ComputeBooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): ComputeBooleanExpression;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
    toString(): string;
}
export declare class PropertyPathElement extends Node {
    property: string;
    quantifier?: '+' | '*' | '?';
    constructor(property: string, quantifier?: '+' | '*' | '?');
    equals(other: PropertyPathElement): boolean;
    clone(): PropertyPathElement;
    toSource(): TokenStream;
    toString(): string;
    visit(visitor: NodeVisitor): void;
}
export declare type PropertyPathSequence = PropertyPathElement[];
/**
 * A boolean expression with SPARQL-style property path
 * this is only meaningful for knowledge graph such as wikidata
 */
export declare class PropertyPathBooleanExpression extends BooleanExpression {
    /**
     * The parameter name to compare.
     */
    path: PropertyPathSequence;
    /**
     * The comparison operator.
     */
    operator: string;
    /**
      * The value being compared against.
      */
    value: Value;
    overload: Type[] | null;
    /**
     * Construct a new atom boolean expression.
     *
     * @param location - the position of this node in the source code
     * @param path - the property path to compare
     * @param operator - the comparison operator
     * @param value - the value being compared against
     */
    constructor(location: SourceRange | null, path: PropertyPathSequence, operator: string, value: Value, overload: Type[] | null);
    get priority(): SyntaxPriority;
    toSource(): TokenStream;
    toLegacy(): BooleanExpression;
    equals(other: BooleanExpression): boolean;
    visit(visitor: NodeVisitor): void;
    clone(): PropertyPathBooleanExpression;
    toString(): string;
    iterateSlots(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<OldSlot, void>;
    iterateSlots2(schema: FunctionDef | null, prim: InvocationLike | null, scope: ScopeMap): Generator<DeviceSelector | AbstractSlot, void>;
}
