import Node, { SourceRange, NLAnnotationMap, AnnotationMap, AnnotationSpec } from './base';
import Type from '../type';
import { ClassDef } from './class_def';
import NodeVisitor from './visitor';
import { TokenStream } from '../new-syntax/tokenstream';
/**
 * The direction of a function argument (parameter).
 *
 */
export declare enum ArgDirection {
    IN_REQ = "in req",
    IN_OPT = "in opt",
    OUT = "out"
}
/**
 * The definition of a function argument, with it's name, type and annotations.
 *
 * This class is also used to define fields in {@link Type.Compound} types.
 *
 */
export declare class ArgumentDef extends Node {
    /**
     * The direction of this argument.
     */
    direction: ArgDirection | null;
    /**
     * The argument name.
     */
    name: string;
    /**
     * The argument type.
     */
    type: Type;
    /**
     * The argument metadata (translatable annotations).
     */
    nl_annotations: NLAnnotationMap;
    /**
     * The argument annotations.
     */
    impl_annotations: AnnotationMap;
    /**
     * Whether this argument is an input or output argument.
     */
    is_input: boolean;
    /**
     * Whether this argument is required.
     */
    required: boolean;
    unique: boolean;
    private _is_compound_field;
    /**
     * Construct a new argument definition.
     *
     * @param location - the position of this node in the source code
     * @param direction - the direction of the argument, or null for a struct field
     * @param name - the argument name
     * @param type - the argument type
     * @param annotations - annotations of the argument
     * @param [annotations.nl={}] - natural-language annotations (translatable annotations)
     * @param [annotations.impl={}] - implementation annotations
     */
    constructor(location: SourceRange | null, direction: ArgDirection | null, name: string, type: Type, annotations?: AnnotationSpec, is_compound_field?: boolean);
    toSource(): TokenStream;
    private _updateFields;
    private _flattenCompoundArray;
    private _iterateCompoundArrayFields;
    /**
    * The canonical form of this argument.
    *
    * This is the primary form of the `#_[canonical]` annotation,
    * if present, or an automatically derived string based on the
    * argument name.
    *
    */
    get canonical(): string;
    /**
     * Read and normalize an implementation annotation from this function definition.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation normalized value, or `undefined` if the
     *         annotation is not present
     */
    getImplementationAnnotation<T>(name: string): T | undefined;
    /**
     * Read a natural-language annotation from this function definition.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation value, or `undefined` if the
     *         annotation is not present
     */
    getNaturalLanguageAnnotation<T>(name: string): T | undefined;
    /**
     * Clone this argument and return a new object with the same properties.
     *
     * @return {Ast.ArgumentDef} the new instance
     */
    clone(): ArgumentDef;
    visit(visitor: NodeVisitor): void;
    /**
     * All natural language metadata for this argument
     * (canonical, confirmation, formatted).
     * @deprecated metadata is deprecated and should not be used. Use {@link Ast.ArgumentDef.nl_annotations} instead.
     */
    get metadata(): NLAnnotationMap;
    /**
     * Implementation annotations
     * @deprecated annotations is deprecated and should not be used. Use {@link Ast.ArgumentDef.impl_annotations} instead.
     */
    get annotations(): AnnotationMap;
    /**
     * Read and normalize an annotation from this argument.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation normalized value, or `undefined` if the
     *         annotation is not present
     * @deprecated getAnnotation is deprecated and should not be used. Use {@link Ast.ArgumentDef.getImplementationAnnotation} instead.
     */
    getAnnotation<T>(name: string): T | undefined;
}
/**
 * Callback type for a filter on arguments.
 *
 * @param {Ast.ArgumentDef} arg - the argument to check
 * @return {boolean} whether the argument passes the filter
 */
export declare type ArgumentFilterCallback = (arg: ArgumentDef) => boolean;
export declare type FunctionType = 'stream' | 'query' | 'action';
/**
 * The definition of a ThingTalk function (inside a class).
 *
 * Function definitions are semi-immutable: you should not modify a function definition
 * received from outside. Instead, you should call {@link Ast.FunctionDef.clone}
 * to create a new instance you can modify. This includes modifying metadata and annotations
 * through the {@link Ast.FunctionDef.metadata} and {@link Ast.FunctionDef.annotations}
 * properties. Failure to call {@link Ast.FunctionDef.clone} will result in obsure
 * type checking errors.
 *
 */
export declare class FunctionDef extends Node {
    private _functionType;
    private _name;
    private _qualifiedName;
    private _qualifiers;
    private _nl_annotations;
    private _impl_annotations;
    private _args;
    private _types;
    private _argmap;
    private _index;
    private _inReq;
    private _inOpt;
    private _out;
    private _extends;
    private _class;
    /**
     * The canonical forms of arguments defined by this expression signature.
     *
     * @deprecated Use {@link Ast.FunctionDef.getArgument} and
     *             {@link Ast.ArgumentDef.canonical} instead.
     */
    argcanonicals: string[];
    /**
     * The question (prompts) of arguments defined by this expression signature.
     *
     * @deprecated Use {@link Ast.FunctionDef.getArgument} and
     *             {@link Ast.ArgumentDef.metadata}`.prompt` instead.
     */
    questions: string[];
    /**
     * Whether this signature defines a `list` query function.
     *
     * This is always false on action and stream signatures.
     *
     */
    is_list: boolean;
    /**
     * Whether this signature defines a `monitorable` query function.
     *
     * This is always false on action signatures, and always true on stream signatures.
     *
     */
    is_monitorable: boolean;
    require_filter: boolean;
    default_projection: string[];
    minimal_projection: string[] | undefined;
    no_filter: boolean;
    /**
     * Construct a new function definition.
     *
     * @param location - the position of this node in the source code
     * @param functionType - the function type (`stream`, `query` or `action`)
     * @param {Ast.ClassDef|null} klass - the class that the function belongs to
     * @param {string} name - the function name
     * @param {string[]|null} _extends - functions that are extended by this definition
     * @param {Ast.ArgumentDef[]} args - the arguments in this function
     * @param {Object.<string, any>} qualifiers - the qualifiers of the function
     * @param {boolean} [qualifiers.is_list=false] - whether this function defines a `list` query
     * @param {boolean} [qualifiers.is_monitorable=false] - whether this function defines a `monitorable` query
     * @param {Object.<string, Object>} annotations - function annotations
     * @param {Object.<string, any>} [annotations.nl={}] - natural language annotations of the function (translatable annotations)
     * @param {Object.<string, Ast.Value>} [annotations.impl={}]- implementation annotations
     */
    constructor(location: SourceRange | null, functionType: FunctionType, klass: ClassDef | null, name: string, _extends: string[], qualifiers: {
        is_list: boolean;
        is_monitorable: boolean;
    }, args: ArgumentDef[], annotations?: AnnotationSpec);
    /**
     * The function name, as declared in the ThingTalk code.
     */
    get name(): string;
    /**
     * The full name of the function, including the class name.
     *
     * This has the form of `<class-name>.<function-name>` if the
     * function belongs to a class, and `.<function-name>` otherwise.
     *
     * Hence, it's possible to distinguish functions that have no
     * class with the leading dot.
     */
    get qualifiedName(): string;
    /**
     * The names of the arguments defined by this expression signature.
     *
     * This does not include arguments inherited from parent functions.
     */
    get args(): string[];
    /**
     * The type of this signature, either `stream`, `query` or `action`
     */
    get functionType(): FunctionType;
    /**
     * The names of the base functions this signature extends.
     */
    get extends(): string[];
    /**
     * The class definition associated with this signature, or `null` if this
     * signature was not created as part of a ThingTalk class.
     */
    get class(): ClassDef | null;
    /**
     * The list of types of the arguments defined by this signature.
     *
     * This list includes the arguments defined by parent classes, and is in the
     * order returned by {@link Ast.FunctionDef.iterateArguments}.
     * @deprecated This property is deprecated because it is slow to compute if
     *             function inheritance is used, and not particularly useful.
     *             Use {@link Ast.FunctionDef.iterateArguments} instead.
     */
    get types(): Type[];
    /**
     * A map of required input arguments defined by this signature, and their type.
     *
     * The map includes the arguments defined by parent classes.
     * @deprecated This property is deprecated because it is slow to compute if
     *             function inheritance is used.
     *             Use {@link Ast.FunctionDef.iterateArguments} instead.
     */
    get inReq(): Type.TypeMap;
    /**
     * A map of optional input arguments defined by this signature, and their type.
     *
     * The map includes the arguments defined by parent classes.
     * @deprecated This property is deprecated because it is slow to compute if
     *             function inheritance is used.
     *             Use {@link Ast.FunctionDef.iterateArguments} instead.
     */
    get inOpt(): Type.TypeMap;
    /**
     * A map of output arguments defined by this signature, and their type.
     *
     * The map includes the arguments defined by parent classes.
     * @deprecated This property is deprecated because it is slow to compute if
     *             function inheritance is used.
     *             Use {@link Ast.FunctionDef.iterateArguments} instead.
     */
    get out(): Type.TypeMap;
    /**
     * The index of arguments in args.
     *.
     * @deprecated This property is deprecated and will not work properly for functions with inheritance
     */
    get index(): Record<string, number>;
    private _loadArguments;
    private _flattenCompoundArguments;
    private _flattenCompoundArgument;
    toString(): string;
    visit(visitor: NodeVisitor): void;
    /**
     * Whether the signature includes an argument with the given name.
     *
     * This method takes into account function extension.
     *
     * @param argname - the argument name
     * @return `true` if the argument is present on this or a parent signature
     */
    hasArgument(arg: string): boolean;
    /**
     * Retrieve the argument definition with the given name.
     *
     * This method takes into account function extension.
     *
     * @param argname - the argument name
     * @return the argument definition, or `undefined`
     *         if the argument does not exist
     */
    getArgument(argname: string): ArgumentDef | undefined;
    /**
     * Retrieve the type of the argument with the given name.
     *
     * This is a convenience method that combines {@link Ast.FunctionDef.getArgument}
     * and {@link Ast.ArgumentDef.type}.
     *
     * @param argname - the argument name
     * @return the argument type, or `undefined`
     *         if the argument does not exist
     */
    getArgType(argname: string): Type | undefined;
    /**
     * Retrieve the canonical form of the argument with the given name.
     *
     * This is a convenience method that combines {@link Ast.FunctionDef.getArgument}
     * and {@link Ast.ArgumentDef.canonical}.
     *
     * @param argname - the argument name
     * @return the argument's canonical form, or `undefined`
     *         if the argument does not exist
     */
    getArgCanonical(argname: string): string | undefined;
    /**
     * Retrieve the NL annotations of the argument with the given name.
     *
     * This is a convenience method that combines {@link Ast.FunctionDef.getArgument}
     * and {@link Ast.ArgumentDef.metadata}.
     *
     * @param argname - the argument name
     * @return the argument's NL annotations, or `undefined`
     *         if the argument does not exist
     */
    getArgMetadata(argname: string): NLAnnotationMap | undefined;
    /**
     * Check if the argument with the given name is an input.
     *
     * This is a convenience method that combines {@link Ast.FunctionDef.getArgument}
     * and {@link Ast.ArgumentDef.is_input}.
     *
     * @param argname - the argument name
     * @return whether the argument is an input, or `undefined`
     *         if the argument does not exist
     */
    isArgInput(argname: string): boolean | undefined;
    /**
     * Check if the argument with the given name is required.
     *
     * This is a convenience method that combines {@link Ast.FunctionDef.getArgument}
     * and {@link Ast.ArgumentDef.required}.
     *
     * @param argname - the argument name
     * @return whether the argument is required, or `undefined`
     *         if the argument does not exist
     */
    isArgRequired(argname: string): boolean | undefined;
    /**
     * Iterate all arguments in this signature.
     *
     * Iteration includes also arguments inherited from parent functions
     *
     * @param {Set} [returned=new Set] - a set of returned argument names to avoid duplicates
     */
    iterateArguments(returned?: Set<string>): Generator<ArgumentDef, void>;
    /**
     * Check if this expression signature has any input arguments.
     */
    hasAnyInputArg(): boolean;
    /**
     * Check if this expression signature has any output arguments.
     */
    hasAnyOutputArg(): boolean;
    private _flattenSubFunctionArguments;
    /**
     * Clone this expression signature into a new signature with the given arguments.
     *
     * This is an internal method called by {@link FunctionDef.clone}
     * and similar functions. Subclasses can override it to call the subclass's
     * constructor.
     *
     * @param {Ast.ArgumentDef[]} args - the arguments in the new signature
     * @param {boolean} flattened - whether the new signature should be flattened or it
     *        it should preserve the extension relation
     * @return {Ast.FunctionDef} a clone of this signature, with a new
     *         set of arguments.
     */
    private _cloneInternal;
    /**
     * Clone this function definition into a new definition with the same arguments.
     *
     * @return a clone of this definition
     */
    clone(): FunctionDef;
    /**
     * Add a new argument to this signature.
     *
     * This method does not mutate the instance, it returns a new instance with
     * the added argument.
     *
     * @param toAdd - the argument to add
     * @return a clone of this signature with a new argument
     */
    addArguments(toAdd: ArgumentDef[]): FunctionDef;
    /**
     * Remove an argument from this signature.
     *
     * This method does not mutate the instance, it returns a new instance without
     * the removed argument.
     *
     * @param {string} arg - the name of the argument to remove
     * @return {Ast.FunctionDef} a clone of this signature with one fewer argument
     */
    removeArgument(arg: string): FunctionDef;
    /**
     * Remove all arguments that do not match a predicate from this signature.
     *
     * This method does not mutate the instance, it returns a new instance with
     * only the arguments that pass the predicate.
     *
     * @param {Ast~ArgumentFilterCallback} filter - a filter callback
     * @return {Ast.FunctionDef} a clone of this signature
     */
    filterArguments(filter: ArgumentFilterCallback): FunctionDef;
    /**
     * Clone this expression signature into a signature of the given type.
     *
     * This is used during typechecking to convert a table into a stream.
     */
    asType(type: FunctionType): FunctionDef;
    toSource(): TokenStream;
    setClass(klass: ClassDef | null): void;
    removeDefaultProjection(): void;
    removeMinimalProjection(): void;
    private _setMinimalProjection;
    /**
     * All natural language annotations for this function
     * (canonical, confirmation, formatted).
     */
    get nl_annotations(): NLAnnotationMap;
    /**
     * Implementation annotations (e.g. "url", "poll_interval" or "json_key")
     *
     */
    get impl_annotations(): AnnotationMap;
    /**
     * Read and normalize an implementation annotation from this function definition.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation normalized value, or `undefined` if the
     *         annotation is not present
     */
    getImplementationAnnotation<T>(name: string): T | undefined;
    /**
     * Read a natural-language annotation from this function definition.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation value, or `undefined` if the
     *         annotation is not present
     */
    getNaturalLanguageAnnotation<T>(name: string): T | undefined;
    /**
     * The canonical form of this function.
     *
     * This should be preferred over accessing the `canonical` property
     * of {@link Ast.FunctionDef.metadata} because it will ensure
     * a canonical form exists even if the annotation is not present.
     */
    get canonical(): string | undefined;
    /**
     * The confirmation string for this function.
     *
     * This is a convenience property for accessing the `confirmation` property
     * of {@link Ast.FunctionDef.metadata}. It will return `undefined`
     * if the annotation is not present.
     */
    get confirmation(): string | undefined;
    /**
     * Iterate all bases of this function (including indirect bases)
     */
    iterateBaseFunctions(): IterableIterator<string>;
    /**
     * Read and normalize an annotation from this function definition.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation normalized value, or `undefined` if the
     *         annotation is not present
     * @deprecated getAnnotation is deprecated and should not be used. Use {@link Ast.FunctionDef.getImplementationAnnotation} instead.
     */
    getAnnotation<T>(name: string): T | undefined;
    /**
     * All natural language metadata for this function
     * (canonical, confirmation, formatted).
     * @deprecated metadata is deprecated and should not be used. Use {@link Ast.FunctionDef.nl_annotations} instead.
     */
    get metadata(): NLAnnotationMap;
    /**
     * Implementation annotations (e.g. "url", "poll_interval" or "json_key")
     * @deprecated annotations is deprecated and should not be used. Use {@link Ast.FunctionDef.impl_annotations} instead.
     */
    get annotations(): AnnotationMap;
}
