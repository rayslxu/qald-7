"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nlAnnotationsToSource = exports.toJSON = exports.implAnnotationsToSource = void 0;
const assert_1 = __importDefault(require("assert"));
const visitor_1 = __importDefault(require("./visitor"));
const tokenstream_1 = require("../new-syntax/tokenstream");
const syntax_api_1 = require("../syntax_api");
const list_1 = __importDefault(require("../utils/list"));
function implAnnotationsToSource(map, prefix = '\n') {
    let syntax = list_1.default.Nil;
    for (const key in map) {
        syntax = list_1.default.concat(syntax, prefix, '#[', key, '=', map[key].toSource(), ']');
    }
    return syntax;
}
exports.implAnnotationsToSource = implAnnotationsToSource;
function toJSON(value) {
    if (Array.isArray(value)) {
        return list_1.default.concat('[', list_1.default.join(value.map(toJSON), ','), ']');
    }
    else if (typeof value === 'object' && value !== null) {
        let list = list_1.default.singleton('{');
        let first = true;
        const object = value;
        for (const key in object) {
            const inner = object[key];
            if (first) {
                list = list_1.default.concat(list, '\n', '\t+');
                first = false;
            }
            else {
                list = list_1.default.concat(list, ',', '\n');
            }
            list = list_1.default.concat(list, key, '=', toJSON(inner));
        }
        if (first)
            list = list_1.default.concat(list, '}');
        else
            list = list_1.default.concat(list, '\n', '\t-', '}');
        return list;
    }
    else if (typeof value === 'string') {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('QUOTED_STRING', value));
    }
    else {
        return list_1.default.singleton(String(value));
    }
}
exports.toJSON = toJSON;
function nlAnnotationsToSource(map, prefix = '\n') {
    let syntax = list_1.default.Nil;
    for (const key of Object.keys(map)) {
        syntax = list_1.default.concat(syntax, prefix, '#_[', key, '=', toJSON(map[key]), ']');
    }
    return syntax;
}
exports.nlAnnotationsToSource = nlAnnotationsToSource;
/**
 * Base class of AST nodes.
 *
 */
class Node {
    /**
     * Construct a new AST node.
     *
     * @param location - the position of this node in the source code
     */
    constructor(location = null) {
        (0, assert_1.default)(location === null ||
            (typeof location.start === 'object' && typeof location.end === 'object'));
        this.location = location;
    }
    /**
     * Optimize this AST node.
     *
     * Optimization removes redundant operations and converts ThingTalk to canonical form.
     *
     * @returns {Ast~Node} the optimized node
     */
    optimize() {
        return this;
    }
    /**
     * Convert this AST node to a normalized surface form in ThingTalk.
     */
    prettyprint() {
        return (0, syntax_api_1.serialize)(this, syntax_api_1.SyntaxType.Normal);
    }
    iteratePrimitives(includeVarRef) {
        // we cannot yield from inside the visitor, so we buffer everything
        const buffer = [];
        const visitor = new class extends visitor_1.default {
            visitVarRefAction(node) {
                if (includeVarRef)
                    buffer.push(['action', node]);
                return true;
            }
            visitInvocationAction(node) {
                buffer.push(['action', node.invocation]);
                return true;
            }
            visitVarRefTable(node) {
                if (includeVarRef)
                    buffer.push(['query', node]);
                return true;
            }
            visitInvocationTable(node) {
                buffer.push(['query', node.invocation]);
                return true;
            }
            visitVarRefStream(node) {
                if (includeVarRef)
                    buffer.push(['stream', node]);
                return true;
            }
            visitFunctionCallExpression(node) {
                if (!includeVarRef)
                    return true;
                if (node.schema)
                    buffer.push([node.schema.functionType, node]);
                else
                    buffer.push(['expression', node]);
                return true;
            }
            visitInvocationExpression(node) {
                if (node.schema)
                    buffer.push([node.schema.functionType, node.invocation]);
                else
                    buffer.push(['expression', node.invocation]);
                return true;
            }
            visitExternalBooleanExpression(node) {
                buffer.push(['filter', node]);
                return true;
            }
        };
        this.visit(visitor);
        return buffer;
    }
}
exports.default = Node;
//# sourceMappingURL=base.js.map