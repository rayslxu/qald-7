import Node, { SourceRange, NLAnnotationMap, AnnotationMap, AnnotationSpec } from './base';
import { DeviceSelector, InputParam } from './invocation';
import { Statement } from './statement';
import { FunctionDef } from './function_def';
import { OldSlot, AbstractSlot } from './slots';
import NodeVisitor from './visitor';
import { TokenStream } from '../new-syntax/tokenstream';
export declare type ClassMember = FunctionDef | MixinImportStmt | EntityDef;
/**
 * The definition of a ThingTalk class.
 *
 */
export declare class ClassDef extends Statement {
    name: string;
    kind: string;
    extends: string[];
    imports: MixinImportStmt[];
    entities: EntityDef[];
    queries: Record<string, FunctionDef>;
    actions: Record<string, FunctionDef>;
    nl_annotations: NLAnnotationMap;
    impl_annotations: AnnotationMap;
    /**
     * If the class is an abstract class.
     */
    readonly is_abstract: boolean;
    /**
     * Construct a new class definition.
     *
     * @param location - the position of this node in the source code
     * @param kind - the class identifier in Thingpedia
     * @param _extends - parent classes (if any)
     * @param members - the class members including queries, actions, entities, imports
     * @param members.imports - import statements in this class
     * @param members.entities - entity declarations in this class
     * @param members.queries - query functions in this class
     * @param members.actions - action functions in this class
     * @param annotations - annotations of the class
     * @param annotations.nl - natural language annotations of the class (translatable annotations)
     * @param annotations.impl - implementation annotations of the class
     * @param options - additional options for the class
     * @param options.is_abstract - `true` if this is an abstract class which has no implementation
     */
    constructor(location: SourceRange | null, kind: string, _extends: string[] | null, members: {
        imports?: MixinImportStmt[];
        entities?: EntityDef[];
        queries?: Record<string, FunctionDef>;
        actions?: Record<string, FunctionDef>;
    }, annotations: AnnotationSpec, options?: {
        is_abstract?: boolean;
    });
    toSource(): TokenStream;
    iterateSlots(): Generator<OldSlot, void>;
    iterateSlots2(): Generator<DeviceSelector | AbstractSlot, void>;
    visit(visitor: NodeVisitor): void;
    private _adjustParentPointers;
    /**
     * Get a function defined in this class with the given type and name.
     *
     * @param {string} type - the function type, either `query` or `action`
     * @param {string} name - the function name
     * @return {module.Ast.FunctionDef|undefined} the function definition, or `undefined`
     *         if the function does not exist
     */
    getFunction(type: 'query' | 'action', name: string): FunctionDef | undefined;
    /**
     * Read and normalize an implementation annotation from this class.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation normalized value, or `undefined` if the
     *         annotation is not present
     */
    getImplementationAnnotation<T>(name: string): T | undefined;
    /**
     * Read a natural-language annotation from this class.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation value, or `undefined` if the
     *         annotation is not present
     */
    getNaturalLanguageAnnotation<T>(name: string): T | undefined;
    /**
     * Clone the class definition.
     *
     * @return {Ast.ClassDef} the cloned class definition
     */
    clone(): ClassDef;
    /**
     * The `loader` mixin for this class, if one is present
     *
     */
    get loader(): MixinImportStmt | undefined;
    /**
     * The `config` mixin for this class, if one is present
     *
     */
    get config(): MixinImportStmt | undefined;
    /**
     * The canonical form of this class.
     *
     * This is is the preferred property to use as a user visible name for devices of
     * this class. It will never be null or undefined: if the `#_[canonical]` annotation
     * is missing, a default will be computed from the class name.
     */
    get canonical(): string;
    /**
     * The natural language annotations of the class
     *
     * @deprecated metadata is deprecated. Use nl_annotations instead.
     */
    get metadata(): NLAnnotationMap;
    /**
     * The implementation annotations of the class
     *
     * @deprecated annotations is deprecated. Use impl_annotations instead.
     */
    get annotations(): AnnotationMap;
    /**
     * Read and normalize an annotation from this class.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation normalized value, or `undefined` if the
     *         annotation is not present
     * @deprecated getAnnotation is deprecated and should not be used. Use {@link Ast.ClassDef.getImplementationAnnotation} instead.
     */
    getAnnotation<T>(name: string): T | undefined;
}
/**
 * A `import` statement that imports a mixin inside a ThingTalk class.
 *
 * Mixins add implementation functionality to ThingTalk classes, such as specifying
 * how the class is loaded (which language, which format, which version of the SDK)
 * and how devices are configured.
 */
export declare class MixinImportStmt extends Node {
    facets: string[];
    module: string;
    in_params: InputParam[];
    /**
     * Construct a new mixin import statement.
     *
     * @param location - the position of this node in the source code
     * @param facets - which facets to import from the mixin (`config`, `auth`, `loader`, ...)
     * @param module - the mixin identifier to import
     * @param in_params - input parameters to pass to the mixin
     */
    constructor(location: SourceRange | null, facets: string[], module: string, in_params: InputParam[]);
    toSource(): TokenStream;
    clone(): MixinImportStmt;
    visit(visitor: NodeVisitor): void;
}
/**
 * An `entity` statement inside a ThingTalk class.
 *
 */
export declare class EntityDef extends Node {
    isEntityDef: boolean;
    /**
     * The entity name.
     */
    name: string;
    extends: string[];
    /**
     * The entity metadata (translatable annotations).
     */
    nl_annotations: NLAnnotationMap;
    /**
     * The entity annotations.
     */
    impl_annotations: AnnotationMap;
    /**
     * Construct a new entity declaration.
     *
     * @param location - the position of this node in the source code
     * @param name - the entity name (the part after the ':')
     * @param extends - the parent entity type, if any (this can be a fully qualified name with ':', or just the part after ':')
     * @param annotations - annotations of the entity type
     * @param [annotations.nl={}] - natural-language annotations (translatable annotations)
     * @param [annotations.impl={}] - implementation annotations
     */
    constructor(location: SourceRange | null, name: string, _extends: string[] | string | null, annotations: AnnotationSpec);
    toSource(): TokenStream;
    /**
     * Clone this entity and return a new object with the same properties.
     *
     * @return the new instance
     */
    clone(): EntityDef;
    /**
     * Read and normalize an implementation annotation from this entity definition.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation normalized value, or `undefined` if the
     *         annotation is not present
     */
    getImplementationAnnotation<T>(name: string): T | undefined;
    /**
     * Read a natural-language annotation from this entity definition.
     *
     * @param {string} name - the annotation name
     * @return {any|undefined} the annotation value, or `undefined` if the
     *         annotation is not present
     */
    getNaturalLanguageAnnotation(name: string): any | undefined;
    visit(visitor: NodeVisitor): void;
}
