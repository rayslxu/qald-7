"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Silei Xu <silei@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Invocation = exports.InputParam = exports.DeviceSelector = void 0;
const assert_1 = __importDefault(require("assert"));
const base_1 = __importDefault(require("./base"));
const function_def_1 = require("./function_def");
const values_1 = require("./values");
const slots_1 = require("./slots");
const list_1 = __importDefault(require("../utils/list"));
const array_equals_1 = __importDefault(require("./array_equals"));
/**
 * An expression that maps to one or more devices in Thingpedia.
 *
 * Selectors correspond to the `@`-device part of the ThingTalk code,
 * up to but not including the function name.
 *
 */
class DeviceSelector extends base_1.default {
    /**
     * Construct a new device selector.
     *
     * @param location - the position of this node in the source code
     * @param kind - the Thingpedia class ID
     * @param id - the unique ID of the device being selected, or null
     *                           to select devices according to the attributes, or
     *                           all devices if no attributes are specified
     * @param principal - reserved/deprecated, must be `null`
     * @param attributes - other attributes used to select a device, if ID is unspecified
     * @param [all=false] - operate on all devices that match the attributes, instead of
     *                                having the user choose
     */
    constructor(location, kind, id, principal, attributes = [], all = false) {
        super(location);
        (0, assert_1.default)(typeof kind === 'string');
        this.kind = kind;
        (0, assert_1.default)(typeof id === 'string' || id === null);
        this.id = id;
        (0, assert_1.default)(principal === null);
        this.principal = principal;
        this.attributes = attributes;
        this.all = all;
    }
    getAttribute(name) {
        for (const attr of this.attributes) {
            if (attr.name === name)
                return attr;
        }
        return undefined;
    }
    toSource() {
        this.attributes.sort((p1, p2) => {
            if (p1.name < p2.name)
                return -1;
            if (p1.name > p2.name)
                return 1;
            return 0;
        });
        const attributes = [];
        if (this.all) {
            attributes.push(list_1.default.concat('all', '=', 'true'));
        }
        else if (this.id && this.id !== this.kind) {
            // note: we omit the device ID if it is identical to the kind (which indicates there can only be
            // one device of this type in the system)
            // this reduces the amount of stuff we have to encode/predict for the common cases
            const name = this.attributes.find((attr) => attr.name === 'name');
            const id = new values_1.Value.Entity(this.id, 'tt:device_id', name ? name.value.toJS() : null);
            attributes.push(list_1.default.concat('id', '=', id.toSource()));
        }
        for (const attr of this.attributes) {
            if (attr.value.isUndefined)
                continue;
            if (attr.name === 'name' && this.id)
                continue;
            attributes.push(list_1.default.concat(attr.name, '=', attr.value.toSource()));
        }
        if (attributes.length === 0)
            return list_1.default.singleton('@' + this.kind);
        return list_1.default.concat('@' + this.kind, '(', list_1.default.join(attributes, ','), ')');
    }
    clone() {
        const attributes = this.attributes.map((attr) => attr.clone());
        return new DeviceSelector(this.location, this.kind, this.id, this.principal, attributes, this.all);
    }
    equals(other) {
        return other instanceof DeviceSelector &&
            this.kind === other.kind &&
            this.id === other.id &&
            (0, array_equals_1.default)(this.attributes, other.attributes) &&
            this.all === other.all;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitDeviceSelector(this)) {
            for (const attr of this.attributes)
                attr.visit(visitor);
        }
        visitor.exit(this);
    }
    toString() {
        return `Device(${this.kind}, ${this.id ? this.id : ''}, )`;
    }
}
exports.DeviceSelector = DeviceSelector;
/**
 * AST node corresponding to an input parameter passed to a function.
 */
class InputParam extends base_1.default {
    /**
     * Construct a new input parameter node.
     *
     * @param {Ast~SourceRange|null} location - the position of this node
     *        in the source code
     * @param {string} name - the input argument name
     * @param {Ast.Value} value - the value being passed
     */
    constructor(location, name, value) {
        super(location);
        this.isInputParam = true;
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(value instanceof values_1.Value);
        this.value = value;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitInputParam(this))
            this.value.visit(visitor);
        visitor.exit(this);
    }
    toSource() {
        return list_1.default.concat(this.name, '=', this.value.toSource());
    }
    clone() {
        return new InputParam(this.location, this.name, this.value.clone());
    }
    equals(other) {
        return this.name === other.name &&
            this.value.equals(other.value);
    }
    toString() {
        return `InputParam(${this.name}, ${this.value})`;
    }
}
exports.InputParam = InputParam;
/**
 * An invocation of a ThingTalk function.
 *
 */
class Invocation extends base_1.default {
    /**
     * Construct a new invocation.
     *
     * @param location - the position of this node in the source code
     * @param {Ast.DeviceSelector} selector - the selector choosing where the function is invoked
     * @param {string} channel - the function name
     * @param {Ast.InputParam[]} in_params - input parameters passed to the function
     * @param {Ast.FunctionDef|null} schema - type signature of the invoked function
     */
    constructor(location, selector, channel, in_params, schema) {
        super(location);
        this.isInvocation = true;
        this.__effectiveSelector = null;
        (0, assert_1.default)(selector instanceof DeviceSelector);
        this.selector = selector;
        (0, assert_1.default)(typeof channel === 'string');
        this.channel = channel;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
        (0, assert_1.default)(schema === null || schema instanceof function_def_1.FunctionDef);
        this.schema = schema;
    }
    toSource() {
        // filter out parameters that are required and undefined
        let filteredParams = this.in_params;
        if (this.schema) {
            const schema = this.schema;
            filteredParams = this.in_params.filter((ip) => {
                return !ip.value.isUndefined || !schema.isArgRequired(ip.name);
            });
        }
        return list_1.default.concat(this.selector.toSource(), '.', this.channel, '(', list_1.default.join(filteredParams.map((ip) => ip.toSource()), ','), ')');
    }
    clone() {
        const clone = new Invocation(this.location, this.selector.clone(), this.channel, this.in_params.map((p) => p.clone()), this.schema ? this.schema.clone() : null);
        clone.__effectiveSelector = this.__effectiveSelector;
        return clone;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitInvocation(this)) {
            this.selector.visit(visitor);
            for (const in_param of this.in_params)
                in_param.visit(visitor);
        }
        visitor.exit(this);
    }
    toString() {
        const in_params = this.in_params && this.in_params.length > 0 ? this.in_params.toString() : '';
        return `Invocation(${this.selector.toString()}, ${this.channel}, ${in_params}, )`;
    }
    /**
     * Iterate all slots (scalar value nodes) in this invocation.
     *
     * @param scope - available names for parameter passing
     * @deprecated Use {@link Ast.Invocation.iterateSlots2} instead.
     */
    *iterateSlots(scope) {
        yield [null, this.selector, this, {}];
        for (const in_param of this.in_params)
            yield [this.schema, in_param, this, scope];
        return [this, (0, slots_1.makeScope)(this)];
    }
    /**
     * Iterate all slots (scalar value nodes) in this invocation.
     *
     * @param {Object.<string, Ast~SlotScopeItem>} scope - available names for parameter passing
     */
    *iterateSlots2(scope) {
        if (this.selector instanceof DeviceSelector) {
            for (const attr of this.selector.attributes)
                yield new slots_1.DeviceAttributeSlot(this, attr);
            // note that we yield the selector after the device attributes
            // this way, almond-dialog-agent will first ask any question to slot-fill
            // the device attributes (if somehow it needs to) and then use the chosen
            // device attributes to choose the device
            yield this.selector;
        }
        return yield* (0, slots_1.iterateSlots2InputParams)(this, scope);
    }
}
exports.Invocation = Invocation;
//# sourceMappingURL=invocation.js.map