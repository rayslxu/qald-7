"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectValue = exports.ArgMapValue = exports.EventValue = exports.EnumValue = exports.EntityValue = exports.RecurrentTimeSpecificationValue = exports.RecurrentTimeRule = exports.TimeValue = exports.DateValue = exports.LocationValue = exports.CurrencyValue = exports.MeasureValue = exports.NumberValue = exports.StringValue = exports.BooleanValue = exports.ContextRefValue = exports.NullValue = exports.UndefinedValue = exports.FilterValue = exports.ArrayFieldValue = exports.ComputationValue = exports.VarRefValue = exports.ArrayValue = exports.Value = exports.RelativeTime = exports.AbsoluteTime = exports.Time = exports.WeekDayDate = exports.DatePiece = exports.DateEdge = exports.UnresolvedLocation = exports.RelativeLocation = exports.AbsoluteLocation = exports.Location = void 0;
const assert_1 = __importDefault(require("assert"));
const Units = __importStar(require("thingtalk-units"));
const type_1 = __importDefault(require("../type"));
const date_utils_1 = require("../utils/date_utils");
const base_1 = __importDefault(require("./base"));
const tokenstream_1 = require("../new-syntax/tokenstream");
const list_1 = __importDefault(require("../utils/list"));
const syntax_priority_1 = require("./syntax_priority");
const builtin = __importStar(require("../runtime/values"));
class Location {
}
exports.Location = Location;
Location.prototype.isAbsolute = false;
Location.prototype.isRelative = false;
Location.prototype.isUnresolved = false;
class AbsoluteLocation extends Location {
    constructor(lat, lon, display = null) {
        super();
        (0, assert_1.default)(typeof lat === 'number');
        this.lat = lat;
        (0, assert_1.default)(typeof lon === 'number');
        this.lon = lon;
        (0, assert_1.default)(typeof display === 'string' || display === null);
        this.display = display;
    }
    get latitude() {
        return this.lat;
    }
    get longitude() {
        return this.lon;
    }
    toEntity() {
        return { latitude: this.lat, longitude: this.lon, display: this.display };
    }
    toSource() {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('LOCATION', this.toEntity()));
    }
    toString() {
        return `Absolute(${this.lat}, ${this.lon}, ${this.display})`;
    }
    clone() {
        return new AbsoluteLocation(this.lat, this.lon, this.display);
    }
    equals(other) {
        return other instanceof AbsoluteLocation && this.lat === other.lat
            && this.lon === other.lon && this.display === other.display;
    }
}
exports.AbsoluteLocation = AbsoluteLocation;
AbsoluteLocation.prototype.isAbsolute = true;
Location.Absolute = AbsoluteLocation;
class RelativeLocation extends Location {
    constructor(relativeTag) {
        super();
        (0, assert_1.default)(typeof relativeTag === 'string');
        this.relativeTag = relativeTag;
    }
    toEntity() {
        throw new Error('Value is not an entity');
    }
    toSource() {
        return list_1.default.concat('$location', '.', this.relativeTag);
    }
    toString() {
        return `Relative(${this.relativeTag})`;
    }
    clone() {
        return new RelativeLocation(this.relativeTag);
    }
    equals(other) {
        return other instanceof RelativeLocation && this.relativeTag === other.relativeTag;
    }
}
exports.RelativeLocation = RelativeLocation;
RelativeLocation.prototype.isRelative = true;
Location.Relative = RelativeLocation;
class UnresolvedLocation extends Location {
    constructor(name) {
        super();
        this.name = name;
    }
    toEntity() {
        return { latitude: NaN, longitude: NaN, display: this.name };
    }
    toSource() {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('LOCATION', this.toEntity()));
    }
    toString() {
        return `Unresolved(${this.name})`;
    }
    clone() {
        return new UnresolvedLocation(this.name);
    }
    equals(other) {
        return other instanceof UnresolvedLocation && this.name === other.name;
    }
}
exports.UnresolvedLocation = UnresolvedLocation;
UnresolvedLocation.prototype.isUnresolved = true;
Location.Unresolved = UnresolvedLocation;
class DateEdge {
    constructor(edge, unit) {
        this.isDateEdge = true;
        (0, assert_1.default)(edge === 'start_of' || edge === 'end_of');
        this.edge = edge;
        (0, assert_1.default)(typeof unit === 'string');
        this.unit = unit;
    }
    toSource() {
        return list_1.default.concat('$' + this.edge, '(', this.unit, ')');
    }
    equals(other) {
        return other instanceof DateEdge && this.edge === other.edge && this.unit === other.unit;
    }
}
exports.DateEdge = DateEdge;
class DatePiece {
    constructor(year, month, day, time) {
        this.isDatePiece = true;
        (0, assert_1.default)((year !== null && year >= 0) || (month !== null && month > 0) || (day !== null && day > 0));
        this.year = year;
        if (year !== null && year >= 0 && year < 100) { // then assume 1950-2050
            if (year >= 50)
                this.year = 1900 + year;
            else
                this.year = 2000 + year;
        }
        this.month = month;
        this.day = day;
        this.time = time;
    }
    toSource() {
        let syntax = list_1.default.concat('new', 'Date', '(');
        if (this.year !== null)
            syntax = list_1.default.concat(syntax, new tokenstream_1.ConstantToken('NUMBER', this.year));
        syntax = list_1.default.concat(syntax, ',');
        if (this.month !== null)
            syntax = list_1.default.concat(syntax, new tokenstream_1.ConstantToken('NUMBER', this.month));
        syntax = list_1.default.concat(syntax, ',');
        if (this.day !== null)
            syntax = list_1.default.concat(syntax, new tokenstream_1.ConstantToken('NUMBER', this.day));
        if (this.time !== null) {
            syntax = list_1.default.concat(syntax, ',');
            syntax = list_1.default.concat(syntax, this.time.toSource());
        }
        syntax = list_1.default.concat(syntax, ')');
        return syntax;
    }
    equals(other) {
        if (!(other instanceof DatePiece))
            return false;
        if (!(this.year === other.year
            && this.month === other.month
            && this.day === other.day))
            return false;
        if (this.time === other.time)
            return true;
        if (this.time && other.time)
            return this.time.equals(other.time);
        return false;
    }
}
exports.DatePiece = DatePiece;
class WeekDayDate {
    constructor(weekday, time) {
        this.isWeekDayDate = true;
        (0, assert_1.default)(weekday === 'monday' ||
            weekday === 'tuesday' ||
            weekday === 'wednesday' ||
            weekday === 'thursday' ||
            weekday === 'friday' ||
            weekday === 'saturday' ||
            weekday === 'sunday');
        this.weekday = weekday;
        this.time = time;
    }
    toSource() {
        if (this.time !== null)
            return list_1.default.concat('new', 'Date', '(', 'enum', this.weekday, ',', this.time.toSource(), ')');
        else
            return list_1.default.concat('new', 'Date', '(', 'enum', this.weekday, ')');
    }
    equals(other) {
        return (other instanceof WeekDayDate && this.weekday === other.weekday
            && (this.time === other.time || !!(this.time && other.time && this.time.equals(other.time))));
    }
}
exports.WeekDayDate = WeekDayDate;
class Time {
}
exports.Time = Time;
Time.prototype.isAbsolute = false;
Time.prototype.isRelative = false;
class AbsoluteTime extends Time {
    constructor(hour, minute, second) {
        super();
        (0, assert_1.default)(typeof hour === 'number' && Number.isFinite(hour));
        this.hour = hour;
        (0, assert_1.default)(typeof minute === 'number' && Number.isFinite(minute));
        this.minute = minute;
        (0, assert_1.default)(typeof second === 'number' && Number.isFinite(second));
        this.second = second;
    }
    toEntity() {
        return { hour: this.hour, minute: this.minute, second: this.second };
    }
    toSource() {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('TIME', this.toEntity()));
    }
    clone() {
        return new AbsoluteTime(this.hour, this.minute, this.second);
    }
    equals(other) {
        return other instanceof AbsoluteTime && this.hour === other.hour
            && this.minute === other.minute && this.second === other.second;
    }
    static fromJS(v) {
        if (typeof v === 'string') {
            const [hourstr, minutestr, secondstr] = v.split(':');
            const hour = parseInt(hourstr);
            const minute = parseInt(minutestr);
            let second;
            if (secondstr === undefined)
                second = 0;
            else
                second = parseInt(secondstr);
            return new AbsoluteTime(hour, minute, second);
        }
        else {
            return new AbsoluteTime(v.hour, v.minute, v.second);
        }
    }
    toJS() {
        return new builtin.Time(this.hour, this.minute, this.second);
    }
}
exports.AbsoluteTime = AbsoluteTime;
AbsoluteTime.prototype.isAbsolute = true;
Time.Absolute = AbsoluteTime;
class RelativeTime extends Time {
    constructor(relativeTag) {
        super();
        (0, assert_1.default)(typeof relativeTag === 'string');
        this.relativeTag = relativeTag;
    }
    toEntity() {
        throw new Error('Value is not an entity');
    }
    toSource() {
        return list_1.default.concat('$time', '.', this.relativeTag);
    }
    clone() {
        return new RelativeTime(this.relativeTag);
    }
    equals(other) {
        return other instanceof RelativeTime && this.relativeTag === other.relativeTag;
    }
}
exports.RelativeTime = RelativeTime;
RelativeTime.prototype.isRelative = true;
Time.Relative = RelativeTime;
/**
 * An AST node that represents a scalar value.
 *
 * This could be a constant, a slot-filling placeholder, the name of a variable in scope,
 * a compound type expression (array or object literal) or a computation expression.
 *
 * Note that AST node representations are different from runtime representations
 * (in {@link Builtin}. AST nodes carry type information, can carry
 * additional information that might not be available at runtime, and can represent
 * unspecified or unresolved values. Code using the library to manipulate programs statically
 * will make use of this class, while code using the library to implement or call Thingpedia
 * functions will make use of the runtime representations.
 *
 */
class Value extends base_1.default {
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    /**
     * Convert a normalized JS value to the corresponding AST node.
     *
     * This is the inverse operation of {@link Ast.Value.toJS}.
     *
     * @param type - the ThingTalk type
     * @param v - the JS value to convert
     * @return the converted value
     */
    static fromJS(type, v) {
        if (type.isBoolean)
            return new Value.Boolean(v);
        if (type.isString)
            return new Value.String(String(v));
        if (type.isNumber)
            return new Value.Number(v);
        if (type.isCurrency) {
            if (typeof v === 'number')
                return new Value.Currency(v, 'usd');
            const o = v;
            return new Value.Currency(o.value, o.code);
        }
        if (type instanceof type_1.default.Entity) {
            if (typeof v === 'string')
                return new Value.Entity(v, type.type, null);
            const o = v;
            return new Value.Entity(o.value, type.type, o.display || null);
        }
        if (type instanceof type_1.default.Measure)
            return new Value.Measure(v, type.unit);
        if (type.isEnum)
            return new Value.Enum(v);
        if (type.isTime)
            return new Value.Time(AbsoluteTime.fromJS(v));
        if (type.isDate)
            return new Value.Date(v);
        if (type.isLocation) {
            const o = v;
            return new Value.Location(new Location.Absolute(o.y, o.x, o.display || null));
        }
        if (type.isRecurrentTimeSpecification) {
            const o = v;
            return new Value.RecurrentTimeSpecification(o.map((r) => RecurrentTimeRule.fromJS(r)));
        }
        if (type.isArgMap) {
            const map = {};
            Object.entries(v).forEach(([key, value]) => {
                map[key] = type_1.default.fromString(value);
            });
            return new Value.ArgMap(map);
        }
        if (type instanceof type_1.default.Array) {
            const array = [];
            v.forEach((elem) => {
                array.push(Value.fromJS(type.elem, elem));
            });
            return new Value.Array(array);
        }
        throw new TypeError('Invalid type ' + type);
    }
    /**
     * Convert a normalized JSON value to the corresponding AST node.
     *
     * This is similar to {@link Ast.Value.fromJS} but handles JSON
     * serialization of Date values.
     *
     * @param type - the ThingTalk type
     * @param v - the JSON value to convert
     * @return the converted value
     */
    static fromJSON(type, v) {
        if (type.isDate) {
            if (v === null)
                return new Value.Date(null);
            const date = new Date(v);
            return new Value.Date(date);
        }
        else {
            return Value.fromJS(type, v);
        }
    }
    /**
     * Check if this AST node represent concrete (compilable) value.
     *
     * Values that are not concrete require normalization by the dialog agent
     * (such as entity or location resolution) before a program using them
     * is compiled and executed.
     *
     * @return {boolean} whether the value is concrete
     */
    isConcrete() {
        return true;
    }
    /**
     * Check if this AST node represent a compile-time constant value.
     *
     * Certain expressions in ThingTalk must be constant.
     *
     * @return {boolean} whether the value is constant
     */
    isConstant() {
        return this.isConcrete();
    }
    /**
     * Normalize this AST value and convert it to JS-friendly representation.
     *
     * This converts the AST representation to something that can be passed to
     * a Thingpedia function. Note that the conversion is lossy and loses type
     * information.
     *
     * @return {any} the normlized value
     */
    toJS() {
        throw new Error('Value is not a constant');
    }
    /**
     * Convert this AST node to an entity that can be extracted from a sentence.
     */
    toEntity() {
        throw new Error('Value is not an entity');
    }
}
exports.Value = Value;
Value.prototype.isBoolean = false;
Value.prototype.isString = false;
Value.prototype.isNumber = false;
Value.prototype.isCurrency = false;
Value.prototype.isEntity = false;
Value.prototype.isMeasure = false;
Value.prototype.isEnum = false;
Value.prototype.isTime = false;
Value.prototype.isDate = false;
Value.prototype.isLocation = false;
Value.prototype.isRecurrentTimeSpecification = false;
Value.prototype.isArgMap = false;
Value.prototype.isArray = false;
Value.prototype.isObject = false;
Value.prototype.isVarRef = false;
Value.prototype.isEvent = false;
Value.prototype.isContextRef = false;
Value.prototype.isUndefined = false;
Value.prototype.isFilter = false;
Value.prototype.isArrayField = false;
Value.prototype.isComputation = false;
Value.prototype.isNull = false;
class ArrayValue extends Value {
    constructor(value, type = null) {
        super(null);
        (0, assert_1.default)(Array.isArray(value));
        this.value = value;
        (0, assert_1.default)(type === null || type instanceof type_1.default);
        this.type = type;
    }
    toSource() {
        return list_1.default.concat('[', list_1.default.join(this.value.map((v) => v.toSource()), ','), ']');
    }
    toString() {
        return `Array(${this.value})`;
    }
    clone() {
        return new ArrayValue(this.value.map((v) => v.clone()), this.type);
    }
    equals(other) {
        return other instanceof ArrayValue && this.value.length === other.value.length
            && this.value.every((v, i) => v.equals(other.value[i]));
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitValue(this) && visitor.visitArrayValue(this)) {
            for (const v of this.value)
                v.visit(visitor);
        }
        visitor.exit(this);
    }
    isConstant() {
        return this.value.every((v) => v.isConstant());
    }
    toJS() {
        return this.value.map((v) => v.toJS());
    }
    getType() {
        if (this.type)
            return this.type;
        return new type_1.default.Array(this.value.length ? this.value[0].getType() : type_1.default.Any);
    }
}
exports.ArrayValue = ArrayValue;
ArrayValue.prototype.isArray = true;
Value.Array = ArrayValue;
class VarRefValue extends Value {
    constructor(name, type = null) {
        super(null);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(type === null || type instanceof type_1.default);
        this.type = type;
    }
    toSource() {
        return list_1.default.join(this.name.split('.').map((n) => list_1.default.singleton(n)), '.');
    }
    toString() {
        return `VarRef(${this.name})`;
    }
    clone() {
        return new VarRefValue(this.name, this.type);
    }
    equals(other) {
        return other instanceof VarRefValue && this.name === other.name;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitVarRefValue(this);
        visitor.exit(this);
    }
    isConstant() {
        return this.name.startsWith('__const_');
    }
    getType() {
        if (this.type)
            return this.type;
        if (this.name.startsWith('__const_'))
            return typeForConstant(this.name);
        return type_1.default.Any;
    }
}
exports.VarRefValue = VarRefValue;
VarRefValue.prototype.isVarRef = true;
Value.VarRef = VarRefValue;
const OperatorPriority = {
    '+': syntax_priority_1.SyntaxPriority.Add,
    '-': syntax_priority_1.SyntaxPriority.Add,
    '*': syntax_priority_1.SyntaxPriority.Mul,
    '/': syntax_priority_1.SyntaxPriority.Mul,
    '%': syntax_priority_1.SyntaxPriority.Mul,
    '**': syntax_priority_1.SyntaxPriority.Exp
};
class ComputationValue extends Value {
    constructor(op, operands, overload = null, type = null) {
        super(null);
        (0, assert_1.default)(typeof op === 'string');
        this.op = op;
        (0, assert_1.default)(Array.isArray(operands));
        this.operands = operands;
        (0, assert_1.default)(overload === null || Array.isArray(overload));
        this.overload = overload;
        (0, assert_1.default)(type === null || type instanceof type_1.default);
        this.type = type;
    }
    get priority() {
        return OperatorPriority[this.op] || syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        const priority = OperatorPriority[this.op];
        if (priority === undefined) {
            // not an infix operator
            return list_1.default.concat(this.op, '(', list_1.default.join(this.operands.map((v) => v.toSource()), ','), ')');
        }
        (0, assert_1.default)(this.operands.length === 2);
        const [lhs, rhs] = this.operands;
        return list_1.default.concat((0, syntax_priority_1.addParenthesis)(priority, lhs.priority, lhs.toSource()), this.op, (0, syntax_priority_1.addParenthesis)(priority, rhs.priority, rhs.toSource()));
    }
    toString() {
        return `Computation(${this.op}, ${this.operands})`;
    }
    clone() {
        return new ComputationValue(this.op, this.operands.map((v) => v.clone()), this.overload, this.type);
    }
    equals(other) {
        return other instanceof ComputationValue && this.op === other.op &&
            this.operands.length === other.operands.length &&
            this.operands.every((op, i) => op.equals(other.operands[i]));
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitValue(this) && visitor.visitComputationValue(this)) {
            for (const v of this.operands)
                v.visit(visitor);
        }
        visitor.exit(this);
    }
    isConstant() {
        return false;
    }
    getType() {
        if (this.type)
            return this.type;
        return type_1.default.Any;
    }
}
exports.ComputationValue = ComputationValue;
ComputationValue.prototype.isComputation = true;
Value.Computation = ComputationValue;
class ArrayFieldValue extends Value {
    constructor(value, field, type = null, arg = null) {
        super(null);
        (0, assert_1.default)(value instanceof Value);
        this.value = value;
        (0, assert_1.default)(typeof field === 'string');
        this.field = field;
        (0, assert_1.default)(type === null || type instanceof type_1.default);
        this.type = type;
        this.arg = arg;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.ArrayField;
    }
    toSource() {
        return list_1.default.concat(this.field, 'of', (0, syntax_priority_1.addParenthesis)(this.priority, this.value.priority, this.value.toSource()));
    }
    toString() {
        return `ArrayField(${this.value}, ${this.field})`;
    }
    clone() {
        return new ArrayFieldValue(this.value.clone(), this.field, this.type, this.arg);
    }
    equals(other) {
        return other instanceof ArrayFieldValue && this.value.equals(other.value) &&
            this.field === other.field;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitValue(this) && visitor.visitArrayFieldValue(this))
            this.value.visit(visitor);
        visitor.exit(this);
    }
    isConstant() {
        return false;
    }
    toJS() {
        return this.value.toJS().map((el) => el[this.field]);
    }
    getType() {
        if (this.type)
            return this.type;
        return type_1.default.Any;
    }
}
exports.ArrayFieldValue = ArrayFieldValue;
ArrayFieldValue.prototype.isArrayField = true;
Value.ArrayField = ArrayFieldValue;
class FilterValue extends Value {
    constructor(value, filter, type = null) {
        super(null);
        (0, assert_1.default)(value instanceof Value);
        this.value = value;
        this.filter = filter;
        (0, assert_1.default)(type === null || type instanceof type_1.default);
        this.type = type;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Filter;
    }
    toSource() {
        // note: the filter is parenthesized if it is a lower priority than a comparison
        // (ie an "or" or "and")
        return list_1.default.concat((0, syntax_priority_1.addParenthesis)(this.priority, this.value.priority, this.value.toSource()), 'filter', (0, syntax_priority_1.addParenthesis)(syntax_priority_1.SyntaxPriority.Comp, this.filter.priority, this.filter.toSource()));
    }
    toString() {
        return `Filter(${this.value}, ${this.filter})`;
    }
    clone() {
        return new FilterValue(this.value.clone(), this.filter.clone(), this.type);
    }
    equals(other) {
        return other instanceof FilterValue && this.value.equals(other.value) &&
            this.filter.equals(other.filter);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitValue(this) && visitor.visitFilterValue(this))
            this.value.visit(visitor);
        visitor.exit(this);
    }
    isConstant() {
        return false;
    }
    getType() {
        if (this.type)
            return this.type;
        return type_1.default.Any;
    }
}
exports.FilterValue = FilterValue;
FilterValue.prototype.isFilter = true;
Value.Filter = FilterValue;
/**
 * A special placeholder for values that must be slot-filled.
 */
class UndefinedValue extends Value {
    constructor(local = true) {
        super(null);
        (0, assert_1.default)(local === true || local === false);
        this.local = local;
    }
    toSource() {
        return list_1.default.singleton('$?');
    }
    toString() {
        return `Undefined(${this.local})`;
    }
    clone() {
        return new UndefinedValue(this.local);
    }
    equals(other) {
        return other instanceof UndefinedValue && this.local === other.local;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitUndefinedValue(this);
        visitor.exit(this);
    }
    isConstant() {
        return false;
    }
    getType() {
        return type_1.default.Any;
    }
}
exports.UndefinedValue = UndefinedValue;
UndefinedValue.prototype.isUndefined = true;
Value.Undefined = UndefinedValue;
/**
 * A null value meaning that there is no value (for not null mainly)
 */
class NullValue extends Value {
    toSource() {
        return list_1.default.singleton('null');
    }
    toString() {
        return `null`;
    }
    clone() {
        return new NullValue();
    }
    equals(other) {
        return other instanceof NullValue;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitNullValue(this);
        visitor.exit(this);
    }
    getType() {
        return type_1.default.Any;
    }
}
exports.NullValue = NullValue;
NullValue.prototype.isNull = true;
Value.Null = NullValue;
class ContextRefValue extends Value {
    constructor(name, type) {
        super(null);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(type instanceof type_1.default);
        this.type = type;
    }
    toSource() {
        return list_1.default.concat('$context', '.', list_1.default.join(this.name.split('.').map((n) => list_1.default.singleton(n)), '.'), ':', this.type.toSource());
    }
    toString() {
        return `ContextRef(${this.name}, ${this.type})`;
    }
    clone() {
        return new ContextRefValue(this.name, this.type);
    }
    equals(other) {
        return other instanceof ContextRefValue && this.name === other.name;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitContextRefValue(this);
        visitor.exit(this);
    }
    isConstant() {
        return false;
    }
    isConcrete() {
        return false;
    }
    getType() {
        return this.type;
    }
}
exports.ContextRefValue = ContextRefValue;
ContextRefValue.prototype.isContextRef = true;
Value.ContextRef = ContextRefValue;
class BooleanValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(typeof value === 'boolean');
        this.value = value;
    }
    toSource() {
        return list_1.default.singleton(String(this.value));
    }
    toString() {
        return `Boolean(${this.value})`;
    }
    clone() {
        return new BooleanValue(this.value);
    }
    equals(other) {
        return other instanceof BooleanValue && this.value === other.value;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitBooleanValue(this);
        visitor.exit(this);
    }
    toJS() {
        return this.value;
    }
    getType() {
        return type_1.default.Boolean;
    }
}
exports.BooleanValue = BooleanValue;
BooleanValue.prototype.isBoolean = true;
Value.Boolean = BooleanValue;
class StringValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(typeof value === 'string');
        this.value = value;
    }
    toEntity() {
        return this.value;
    }
    toSource() {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('QUOTED_STRING', this.value));
    }
    toString() {
        return `String(${this.value})`;
    }
    clone() {
        return new StringValue(this.value);
    }
    equals(other) {
        return other instanceof StringValue && this.value === other.value;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitStringValue(this);
        visitor.exit(this);
    }
    toJS() {
        return this.value;
    }
    getType() {
        return type_1.default.String;
    }
}
exports.StringValue = StringValue;
StringValue.prototype.isString = true;
Value.String = StringValue;
class NumberValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(typeof value === 'number');
        this.value = value;
    }
    toEntity() {
        return this.value;
    }
    toSource() {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('NUMBER', this.value));
    }
    toString() {
        return `Number(${this.value})`;
    }
    clone() {
        return new NumberValue(this.value);
    }
    equals(other) {
        return other instanceof NumberValue && this.value === other.value;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitNumberValue(this);
        visitor.exit(this);
    }
    toJS() {
        return this.value;
    }
    getType() {
        return type_1.default.Number;
    }
}
exports.NumberValue = NumberValue;
NumberValue.prototype.isNumber = true;
Value.Number = NumberValue;
class MeasureValue extends Value {
    constructor(value, unit) {
        super(null);
        (0, assert_1.default)(typeof value === 'number');
        this.value = value;
        (0, assert_1.default)(typeof unit === 'string');
        this.unit = unit;
    }
    toEntity() {
        return { unit: this.unit, value: this.value };
    }
    toSource() {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('MEASURE', this.toEntity()));
    }
    toString() {
        return `Measure(${this.value}, ${this.unit})`;
    }
    clone() {
        return new MeasureValue(this.value, this.unit);
    }
    equals(other) {
        return other instanceof MeasureValue && this.value === other.value
            && this.unit === other.unit;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitMeasureValue(this);
        visitor.exit(this);
    }
    isConcrete() {
        return !this.unit.startsWith("default");
    }
    toJS() {
        return Units.transformToBaseUnit(this.value, this.unit);
    }
    getType() {
        return new type_1.default.Measure(this.unit);
    }
}
exports.MeasureValue = MeasureValue;
MeasureValue.prototype.isMeasure = true;
Value.Measure = MeasureValue;
class CurrencyValue extends Value {
    constructor(value, code) {
        super(null);
        (0, assert_1.default)(typeof value === 'number');
        this.value = value;
        (0, assert_1.default)(typeof code === 'string');
        this.code = code;
    }
    toEntity() {
        return { unit: this.code, value: this.value };
    }
    toSource() {
        return list_1.default.singleton(new tokenstream_1.ConstantToken('CURRENCY', this.toEntity()));
    }
    toString() {
        return `Currency(${this.value}, ${this.code})`;
    }
    clone() {
        return new CurrencyValue(this.value, this.code);
    }
    equals(other) {
        return other instanceof CurrencyValue && this.value === other.value
            && this.code === other.code;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitCurrencyValue(this);
        visitor.exit(this);
    }
    toJS() {
        return new builtin.Currency(this.value, this.code);
    }
    getType() {
        return type_1.default.Currency;
    }
}
exports.CurrencyValue = CurrencyValue;
CurrencyValue.prototype.isCurrency = true;
Value.Currency = CurrencyValue;
class LocationValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(value instanceof Location);
        this.value = value;
    }
    toEntity() {
        return this.value.toEntity();
    }
    toSource() {
        return this.value.toSource();
    }
    toString() {
        return `Location(${this.value})`;
    }
    clone() {
        return new LocationValue(this.value.clone());
    }
    equals(other) {
        return other instanceof LocationValue && this.value.equals(other.value);
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitLocationValue(this);
        visitor.exit(this);
    }
    isConstant() {
        // a relative location is considered a constant, even though it is not concrete
        return true;
    }
    isConcrete() {
        return this.value instanceof AbsoluteLocation;
    }
    toJS() {
        if (this.value instanceof AbsoluteLocation)
            return new builtin.Location(this.value.lat, this.value.lon, this.value.display);
        else
            throw new TypeError('Location ' + this + ' is unknown');
    }
    getType() {
        return type_1.default.Location;
    }
}
exports.LocationValue = LocationValue;
LocationValue.prototype.isLocation = true;
Value.Location = LocationValue;
function isValidDate(value) {
    return value instanceof Date
        || value instanceof DateEdge
        || value instanceof DatePiece
        || value instanceof WeekDayDate;
}
function dateEquals(a, b) {
    if (a === null)
        return b === null;
    if (a instanceof Date)
        return b instanceof Date && +a === +b;
    return a.equals(b);
}
function dateToSource(date) {
    if (date instanceof Date)
        return list_1.default.singleton(new tokenstream_1.ConstantToken('DATE', date));
    return date.toSource();
}
class DateValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(value === null || isValidDate(value));
        // a DatePiece with non-null year is actually a fully specified date
        if (value instanceof DatePiece && value.year !== null) {
            let hour = 0, minute = 0, second = 0;
            if (value.time) {
                hour = value.time.hour;
                minute = value.time.minute;
                second = value.time.second;
            }
            value = new Date(value.year, value.month !== null ? value.month - 1 : 0, value.day !== null ? value.day : 1, hour, minute, second);
        }
        this.value = value;
    }
    static now() {
        return new DateValue(null);
    }
    toEntity() {
        if (this.value instanceof Date)
            return this.value;
        else
            throw new Error('Value is not an entity');
    }
    toSource() {
        if (this.value === null)
            return list_1.default.singleton('$now');
        return dateToSource(this.value);
    }
    toString() {
        return `Date(${this.value})`;
    }
    clone() {
        return new DateValue(this.value);
    }
    equals(other) {
        if (!(other instanceof DateValue))
            return false;
        return dateEquals(this.value, other.value);
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitDateValue(this);
        visitor.exit(this);
    }
    normalize(timezone) {
        return new DateValue((0, date_utils_1.normalizeDate)(this.value, timezone));
    }
    toJS() {
        if (this.value instanceof Date)
            return this.value;
        throw new Error(`Value is not a constant date, must normalize first`);
    }
    getType() {
        return type_1.default.Date;
    }
}
exports.DateValue = DateValue;
DateValue.prototype.isDate = true;
Value.Date = DateValue;
class TimeValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(value instanceof Time);
        this.value = value;
    }
    toEntity() {
        return this.value.toEntity();
    }
    toSource() {
        return this.value.toSource();
    }
    toString() {
        return `Time(${this.value})`;
    }
    clone() {
        return new TimeValue(this.value.clone());
    }
    equals(other) {
        return other instanceof TimeValue && this.value.equals(other.value);
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitTimeValue(this);
        visitor.exit(this);
    }
    isConstant() {
        // a relative time is considered a constant, even though it is not concrete
        return true;
    }
    isConcrete() {
        return this.value instanceof AbsoluteTime;
    }
    toJS() {
        if (this.value instanceof AbsoluteTime)
            return this.value.toJS();
        else
            throw new TypeError('Time is unknown');
    }
    getType() {
        return type_1.default.Time;
    }
}
exports.TimeValue = TimeValue;
TimeValue.prototype.isTime = true;
Value.Time = TimeValue;
function checkAbsoluteDate(dateLike) {
    if (dateLike instanceof Date)
        return dateLike;
    throw new Error(`Date is not normalized`);
}
/**
 * An AST node representing a single rule for a recurrent event.
 *
 */
class RecurrentTimeRule extends base_1.default {
    constructor({ beginTime, endTime, interval = new MeasureValue(1, 'day'), frequency = 1, dayOfWeek = null, beginDate = null, endDate = null, subtract = false }) {
        super(null);
        (0, assert_1.default)(beginTime instanceof AbsoluteTime);
        (0, assert_1.default)(endTime instanceof AbsoluteTime);
        (0, assert_1.default)(interval instanceof MeasureValue);
        (0, assert_1.default)(typeof frequency === 'number');
        (0, assert_1.default)(dayOfWeek === null || typeof dayOfWeek === 'string');
        (0, assert_1.default)(beginDate === null || isValidDate(beginDate));
        (0, assert_1.default)(endDate === null || isValidDate(endDate));
        (0, assert_1.default)(typeof subtract === 'boolean');
        this.beginTime = beginTime;
        this.endTime = endTime;
        this.interval = interval;
        this.frequency = frequency;
        this.dayOfWeek = dayOfWeek;
        this.beginDate = beginDate;
        this.endDate = endDate;
        this.subtract = subtract;
    }
    toSource() {
        let src = list_1.default.concat('{', ' ', 'beginTime', '=', this.beginTime.toSource(), ',', 'endTime', '=', this.endTime.toSource());
        if (this.interval.value !== 1 || this.interval.unit !== 'day')
            src = list_1.default.concat(src, ',', 'interval', '=', this.interval.toSource());
        if (this.frequency !== 1)
            src = list_1.default.concat(src, ',', 'frequency', '=', new tokenstream_1.ConstantToken('NUMBER', this.frequency));
        if (this.dayOfWeek !== null)
            src = list_1.default.concat(src, ',', 'dayOfWeek', '=', 'enum', this.dayOfWeek);
        if (this.beginDate !== null)
            src = list_1.default.concat(src, ',', 'beginDate', '=', dateToSource(this.beginDate));
        if (this.endDate !== null)
            src = list_1.default.concat(src, ',', 'endDate', '=', dateToSource(this.endDate));
        if (this.subtract)
            src = list_1.default.concat(src, ',', 'subtract', '=', 'true');
        src = list_1.default.concat(src, ' ', '}');
        return src;
    }
    toString() {
        return `RecurrentTimeRule(${this.subtract ? 'subtract' : 'add'} ${this.beginTime} -- ${this.endTime}; ${this.frequency} every ${this.interval}; from ${this.beginDate} to ${this.endDate})`;
    }
    clone() {
        return new RecurrentTimeRule(this);
    }
    equals(other) {
        return this.beginTime.equals(other.beginTime) &&
            this.endTime.equals(other.endTime) &&
            this.interval.equals(other.interval) &&
            this.frequency === other.frequency &&
            this.dayOfWeek === other.dayOfWeek &&
            dateEquals(this.beginDate, other.beginDate) &&
            dateEquals(this.endDate, other.endDate);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitRecurrentTimeRule(this))
            this.interval.visit(visitor);
        visitor.exit(this);
    }
    static fromJS(v) {
        return new RecurrentTimeRule({
            beginTime: AbsoluteTime.fromJS(v.beginTime),
            endTime: AbsoluteTime.fromJS(v.endTime),
            interval: new MeasureValue(v.interval, 'ms'),
            frequency: v.frequency,
            dayOfWeek: v.dayOfWeek !== null ? ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'][v.dayOfWeek] : null,
            beginDate: v.beginDate,
            endDate: v.endDate,
            subtract: v.subtract,
        });
    }
    normalize(timezone) {
        return new RecurrentTimeRule({
            beginTime: this.beginTime,
            endTime: this.endTime,
            interval: this.interval,
            frequency: this.frequency,
            dayOfWeek: this.dayOfWeek,
            beginDate: this.beginDate ? (0, date_utils_1.normalizeDate)(this.beginDate, timezone) : null,
            endDate: this.endDate ? (0, date_utils_1.normalizeDate)(this.endDate, timezone) : null,
            subtract: this.subtract
        });
    }
    toJS() {
        return new builtin.RecurrentTimeRule({
            beginTime: this.beginTime.toJS(),
            endTime: this.endTime.toJS(),
            interval: this.interval.toJS(),
            frequency: this.frequency,
            dayOfWeek: this.dayOfWeek ? ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'].indexOf(this.dayOfWeek) : null,
            beginDate: this.beginDate ? checkAbsoluteDate(this.beginDate) : null,
            endDate: this.endDate ? checkAbsoluteDate(this.endDate) : null,
            subtract: this.subtract
        });
    }
}
exports.RecurrentTimeRule = RecurrentTimeRule;
class RecurrentTimeSpecificationValue extends Value {
    constructor(rules) {
        super(null);
        this.rules = rules;
    }
    toSource() {
        return list_1.default.concat('new', 'RecurrentTimeSpecification', '(', list_1.default.join(this.rules.map((r) => r.toSource()), ','), ')');
    }
    toString() {
        return `RecurrentTimeSpec([${this.rules.join(', ')}])`;
    }
    clone() {
        return new RecurrentTimeSpecificationValue(this.rules.map((r) => r.clone()));
    }
    equals(other) {
        return other instanceof RecurrentTimeSpecificationValue
            && this.rules.length === other.rules.length
            && this.rules.every((v, i) => v.equals(other.rules[i]));
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitValue(this) && visitor.visitRecurrentTimeSpecificationValue(this)) {
            for (const rule of this.rules)
                rule.visit(visitor);
        }
        visitor.exit(this);
    }
    normalize(timezone) {
        return new RecurrentTimeSpecificationValue(this.rules.map((r) => r.normalize(timezone)));
    }
    toJS() {
        return this.rules.map((r) => r.toJS());
    }
    getType() {
        return type_1.default.RecurrentTimeSpecification;
    }
}
exports.RecurrentTimeSpecificationValue = RecurrentTimeSpecificationValue;
RecurrentTimeSpecificationValue.prototype.isRecurrentTimeSpecification = true;
Value.RecurrentTimeSpecification = RecurrentTimeSpecificationValue;
class EntityValue extends Value {
    constructor(value, type, display = null) {
        super(null);
        (0, assert_1.default)(value === null || typeof value === 'string');
        this.value = value;
        (0, assert_1.default)(typeof type === 'string');
        this.type = type;
        (0, assert_1.default)(display === null || typeof display === 'string');
        this.display = display;
    }
    toEntity() {
        if (!this.value)
            return { value: this.value, display: this.display };
        switch (this.type) {
            case 'tt:picture':
            case 'tt:username':
            case 'tt:hashtag':
            case 'tt:url':
            case 'tt:phone_number':
            case 'tt:email_address':
            case 'tt:path_name':
                return this.value;
            default:
                return { value: this.value, display: this.display };
        }
    }
    toSource() {
        if (!this.value)
            return list_1.default.singleton(new tokenstream_1.ConstantToken('GENERIC_ENTITY', this));
        switch (this.type) {
            case 'tt:picture':
                return list_1.default.singleton(new tokenstream_1.ConstantToken('PICTURE', this.value));
            case 'tt:username':
                return list_1.default.singleton(new tokenstream_1.ConstantToken('USERNAME', this.value));
            case 'tt:hashtag':
                return list_1.default.singleton(new tokenstream_1.ConstantToken('HASHTAG', this.value));
            case 'tt:url':
                return list_1.default.singleton(new tokenstream_1.ConstantToken('URL', this.value));
            case 'tt:phone_number':
                return list_1.default.singleton(new tokenstream_1.ConstantToken('PHONE_NUMBER', this.value));
            case 'tt:email_address':
                return list_1.default.singleton(new tokenstream_1.ConstantToken('EMAIL_ADDRESS', this.value));
            case 'tt:path_name':
                return list_1.default.singleton(new tokenstream_1.ConstantToken('PATH_NAME', this.value));
            default:
                return list_1.default.singleton(new tokenstream_1.ConstantToken('GENERIC_ENTITY', this));
        }
    }
    toString() {
        return `Entity(${this.value}, ${this.type}, ${this.display})`;
    }
    clone() {
        return new EntityValue(this.value, this.type, this.display);
    }
    equals(other) {
        return other instanceof EntityValue && this.value === other.value && this.type === other.type;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitEntityValue(this);
        visitor.exit(this);
    }
    isConcrete() {
        return this.value !== null;
    }
    toJS() {
        (0, assert_1.default)(this.value !== null);
        return new builtin.Entity(this.value, this.display);
    }
    getType() {
        return new type_1.default.Entity(this.type);
    }
}
exports.EntityValue = EntityValue;
EntityValue.prototype.isEntity = true;
Value.Entity = EntityValue;
class EnumValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(typeof value === 'string');
        this.value = value;
    }
    toSource() {
        return list_1.default.concat('enum', this.value);
    }
    toString() {
        return `Enum(${this.value})`;
    }
    clone() {
        return new EnumValue(this.value);
    }
    equals(other) {
        return other instanceof EnumValue && this.value === other.value;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitEnumValue(this);
        visitor.exit(this);
    }
    toJS() {
        return this.value;
    }
    getType() {
        return new type_1.default.Enum([this.value, '*']);
    }
}
exports.EnumValue = EnumValue;
EnumValue.prototype.isEnum = true;
Value.Enum = EnumValue;
class EventValue extends Value {
    constructor(name) {
        super(null);
        (0, assert_1.default)(name === null || typeof name === 'string');
        this.name = name;
    }
    toSource() {
        if (this.name === null)
            return list_1.default.singleton('$result');
        else
            return list_1.default.concat('$' + this.name);
    }
    toString() {
        return `Event(${this.name})`;
    }
    clone() {
        return new EventValue(this.name);
    }
    equals(other) {
        return other instanceof EventValue && this.name === other.name;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitEventValue(this);
        visitor.exit(this);
    }
    isConstant() {
        return false;
    }
    getType() {
        switch (this.name) {
            case 'type':
                return new type_1.default.Entity('tt:function');
            case 'program_id':
                return new type_1.default.Entity('tt:program_id');
            case 'source':
                return new type_1.default.Entity('tt:contact');
            default:
                return type_1.default.String;
        }
    }
}
exports.EventValue = EventValue;
EventValue.prototype.isEvent = true;
Value.Event = EventValue;
class ArgMapValue extends Value {
    constructor(value) {
        super(null);
        (0, assert_1.default)(typeof value === 'object');
        this.value = value;
    }
    toSource() {
        return list_1.default.concat('new', 'ArgMap', '(', list_1.default.join(Object.entries(this.value).map(([name, type]) => list_1.default.concat(name, ':' + type.toString())), ','), ')');
    }
    toString() {
        return `ArgMap(${this.value})`;
    }
    clone() {
        const clone = {};
        for (const key in this.value)
            clone[key] = this.value[key];
        return new ArgMapValue(clone);
    }
    equals(other) {
        if (!(other instanceof ArgMapValue))
            return false;
        const k1 = Object.keys(this.value);
        const k2 = Object.keys(other.value);
        if (k1.length !== k2.length)
            return false;
        for (const key of k1) {
            if (!other.value[key] || this.value[key].equals(other.value[key]))
                return false;
        }
        return true;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitValue(this) && visitor.visitArgMapValue(this);
        visitor.exit(this);
    }
    toJS() {
        return this.value;
    }
    getType() {
        return type_1.default.ArgMap;
    }
}
exports.ArgMapValue = ArgMapValue;
ArgMapValue.prototype.isArgMap = true;
Value.ArgMap = ArgMapValue;
class ObjectValue extends Value {
    constructor(value, type = null) {
        super(null);
        (0, assert_1.default)(typeof value === 'object');
        this.value = value;
        (0, assert_1.default)(type === null || type instanceof type_1.default);
        this.type = type;
    }
    toSource() {
        const entries = Object.entries(this.value);
        if (entries.length > 0) {
            return list_1.default.concat('{', ' ', list_1.default.join(entries.map(([name, value]) => list_1.default.concat(name, '=', value.toSource())), ','), ' ', '}');
        }
        else {
            return list_1.default.concat('{', '}');
        }
    }
    toString() {
        return `Object(${this.value})`;
    }
    clone() {
        const clone = {};
        for (const key in this.value)
            clone[key] = this.value[key].clone();
        return new ObjectValue(clone, this.type);
    }
    equals(other) {
        if (!(other instanceof ObjectValue))
            return false;
        const k1 = Object.keys(this.value);
        const k2 = Object.keys(other.value);
        if (k1.length !== k2.length)
            return false;
        for (const key of k1) {
            if (!other.value[key] || this.value[key].equals(other.value[key]))
                return false;
        }
        return true;
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitValue(this) && visitor.visitObjectValue(this)) {
            for (const key in this.value)
                this.value[key].visit(visitor);
        }
        visitor.exit(this);
    }
    isConstant() {
        return Object.values(this.value).every((v) => v.isConstant());
    }
    toJS() {
        const obj = {};
        Object.entries(this.value).forEach(([key, value]) => {
            obj[key] = value.toJS();
        });
        return obj;
    }
    getType() {
        if (this.type)
            return this.type;
        return type_1.default.Object;
    }
}
exports.ObjectValue = ObjectValue;
ObjectValue.prototype.isObject = true;
Value.Object = ObjectValue;
function unescape(symbol) {
    return symbol.replace(/_([0-9a-fA-Z]{2}|_)/g, (match, ch) => {
        if (ch === '_')
            return ch;
        return String.fromCharCode(parseInt(ch, 16));
    });
}
const TYPES = {
    QUOTED_STRING: type_1.default.String,
    NUMBER: type_1.default.Number,
    CURRENCY: type_1.default.Currency,
    DURATION: new type_1.default.Measure('ms'),
    LOCATION: type_1.default.Location,
    DATE: type_1.default.Date,
    TIME: type_1.default.Time,
    EMAIL_ADDRESS: new type_1.default.Entity('tt:email_address'),
    PHONE_NUMBER: new type_1.default.Entity('tt:phone_number'),
    HASHTAG: new type_1.default.Entity('tt:hashtag'),
    USERNAME: new type_1.default.Entity('tt:username'),
    URL: new type_1.default.Entity('tt:url'),
    PATH_NAME: new type_1.default.Entity('tt:path_name'),
};
function entityTypeToTTType(entityType) {
    if (entityType.startsWith('GENERIC_ENTITY_'))
        return new type_1.default.Entity(entityType.substring('GENERIC_ENTITY_'.length));
    else if (entityType.startsWith('MEASURE_'))
        return new type_1.default.Measure(entityType.substring('MEASURE_'.length));
    else
        return TYPES[entityType];
}
function typeForConstant(name) {
    let measure = /__const_NUMBER_([0-9]+)__([a-z0-9A-Z]+)/.exec(name);
    if (measure !== null)
        return new type_1.default.Measure(measure[2]);
    measure = /__const_MEASURE__([a-z0-9A-Z]+)_([0-9]+)/.exec(name);
    if (measure !== null)
        return new type_1.default.Measure(measure[1]);
    const underscoreindex = name.lastIndexOf('_');
    const entitytype = unescape(name.substring('__const_'.length, underscoreindex));
    const type = entityTypeToTTType(entitytype);
    if (!type)
        throw new TypeError(`Invalid __const variable ${name}`);
    return type;
}
//# sourceMappingURL=values.js.map