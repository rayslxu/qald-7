"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2019-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoinExpression = exports.ChainExpression = exports.SliceExpression = exports.IndexExpression = exports.SortExpression = exports.AggregationExpression = exports.AliasExpression = exports.ProjectionExpression2 = exports.ProjectionElement = exports.ProjectionExpression = exports.BooleanQuestionExpression = exports.MonitorExpression = exports.FilterExpression = exports.InvocationExpression = exports.FunctionCallExpression = exports.Expression = void 0;
const assert_1 = __importDefault(require("assert"));
const base_1 = __importDefault(require("./base"));
const invocation_1 = require("./invocation");
const boolean_expression_1 = require("./boolean_expression");
const legacy = __importStar(require("./legacy"));
const values_1 = require("./values");
const slots_1 = require("./slots");
const type_1 = __importDefault(require("../type"));
const list_1 = __importDefault(require("../utils/list"));
const syntax_priority_1 = require("./syntax_priority");
const array_equals_1 = __importDefault(require("./array_equals"));
const utils_1 = require("../utils");
const errors_1 = require("../utils/errors");
function primitiveArrayEquals(a1, a2) {
    if (a1 === a2)
        return true;
    if (!a1 || !a2)
        return false;
    if (a1.length !== a2.length)
        return false;
    for (let i = 0; i < a1.length; i++) {
        if (a1[i] !== a2[i])
            return false;
    }
    return true;
}
/**
 * A stream, table, or action expression.
 */
class Expression extends base_1.default {
    constructor(location, schema) {
        super(location);
        this.schema = schema;
    }
    optimize() {
        return this;
    }
}
exports.Expression = Expression;
// move parameter-passing from regular parameters to join parameters
// when converting back to the legacy AST nodes
function moveInputParams(in_params, into_params, scope_params) {
    return in_params.filter((ip) => {
        if ((ip.value instanceof values_1.VarRefValue && !scope_params.includes(ip.value.name) && !ip.value.name.startsWith('__const_')) || ip.value.isEvent) {
            into_params.push(ip);
            return false;
        }
        else {
            return true;
        }
    });
}
class FunctionCallExpression extends Expression {
    constructor(location, name, in_params, schema) {
        super(location, schema);
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
        (0, assert_1.default)(Array.isArray(in_params));
        this.in_params = in_params;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toString() {
        const in_params = this.in_params && this.in_params.length > 0 ? this.in_params.toString() : '';
        return `FunctionCallExpression(${this.name}, ${in_params})`;
    }
    toSource() {
        return list_1.default.concat(this.name, '(', list_1.default.join(this.in_params.map((ip) => ip.toSource()), ','), ')');
    }
    equals(other) {
        return other instanceof FunctionCallExpression &&
            this.name === other.name &&
            (0, array_equals_1.default)(this.in_params, other.in_params);
    }
    toLegacy(into_params = [], scope_params = []) {
        const schema = this.schema;
        if (schema.functionType === 'stream') {
            if (this.name === 'timer') {
                const base = this.in_params.find((ip) => ip.name === 'base');
                const interval = this.in_params.find((ip) => ip.name === 'interval');
                const frequency = this.in_params.find((ip) => ip.name === 'frequency');
                return new legacy.TimerStream(this.location, base.value, interval.value, frequency ? frequency.value : null, this.schema);
            }
            else if (this.name === 'attimer') {
                const time = this.in_params.find((ip) => ip.name === 'time');
                const expiration_date = this.in_params.find((ip) => ip.name === 'expiration_date');
                let timevalue;
                if (time.value instanceof values_1.Value.Array)
                    timevalue = time.value.value;
                else
                    timevalue = [time.value];
                return new legacy.AtTimerStream(this.location, timevalue, expiration_date ? expiration_date.value : null, this.schema);
            }
            else {
                return new legacy.VarRefStream(this.location, this.name, this.in_params, this.schema);
            }
        }
        else if (schema.functionType === 'query') {
            return new legacy.VarRefTable(this.location, this.name, moveInputParams(this.in_params, into_params, scope_params), this.schema);
        }
        else {
            return new legacy.VarRefAction(this.location, this.name, moveInputParams(this.in_params, into_params, scope_params), this.schema);
        }
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitFunctionCallExpression(this)) {
            for (const in_param of this.in_params)
                in_param.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new FunctionCallExpression(this.location, this.name, this.in_params.map((p) => p.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        for (const in_param of this.in_params)
            yield [this.schema, in_param, this, scope];
        return [this, (0, slots_1.makeScope)(this)];
    }
    *iterateSlots2(scope) {
        return yield* (0, slots_1.iterateSlots2InputParams)(this, scope);
    }
}
exports.FunctionCallExpression = FunctionCallExpression;
class InvocationExpression extends Expression {
    constructor(location, invocation, schema) {
        super(location, schema);
        (0, assert_1.default)(invocation instanceof invocation_1.Invocation);
        this.invocation = invocation;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        return this.invocation.toSource();
    }
    equals(other) {
        return other instanceof InvocationExpression &&
            this.invocation.selector.equals(other.invocation.selector) &&
            this.invocation.channel === other.invocation.channel &&
            (0, array_equals_1.default)(this.invocation.in_params, other.invocation.in_params);
    }
    toLegacy(into_params = [], scope_params = []) {
        const schema = this.schema;
        (0, assert_1.default)(schema.functionType !== 'stream');
        if (schema.functionType === 'query') {
            const clone = this.invocation.clone();
            clone.in_params = moveInputParams(clone.in_params, into_params, scope_params);
            return new legacy.InvocationTable(this.location, clone, this.schema);
        }
        else {
            return new legacy.InvocationAction(this.location, this.invocation, this.schema);
        }
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitInvocationExpression(this))
            this.invocation.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new InvocationExpression(this.location, this.invocation.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.invocation.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.invocation.iterateSlots2(scope);
    }
}
exports.InvocationExpression = InvocationExpression;
class FilterExpression extends Expression {
    constructor(location, expression, filter, schema) {
        super(location, schema);
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        (0, assert_1.default)(filter instanceof boolean_expression_1.BooleanExpression);
        this.filter = filter;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Filter;
    }
    toSource() {
        return list_1.default.concat((0, syntax_priority_1.addParenthesis)(this.priority, this.expression.priority, this.expression.toSource()), 'filter', this.filter.toSource());
    }
    equals(other) {
        return other instanceof FilterExpression &&
            this.expression.equals(other.expression) &&
            this.filter.equals(other.filter);
    }
    toLegacy(into_params = [], scope_params = []) {
        const schema = this.schema;
        (0, assert_1.default)(schema.functionType !== 'action');
        if (schema.functionType === 'query')
            return new legacy.FilteredTable(this.location, this.expression.toLegacy(into_params, scope_params), this.filter, this.schema);
        else
            return new legacy.EdgeFilterStream(this.location, this.expression.toLegacy(into_params, scope_params), this.filter, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitFilterExpression(this)) {
            this.expression.visit(visitor);
            this.filter.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new FilterExpression(this.location, this.expression.clone(), this.filter.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, newScope] = yield* this.expression.iterateSlots(scope);
        yield* this.filter.iterateSlots(this.expression.schema, prim, newScope);
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, newScope] = yield* this.expression.iterateSlots2(scope);
        yield* this.filter.iterateSlots2(this.expression.schema, prim, newScope);
        return [prim, newScope];
    }
}
exports.FilterExpression = FilterExpression;
class MonitorExpression extends Expression {
    constructor(location, expression, args, schema) {
        super(location, schema);
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        (0, assert_1.default)(args === null || (Array.isArray(args) && args.length > 0));
        this.args = args;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        if (this.args === null) {
            return list_1.default.concat('monitor', '(', this.expression.toSource(), ')');
        }
        else {
            return list_1.default.concat('monitor', '(', list_1.default.join(this.args.map((a) => list_1.default.singleton(a)), ','), 'of', this.expression.toSource(), ')');
        }
    }
    equals(other) {
        return other instanceof MonitorExpression &&
            this.expression.equals(other.expression) &&
            primitiveArrayEquals(this.args, other.args);
    }
    toLegacy(into_params = [], scope_params = []) {
        const el = this.expression.toLegacy(into_params, scope_params);
        (0, assert_1.default)(el instanceof legacy.Table);
        return new legacy.MonitorStream(this.location, el, this.args, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitMonitorExpression(this))
            this.expression.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new MonitorExpression(this.location, this.expression.clone(), this.args ? this.args.map((a) => a) : null, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.expression.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.expression.iterateSlots2(scope);
    }
}
exports.MonitorExpression = MonitorExpression;
class BooleanQuestionExpression extends Expression {
    constructor(location, expression, booleanExpression, schema) {
        super(location, schema);
        this.expression = expression;
        this.booleanExpression = booleanExpression;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Projection;
    }
    toSource() {
        return list_1.default.concat('[', this.booleanExpression.toSource(), ']', 'of', (0, syntax_priority_1.addParenthesis)(this.priority, this.expression.priority, this.expression.toSource()));
    }
    equals(other) {
        return other instanceof BooleanQuestionExpression &&
            this.expression.equals(other.expression) &&
            this.booleanExpression.equals(other.booleanExpression);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitBooleanQuestionExpression(this)) {
            this.expression.visit(visitor);
            this.booleanExpression.visit(visitor);
        }
        visitor.exit(this);
    }
    toLegacy(into_params = [], scope_params = []) {
        throw new errors_1.UnserializableError('Boolean question expression');
    }
    clone() {
        return new BooleanQuestionExpression(this.location, this.expression.clone(), this.booleanExpression.clone(), this.schema);
    }
    *iterateSlots(scope) {
        const [prim, newScope] = yield* this.expression.iterateSlots(scope);
        yield* this.booleanExpression.iterateSlots(this.expression.schema, prim, newScope);
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, newScope] = yield* this.expression.iterateSlots2(scope);
        yield* this.booleanExpression.iterateSlots2(this.expression.schema, prim, newScope);
        return [prim, newScope];
    }
}
exports.BooleanQuestionExpression = BooleanQuestionExpression;
class ProjectionExpression extends Expression {
    constructor(location, expression, args, computations, aliases, schema) {
        super(location, schema);
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        (0, assert_1.default)(Array.isArray(args));
        // if there is a *, it's the only name projected
        (0, assert_1.default)(args.every((x) => x !== '*') || args.length === 1);
        this.args = args;
        this.computations = computations;
        this.aliases = aliases;
        (0, assert_1.default)(this.args.length > 0 || this.computations.length > 0);
        (0, assert_1.default)(this.computations.length === this.aliases.length);
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Projection;
    }
    toSource() {
        const allprojections = this.args.map((a) => list_1.default.join(a.split('.').map((n) => list_1.default.singleton(n)), '.'));
        for (let i = 0; i < this.computations.length; i++) {
            const value = this.computations[i];
            const alias = this.aliases[i];
            if (alias)
                allprojections.push(list_1.default.concat(value.toSource(), 'as', alias));
            else
                allprojections.push(value.toSource());
        }
        return list_1.default.concat('[', list_1.default.join(allprojections, ','), ']', 'of', (0, syntax_priority_1.addParenthesis)(this.priority, this.expression.priority, this.expression.toSource()));
    }
    equals(other) {
        return other instanceof ProjectionExpression &&
            this.expression.equals(other.expression) &&
            primitiveArrayEquals(this.args, other.args) &&
            (0, array_equals_1.default)(this.computations, other.computations);
    }
    toLegacy(into_params = [], scope_params = []) {
        const schema = this.schema;
        (0, assert_1.default)(schema.functionType !== 'action');
        const inner = this.expression.toLegacy(into_params, scope_params);
        const names = this.args.slice();
        if (schema.functionType === 'query') {
            let table = inner;
            if (this.computations.length > 0) {
                for (let i = 0; i < this.computations.length; i++) {
                    const value = this.computations[i];
                    const alias = this.aliases[i];
                    table = new legacy.ComputeTable(this.location, table, value, alias, table.schema);
                    names.push(alias || (0, utils_1.getScalarExpressionName)(value));
                }
            }
            if (names[0] === '*')
                return table;
            return new legacy.ProjectionTable(this.location, table, names, this.schema);
        }
        else {
            let stream = inner;
            if (this.computations.length > 0) {
                for (let i = 0; i < this.computations.length; i++) {
                    const value = this.computations[i];
                    const alias = this.aliases[i];
                    stream = new legacy.ComputeStream(this.location, stream, value, alias, stream.schema);
                    names.push(alias || (0, utils_1.getScalarExpressionName)(value));
                }
            }
            if (names[0] === '*')
                return stream;
            return new legacy.ProjectionStream(this.location, stream, names, this.schema);
        }
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitProjectionExpression(this))
            this.expression.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new ProjectionExpression(this.location, this.expression.clone(), this.args.slice(), this.computations.map((v) => v.clone()), this.aliases.slice(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, nestedScope] = yield* this.expression.iterateSlots(scope);
        const newScope = {};
        for (const name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, nestedScope] = yield* this.expression.iterateSlots2(scope);
        for (let i = 0; i < this.computations.length; i++)
            yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.ArrayIndexSlot(prim, nestedScope, this.computations[i].getType(), this.computations, 'computations', i));
        const newScope = {};
        for (const name of this.args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
}
exports.ProjectionExpression = ProjectionExpression;
class ProjectionElement extends base_1.default {
    constructor(value, alias, types) {
        super();
        this.value = value;
        this.alias = alias;
        this.types = types;
    }
    clone() {
        let value;
        if (typeof this.value === 'string')
            value = this.value;
        else if (this.value instanceof values_1.Value)
            value = this.value.clone();
        else
            value = this.value.map((v) => v.clone());
        return new ProjectionElement(value, this.alias, this.types.map((t) => t.clone()));
    }
    toSource() {
        let tokens;
        if (typeof this.value === 'string')
            tokens = list_1.default.join(this.value.split('.').map((v) => list_1.default.singleton(v)), '.');
        else if (this.value instanceof values_1.Value)
            tokens = this.value.toSource();
        else
            tokens = list_1.default.concat('<', list_1.default.join(this.value.map((e) => e.toSource()), '/'), '>');
        if (this.types.length > 0)
            tokens = list_1.default.concat(tokens, ':', list_1.default.join(this.types.map((t) => t.toSource()), '|'));
        if (this.alias)
            tokens = list_1.default.concat(tokens, 'as', this.alias);
        return tokens;
    }
    equals(other) {
        if (this.alias !== other.alias || !(0, array_equals_1.default)(this.types, other.types))
            return false;
        if (typeof this.value === 'string' && typeof other.value === 'string')
            return this.value === other.value;
        if (this.value instanceof values_1.Value && other.value instanceof values_1.Value)
            return this.value.equals(other.value);
        if (Array.isArray(this.value) && Array.isArray(other.value))
            return (0, array_equals_1.default)(this.value, other.value);
        return false;
    }
    visit(visitor) {
        visitor.enter(this);
        visitor.visitProjectionElement(this);
        visitor.exit(this);
    }
}
exports.ProjectionElement = ProjectionElement;
class ProjectionExpression2 extends Expression {
    constructor(location, expression, projections, schema) {
        super(location, schema);
        this.expression = expression;
        this.projections = projections;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Projection;
    }
    toSource() {
        const allprojections = this.projections.map((p) => p.toSource());
        return list_1.default.concat('[', list_1.default.join(allprojections, ','), ']', 'of', (0, syntax_priority_1.addParenthesis)(this.priority, this.expression.priority, this.expression.toSource()));
    }
    equals(other) {
        return other instanceof ProjectionExpression2 &&
            this.expression.equals(other.expression) &&
            (0, array_equals_1.default)(this.projections, other.projections);
    }
    toLegacy(into_params = [], scope_params = []) {
        const schema = this.schema;
        (0, assert_1.default)(schema.functionType !== 'action');
        if (this.projections.some((proj) => proj.types.length > 0))
            throw new errors_1.UnserializableError('Projection with type constraint');
        if (this.projections.some((proj) => Array.isArray(proj.value)))
            throw new errors_1.UnserializableError('Projection with property path');
        const inner = this.expression.toLegacy(into_params, scope_params);
        const names = [];
        if (schema.functionType === 'query') {
            let table = inner;
            for (let i = 0; i < this.projections.length; i++) {
                const projection = this.projections[i];
                if (typeof projection.value === 'string') {
                    names.push(projection.value);
                }
                else {
                    table = new legacy.ComputeTable(this.location, table, projection.value, projection.alias, table.schema);
                    names.push(projection.alias || (0, utils_1.getScalarExpressionName)(projection.value));
                }
            }
            return new legacy.ProjectionTable(this.location, table, names, this.schema);
        }
        else {
            let stream = inner;
            for (let i = 0; i < this.projections.length; i++) {
                const projection = this.projections[i];
                if (typeof projection.value === 'string') {
                    names.push(projection.value);
                }
                else {
                    stream = new legacy.ComputeStream(this.location, stream, projection.value, projection.alias, stream.schema);
                    names.push(projection.alias || (0, utils_1.getScalarExpressionName)(projection.value));
                }
            }
            return new legacy.ProjectionStream(this.location, stream, names, this.schema);
        }
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitProjectionExpression2(this))
            this.expression.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new ProjectionExpression2(this.location, this.expression.clone(), this.projections.map((proj) => proj.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [prim, nestedScope] = yield* this.expression.iterateSlots(scope);
        const newScope = {};
        const args = this.projections.filter((proj) => typeof proj.value === 'string').map((proj) => proj.value);
        for (const name of args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
    *iterateSlots2(scope) {
        const [prim, nestedScope] = yield* this.expression.iterateSlots2(scope);
        const computations = this.projections.filter((proj) => proj instanceof values_1.Value).map((proj) => proj.value);
        for (let i = 0; i < computations.length; i++)
            yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.ArrayIndexSlot(prim, nestedScope, computations[i].getType(), computations, 'computations', i));
        const newScope = {};
        const args = this.projections.filter((proj) => typeof proj.value === 'string').map((proj) => proj.value);
        for (const name of args)
            newScope[name] = nestedScope[name];
        return [prim, newScope];
    }
}
exports.ProjectionExpression2 = ProjectionExpression2;
class AliasExpression extends Expression {
    constructor(location, expression, name, schema) {
        super(location, schema);
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        (0, assert_1.default)(typeof name === 'string');
        this.name = name;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Alias;
    }
    toSource() {
        return list_1.default.concat((0, syntax_priority_1.addParenthesis)(this.priority, this.expression.priority, this.expression.toSource()), 'as', this.name);
    }
    equals(other) {
        return other instanceof AliasExpression &&
            this.expression.equals(other.expression) &&
            this.name === other.name;
    }
    toLegacy(into_params = [], scope_params = []) {
        const el = this.expression.toLegacy(into_params, scope_params);
        if (el instanceof legacy.Table) {
            return new legacy.AliasTable(this.location, el, this.name, this.schema);
        }
        else {
            (0, assert_1.default)(el instanceof legacy.Stream);
            return new legacy.AliasStream(this.location, el, this.name, this.schema);
        }
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAliasExpression(this))
            this.expression.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new AliasExpression(this.location, this.expression.clone(), this.name, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.expression.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.expression.iterateSlots2(scope);
    }
}
exports.AliasExpression = AliasExpression;
class AggregationExpression extends Expression {
    constructor(location, expression, field, operator, schema, overload = null, groupBy = null) {
        super(location, schema);
        // TODO
        this.alias = null;
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        (0, assert_1.default)(typeof field === 'string');
        this.field = field;
        (0, assert_1.default)(typeof operator === 'string');
        this.operator = operator;
        this.groupBy = groupBy;
        this.overload = overload;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        let source;
        if (this.field === '*') {
            source = list_1.default.concat(this.operator, '(', this.expression.toSource(), ')');
        }
        else {
            const field = list_1.default.join(this.field.split('.').map((n) => list_1.default.singleton(n)), '.');
            source = list_1.default.concat(this.operator, '(', field, 'of', this.expression.toSource(), ')');
        }
        if (this.groupBy)
            source = list_1.default.concat(source, 'by', this.groupBy);
        return source;
    }
    equals(other) {
        return other instanceof AggregationExpression &&
            this.expression.equals(other.expression) &&
            this.field === other.field &&
            this.operator === other.operator &&
            this.groupBy === other.groupBy;
    }
    toLegacy(into_params = [], scope_params = []) {
        if (this.groupBy)
            throw new errors_1.UnserializableError('Group by');
        const el = this.expression.toLegacy(into_params, scope_params);
        (0, assert_1.default)(el instanceof legacy.Table);
        return new legacy.AggregationTable(this.location, el, this.field, this.operator, null, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitAggregationExpression(this))
            this.expression.visit(visitor);
        visitor.exit(this);
    }
    clone() {
        return new AggregationExpression(this.location, this.expression.clone(), this.field, this.operator, this.schema ? this.schema.clone() : null, this.overload, this.groupBy);
    }
    *iterateSlots(scope) {
        return yield* this.expression.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        return yield* this.expression.iterateSlots2(scope);
    }
}
exports.AggregationExpression = AggregationExpression;
class SortExpression extends Expression {
    constructor(location, expression, value, direction, schema) {
        super(location, schema);
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        this.value = value;
        (0, assert_1.default)(direction === 'asc' || direction === 'desc');
        this.direction = direction;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Primary;
    }
    toSource() {
        return list_1.default.concat('sort', '(', this.value.toSource(), ' ', this.direction, 'of', this.expression.toSource(), ')');
    }
    equals(other) {
        return other instanceof SortExpression &&
            this.expression.equals(other.expression) &&
            this.value.equals(other.value) &&
            this.direction === other.direction;
    }
    toLegacy(into_params = [], scope_params = []) {
        const el = this.expression.toLegacy(into_params, scope_params);
        (0, assert_1.default)(el instanceof legacy.Table);
        if (this.value instanceof values_1.VarRefValue) {
            return new legacy.SortedTable(this.location, el, this.value.name, this.direction, this.schema);
        }
        else {
            return new legacy.SortedTable(this.location, new legacy.ComputeTable(this.location, el, this.value, null, this.schema), (0, utils_1.getScalarExpressionName)(this.value), this.direction, this.schema);
        }
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitSortExpression(this)) {
            this.expression.visit(visitor);
            this.value.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new SortExpression(this.location, this.expression.clone(), this.value.clone(), this.direction, this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.expression.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        const [prim, innerScope] = yield* this.expression.iterateSlots2(scope);
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, innerScope, type_1.default.Number, this, 'sort', 'value'));
        return [prim, innerScope];
    }
}
exports.SortExpression = SortExpression;
class IndexExpression extends Expression {
    constructor(location, expression, indices, schema) {
        super(location, schema);
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        (0, assert_1.default)(Array.isArray(indices));
        this.indices = indices;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Index;
    }
    toSource() {
        return list_1.default.concat((0, syntax_priority_1.addParenthesis)(this.priority, this.expression.priority, this.expression.toSource()), '[', list_1.default.join(this.indices.map((i) => i.toSource()), ','), ']');
    }
    equals(other) {
        return other instanceof IndexExpression &&
            this.expression.equals(other.expression) &&
            (0, array_equals_1.default)(this.indices, other.indices);
    }
    toLegacy(into_params = [], scope_params = []) {
        const el = this.expression.toLegacy(into_params, scope_params);
        (0, assert_1.default)(el instanceof legacy.Table);
        return new legacy.IndexTable(this.location, el, this.indices, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitIndexExpression(this)) {
            this.expression.visit(visitor);
            for (const index of this.indices)
                index.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new IndexExpression(this.location, this.expression.clone(), this.indices.map((i) => i.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.expression.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        const [prim, innerScope] = yield* this.expression.iterateSlots2(scope);
        for (let i = 0; i < this.indices.length; i++)
            yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.ArrayIndexSlot(prim, innerScope, type_1.default.Number, this.indices, 'expression.index', i));
        return [prim, innerScope];
    }
}
exports.IndexExpression = IndexExpression;
class SliceExpression extends Expression {
    constructor(location, expression, base, limit, schema) {
        super(location, schema);
        (0, assert_1.default)(expression instanceof Expression);
        this.expression = expression;
        (0, assert_1.default)(base instanceof values_1.Value);
        this.base = base;
        (0, assert_1.default)(limit instanceof values_1.Value);
        this.limit = limit;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Index;
    }
    toSource() {
        return list_1.default.concat((0, syntax_priority_1.addParenthesis)(this.priority, this.expression.priority, this.expression.toSource()), '[', this.base.toSource(), ':', this.limit.toSource(), ']');
    }
    equals(other) {
        return other instanceof SliceExpression &&
            this.expression.equals(other.expression) &&
            this.base.equals(other.base) &&
            this.limit.equals(other.limit);
    }
    toLegacy(into_params = [], scope_params = []) {
        const el = this.expression.toLegacy(into_params, scope_params);
        (0, assert_1.default)(el instanceof legacy.Table);
        return new legacy.SlicedTable(this.location, el, this.base, this.limit, this.schema);
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitSliceExpression(this)) {
            this.expression.visit(visitor);
            this.base.visit(visitor);
            this.limit.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new SliceExpression(this.location, this.expression.clone(), this.base.clone(), this.limit.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        return yield* this.expression.iterateSlots(scope);
    }
    *iterateSlots2(scope) {
        const [prim, innerScope] = yield* this.expression.iterateSlots2(scope);
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, innerScope, type_1.default.Number, this, 'slice', 'base'));
        yield* (0, slots_1.recursiveYieldArraySlots)(new slots_1.FieldSlot(prim, innerScope, type_1.default.Number, this, 'slice', 'limit'));
        return [prim, innerScope];
    }
}
exports.SliceExpression = SliceExpression;
/**
 * Evaluates a list of expressions, passing the result of the previous one
 * to the next.
 *
 * In syntax, the expressions are separated by "=>"
 */
class ChainExpression extends Expression {
    constructor(location, expressions, schema) {
        super(location, schema);
        (0, assert_1.default)(Array.isArray(expressions));
        this.expressions = expressions;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Chain;
    }
    get first() {
        return this.expressions[0];
    }
    set first(expr) {
        this.expressions[0] = expr;
    }
    get last() {
        return this.expressions[this.expressions.length - 1];
    }
    set last(expr) {
        this.expressions[this.expressions.length - 1] = expr;
    }
    get lastQuery() {
        const expressions = this.expressions;
        const last = expressions[expressions.length - 1];
        if (last.schema.functionType === 'action') {
            if (expressions.length === 1)
                return null;
            else
                return expressions[expressions.length - 2];
        }
        else {
            return last;
        }
    }
    setLastQuery(expr) {
        const expressions = this.expressions;
        const last = expressions[expressions.length - 1];
        if (last.schema.functionType === 'action') {
            if (expressions.length === 1)
                expressions.unshift(expr);
            else
                expressions[expressions.length - 2] = expr;
        }
        else {
            expressions[expressions.length - 1] = expr;
        }
    }
    toSource() {
        return list_1.default.join(this.expressions.map((exp) => exp.toSource()), '=>');
    }
    equals(other) {
        return other instanceof ChainExpression &&
            (0, array_equals_1.default)(this.expressions, other.expressions);
    }
    toLegacy(into_params = [], scope_params = []) {
        if (this.expressions.length === 1)
            return this.expressions[0].toLegacy(into_params, scope_params);
        // note: schemas and parameter passing work differently in old thingtalk
        // table/stream join and new thingtalk chain expressions
        // so this is not a perfect conversion
        const first = this.expressions[0];
        if (first.schema.functionType === 'stream') {
            const fl = first.toLegacy(into_params, scope_params);
            (0, assert_1.default)(fl instanceof legacy.Stream);
            if (this.expressions.length > 2) {
                const newIntoParams = [];
                const sl = this.expressions[1].toLegacy(newIntoParams, scope_params);
                (0, assert_1.default)(sl instanceof legacy.Table);
                const rest = this.expressions.slice(2).reduce((al, b) => {
                    const newIntoParams = [];
                    const bl = b.toLegacy(newIntoParams, scope_params);
                    (0, assert_1.default)(bl instanceof legacy.Table);
                    const joinParams = newIntoParams.filter((ip) => {
                        if (ip.value instanceof values_1.VarRefValue) {
                            if (al.schema.hasArgument(ip.value.name)) {
                                return true;
                            }
                            else {
                                into_params.push(ip);
                                return false;
                            }
                        }
                        else { // $event
                            return true;
                        }
                    });
                    return new legacy.JoinTable(null, al, bl, joinParams, b.schema);
                }, sl);
                const joinParams = newIntoParams.filter((ip) => {
                    if (ip.value instanceof values_1.VarRefValue) {
                        if (fl.schema.hasArgument(ip.value.name)) {
                            return true;
                        }
                        else {
                            into_params.push(ip);
                            return false;
                        }
                    }
                    else { // $event
                        return true;
                    }
                });
                return new legacy.JoinStream(this.location, fl, rest, joinParams, this.expressions[this.expressions.length - 1].schema);
            }
            else {
                const newIntoParams = [];
                const rest = this.expressions[1].toLegacy(newIntoParams, scope_params);
                (0, assert_1.default)(rest instanceof legacy.Table);
                const joinParams = newIntoParams.filter((ip) => {
                    if (ip.value instanceof values_1.VarRefValue) {
                        if (fl.schema.hasArgument(ip.value.name)) {
                            return true;
                        }
                        else {
                            into_params.push(ip);
                            return false;
                        }
                    }
                    else { // $event
                        return true;
                    }
                });
                return new legacy.JoinStream(this.location, fl, rest, joinParams, this.expressions[1].schema);
            }
        }
        else {
            const fl = this.expressions[0].toLegacy(into_params, scope_params);
            (0, assert_1.default)(fl instanceof legacy.Table);
            return this.expressions.slice(1).reduce((al, b) => {
                const newIntoParams = [];
                let bl = b.toLegacy(newIntoParams, scope_params);
                if (bl instanceof legacy.Action) {
                    // this can occur with chain expressions in assignments
                    (0, assert_1.default)(bl instanceof legacy.VarRefAction);
                    // this is a hack! we generate a table that calls an action
                    bl = new legacy.VarRefTable(bl.location, bl.name, bl.in_params, bl.schema);
                }
                (0, assert_1.default)(bl instanceof legacy.Table);
                const joinParams = newIntoParams.filter((ip) => {
                    if (ip.value instanceof values_1.VarRefValue) {
                        if (al.schema.hasArgument(ip.value.name)) {
                            return true;
                        }
                        else {
                            into_params.push(ip);
                            return false;
                        }
                    }
                    else { // $event
                        return true;
                    }
                });
                return new legacy.JoinTable(null, al, bl, joinParams, b.schema);
            }, fl);
        }
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitChainExpression(this)) {
            for (const expr of this.expressions)
                expr.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new ChainExpression(this.location, this.expressions.map((ex) => ex.clone()), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const newScope = {};
        for (const expr of this.expressions) {
            [, scope] = yield* expr.iterateSlots(scope);
            Object.assign(newScope, scope);
        }
        return [null, newScope];
    }
    *iterateSlots2(scope) {
        const newScope = {};
        for (const expr of this.expressions) {
            [, scope] = yield* expr.iterateSlots2(scope);
            Object.assign(newScope, scope);
        }
        return [null, newScope];
    }
}
exports.ChainExpression = ChainExpression;
class JoinExpression extends Expression {
    constructor(location, left, right, schema) {
        super(location, schema);
        this.lhs = left;
        this.rhs = right;
    }
    get priority() {
        return syntax_priority_1.SyntaxPriority.Join;
    }
    toSource() {
        return list_1.default.concat((0, syntax_priority_1.addParenthesis)(this.priority, this.lhs.priority, this.lhs.toSource()), 'join', (0, syntax_priority_1.addParenthesis)(this.priority, this.rhs.priority, this.rhs.toSource()));
    }
    equals(other) {
        return other instanceof JoinExpression &&
            this.lhs.equals(other.lhs) && this.rhs.equals(other.rhs);
    }
    toLegacy(into_params = [], scope_params = []) {
        throw new errors_1.UnserializableError('Join expression');
    }
    visit(visitor) {
        visitor.enter(this);
        if (visitor.visitJoinExpression(this)) {
            this.lhs.visit(visitor);
            this.rhs.visit(visitor);
        }
        visitor.exit(this);
    }
    clone() {
        return new JoinExpression(this.location, this.lhs.clone(), this.rhs.clone(), this.schema ? this.schema.clone() : null);
    }
    *iterateSlots(scope) {
        const [, leftScope] = yield* this.lhs.iterateSlots(scope);
        const [, rightScope] = yield* this.rhs.iterateSlots(scope);
        const newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    }
    *iterateSlots2(scope) {
        const [, leftScope] = yield* this.lhs.iterateSlots2(scope);
        const [, rightScope] = yield* this.rhs.iterateSlots2(scope);
        const newScope = {};
        Object.assign(newScope, leftScope, rightScope);
        return [null, newScope];
    }
}
exports.JoinExpression = JoinExpression;
//# sourceMappingURL=expression.js.map