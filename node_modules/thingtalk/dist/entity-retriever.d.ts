import List from './utils/list';
import { SyntaxType } from './syntax_api';
import { AnyEntity, EntityMap } from './entities';
/**
 * Abstract class capable of allocating entity numbers when converting
 * ThingTalk code to NN syntax (which uses numbered entities matching the input sentence).
 */
export declare abstract class AbstractEntityRetriever {
    protected _syntaxType: SyntaxType.Tokenized | SyntaxType.LegacyNN;
    protected _timezone: string;
    constructor(options: {
        timezone: string | undefined;
    });
    get timezone(): string;
    setSyntaxType(syntaxType: SyntaxType.Tokenized | SyntaxType.LegacyNN): void;
    /**
     * Find the entity with the given `entityType` (USERNAME, HASHTAG, etc.) and value.
     *
     * @param entityType - the type of entity to retrieve
     * @param value - the value to retrieve
     * @param options - additional options
     * @param options.ignoreNotFound - return `null` if the entity is not found, instead
     *   of throwing an exception.
     * @return the list of tokens making up this entity.
     */
    abstract findEntity(entityType: string, value: AnyEntity, options: {
        ignoreNotFound: true;
        includeEntityValue?: boolean;
        excludeEntityDisplay?: boolean;
    }): List<string> | null;
    abstract findEntity(entityType: string, value: AnyEntity, options?: {
        ignoreNotFound?: false;
        includeEntityValue?: boolean;
        excludeEntityDisplay?: boolean;
    }): List<string>;
}
/**
 * Entity retriever that looks for an entity in the tokenized entities, if any, and then
 * falls back to string matching in the sentence.
 */
export declare class EntityRetriever extends AbstractEntityRetriever {
    sentence: string[];
    entities: EntityMap;
    constructor(sentence: string | string[], entities: EntityMap, options: {
        timezone: string | undefined;
    });
    protected _sentenceContains(tokens: string[]): boolean;
    /**
     * Match an entity from the sentence.
     *
     * This method should search for the entity string in the sentence, and return the value
     * to predict in NN-syntax, or `undefined` if the entity is not mentioned.
     * This method can be overridden to implement custom tokenization or normalization.
     *
     * @param {string} entityType - the entity type (USERNAME, HASHTAG, QUOTED_STRING, etc.)
     * @param {string} entityString - the string to search
     * @param {boolean} ignoreNotFound - ignore if the entity is not mentioned; subclasses can
     *   use this to hallucinate entities that are not mentioned, when `ignoreNotFound` is false
     * @return the tokens to predict, or `undefined` if the entity is not mentioned in the sentence.
     */
    protected _findEntityFromSentence(entityType: string, entityString: string, ignoreNotFound: boolean): string[] | undefined;
    /**
     * Match a numeric entity from the sentence.
     *
     * This method should search for a mention of the number in the sentence, and return the value
     * to predict in NN-syntax, or `undefined` if the entity is not mentioned.
     * This method can be overridden to implement custom tokenization or normalization.
     *
     * @param {string} entityType - the numeric entity type (NUMBER, MEASURE, CURRENCY, etc.)
     * @param {number} number - the number to search
     * @param {boolean} ignoreNotFound - ignore if the number is not mentioned; subclasses can
     *   use this to hallucinate entities that are not mentioned, when `ignoreNotFound` is false
     * @return the tokens to predict, or `undefined` if the entity is not mentioned in the sentence.
     */
    protected _findNumberFromSentence(entityType: string, number: number, ignoreNotFound: boolean): string[] | undefined;
    private _findStringLikeEntity;
    private _findEntityInBag;
    findEntity(entityType: string, entity: AnyEntity, options: {
        ignoreNotFound: true;
        includeEntityValue?: boolean;
        excludeEntityDisplay?: boolean;
    }): List<string> | null;
    findEntity(entityType: string, entity: AnyEntity, options?: {
        ignoreNotFound?: false;
        includeEntityValue?: boolean;
        excludeEntityDisplay?: boolean;
    }): List<string>;
}
export declare class SequentialEntityAllocator extends AbstractEntityRetriever {
    offsets: {
        [key: string]: number;
    };
    entities: EntityMap;
    explicitStrings: boolean;
    constructor(entities: EntityMap, options: {
        timezone: string | undefined;
        explicitStrings?: boolean;
    });
    reset(): void;
    private updateOffsets;
    findEntity(entityType: string, entity: AnyEntity, { ignoreNotFound, includeEntityValue, excludeEntityDisplay }?: {
        ignoreNotFound?: boolean | undefined;
        includeEntityValue?: boolean | undefined;
        excludeEntityDisplay?: boolean | undefined;
    }): List<string>;
}
