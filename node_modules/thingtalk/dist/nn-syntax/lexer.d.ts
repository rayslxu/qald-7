import Type from '../type';
import { SourceRange } from '../utils/source_locations';
import { AnyEntity, EntityMap, EntityResolver } from '../entities';
interface FunctionToken {
    kind: string;
    channel: string;
}
interface ContextRefToken {
    name: string;
    type: Type;
}
interface GenericEntityToken {
    name: string;
    value: string;
    type: string;
}
declare type TokenValue = AnyEntity | GenericEntityToken | FunctionToken | ContextRefToken;
declare class TokenWrapper {
    token: string;
    value: TokenValue;
    location: SourceRange;
    constructor(token: string, value: TokenValue, location?: number);
    toString(): string;
}
export default class SequenceLexer implements Iterator<TokenWrapper> {
    private _sequence;
    private _entities;
    private _i;
    private _lastfunction;
    private _lastparam;
    private _instring;
    constructor(sequence: Iterable<string>, entities: EntityResolver | EntityMap);
    next(): IteratorResult<TokenWrapper>;
}
export {};
