"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2016-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const type_1 = __importDefault(require("./type"));
const Grammar = __importStar(require("./syntax_api"));
const typecheck_1 = __importDefault(require("./typecheck"));
const function_def_1 = require("./ast/function_def");
const program_1 = require("./ast/program");
const statement_1 = require("./ast/statement");
const cache_1 = __importDefault(require("./utils/cache"));
function delay(timeout) {
    return new Promise((resolve, reject) => {
        setTimeout(resolve, timeout);
    });
}
class DummyMemoryClient {
    constructor() {
        this._tables = new Map;
    }
    getSchema(table, principal) {
        return Promise.resolve(this._tables.get(table) || null);
    }
    createTable(table, args, types) {
        this._tables.set(table, { args: args, types: types });
        return Promise.resolve();
    }
}
/**
 * Delegate object to retrieve type information and metadata from Thingpedia.
 *
 * This class wraps an {@link AbstractThingpediaClient} and provides batching, in-memory
 * caching, and parsing.
 */
class SchemaRetriever {
    /**
     * Construct a new schema retriever.
     *
     * @param {AbstractThingpediaClient} tpClient - the Thingpedia client interface to wrap
     * @param {MemoryClient} [mClient] - the client interface to access stored tables
     * @param {boolean} [silent=false] - whether debugging information should be printed
     */
    constructor(tpClient, mClient, silent = false) {
        this._manifestCache = new Map;
        // each of the following exists for schema (types only)
        // and metadata (types and NL annotations)
        // keyed by isMeta/useMeta
        this._currentRequest = {
            basic: null,
            everything: null,
            dataset: null,
        };
        this._pendingRequests = {
            basic: [],
            everything: [],
            dataset: [],
        };
        this._classCache = {
            // expire caches in 24 hours (same as on-disk thingpedia caches)
            basic: new cache_1.default(24 * 3600 * 1000),
            everything: new cache_1.default(24 * 3600 * 1000),
            dataset: new cache_1.default(24 * 3600 * 1000)
        };
        this._entityTypeCache = new cache_1.default(24 * 3600 * 1000);
        this._thingpediaClient = tpClient;
        this._memoryClient = mClient || new DummyMemoryClient();
        this._silent = !!silent;
    }
    /**
     * Remove all information related to the given Thingpedia class from the cache.
     *
     * @param {string} kind - the class identifier
     */
    removeFromCache(kind) {
        this._classCache.basic.delete(kind);
        this._classCache.everything.delete(kind);
        this._manifestCache.delete(kind);
    }
    /**
     * Remove all information from all caches.
     */
    clearCache() {
        this._classCache.basic.clear();
        this._classCache.everything.clear();
        this._manifestCache.clear();
    }
    /**
     * Override cached type information with the passed in class.
     *
     * This can be used to ensure the schema retriever is consistent with other
     * cached information (for example, on disk caching of device implementation).
     *
     * @param {Ast.ClassDef} classDef - class definition to inject
     */
    injectClass(classDef) {
        // never expire explicitly injected class
        this._classCache.basic.set(classDef.kind, classDef, -1);
        this._classCache.everything.set(classDef.kind, classDef, -1);
        this._manifestCache.set(classDef.kind, Promise.resolve(classDef));
    }
    async _getManifestRequest(kind) {
        const code = await this._thingpediaClient.getDeviceCode(kind);
        const parsed = await Grammar.parse(code, Grammar.SyntaxType.Normal, { locale: this._thingpediaClient.locale, timezone: undefined }).typecheck(this);
        (0, assert_1.default)(parsed instanceof program_1.Library && parsed.classes.length > 0);
        return parsed.classes[0];
    }
    _getManifest(kind) {
        if (this._manifestCache.has(kind))
            return Promise.resolve(this._manifestCache.get(kind));
        const request = this._getManifestRequest(kind);
        this._manifestCache.set(kind, request);
        return request;
    }
    async getFormatMetadata(kind, query) {
        const classDef = await this._getManifest(kind);
        if (classDef.queries[query])
            return classDef.queries[query].metadata.formatted || [];
        return [];
    }
    async _makeRequest(isMeta) {
        // delay the actual request so that further requests
        // in the same event loop iteration will be batched
        // toghether
        // batching is important because otherwise we can
        // make a lot of tiny HTTP requests at the same time
        // and kill the Thingpedia server just out of overhead
        await delay(0);
        const pending = this._pendingRequests[isMeta];
        this._pendingRequests[isMeta] = [];
        this._currentRequest[isMeta] = null;
        if (pending.length === 0)
            return {};
        if (!this._silent)
            console.log(`Batched ${isMeta ? 'schema-meta' : 'schema'} request for ${pending}`);
        const code = await this._thingpediaClient.getSchemas(pending, isMeta === 'everything');
        if (code.trim() === '') {
            // empty reply, this means none of the requested classes was found
            // add negative cache entry (with small 10 minute timeout) for the missing class
            for (const kind of pending) {
                // we add it for both with & without metadata (if the class doesn't exist it doesn't exist)
                this._classCache.basic.set(kind, null, 600 * 1000);
                this._classCache.everything.set(kind, null, 600 * 1000);
            }
            return {};
        }
        const parsed = Grammar.parse(code, Grammar.SyntaxType.Normal, { locale: this._thingpediaClient.locale, timezone: undefined });
        const result = {};
        const missing = new Set(pending);
        await Promise.all(parsed.classes.map(async (classDef) => {
            try {
                const typeChecker = new typecheck_1.default(this, isMeta === 'everything');
                await typeChecker.typeCheckClass(classDef, true);
                this._classCache[isMeta].set(classDef.kind, classDef);
                result[classDef.kind] = classDef;
                missing.delete(classDef.kind);
            }
            catch (e) {
                result[classDef.kind] = e;
            }
        }));
        // add negative cache entry (with small 10 minute timeout) for the missing class
        for (const kind of missing) {
            // we add it for both with & without metadata (if the class doesn't exist it doesn't exist)
            this._classCache.basic.set(kind, null, 600 * 1000);
            this._classCache.everything.set(kind, null, 600 * 1000);
        }
        return result;
    }
    _ensureRequest(isMeta) {
        if (this._currentRequest[isMeta] !== null)
            return;
        this._currentRequest[isMeta] = this._makeRequest(isMeta);
    }
    async _getClass(kind, useMeta) {
        if (typeof kind !== 'string')
            throw new TypeError();
        const cached = this._classCache[useMeta].get(kind);
        if (cached !== undefined) {
            if (cached === null) // negative cache
                throw new TypeError('Invalid kind ' + kind);
            return cached;
        }
        if (this._pendingRequests[useMeta].indexOf(kind) < 0)
            this._pendingRequests[useMeta].push(kind);
        this._ensureRequest(useMeta);
        const everything = await this._currentRequest[useMeta];
        if (kind in everything) {
            const result = everything[kind];
            if (result instanceof Error)
                throw result;
            else
                return result;
        }
        else {
            throw new TypeError('Invalid kind ' + kind);
        }
    }
    /**
     * Return the full type information of the passed in class.
     *
     * @param {string} kind - the class identifier
     * @return {Ast.ClassDef} the corresponding class
     */
    getFullSchema(kind) {
        return this._getClass(kind, 'everything');
    }
    /**
     * Return the full type information and metadata of the passed in class.
     *
     * @param {string} kind - the class identifier
     * @return {Ast.ClassDef} the corresponding class, including metadata
     */
    getFullMeta(kind) {
        return this._getClass(kind, 'everything');
    }
    _where(where) {
        switch (where) {
            case 'query': return 'queries';
            case 'action': return 'actions';
            case 'both': return 'both';
            default: throw new TypeError('unexpected function type ' + where);
        }
    }
    // FIXME: this function exists for compatibility with
    // some really old code in almond-cloud (IIRC)
    // investigate if it can be removed
    /**
     * Return the type signature of the given function.
     *
     * This method is deprecated because it returns the types without the
     * argument names, directions and annotations.
     *
     * @param {string} kind - the class identifier
     * @param {string} functionType - the type of function (either `query` or `action`)
     * @param {string} name - the function name
     * @return {Type[]} the list of types in the signature
     * @deprecated Use {@link SchemaRetriever.getSchemaAndNames} instead
     */
    async getSchema(kind, functionType, name) {
        return (await this.getSchemaAndNames(kind, functionType, name)).types;
    }
    async _getFunction(kind, functionType, name, useMeta) {
        const where = this._where(functionType);
        const classDef = await this._getClass(kind, useMeta);
        if (where === 'both') {
            if (!(name in classDef.queries) && !(name in classDef.actions))
                throw new TypeError(`Class ${kind} has no function ${name}`);
            return classDef.queries[name] || classDef.actions[name];
        }
        else {
            if (!(name in classDef[where]))
                throw new TypeError(`Class ${kind} has no ${functionType} ${name}`);
            return classDef[where][name];
        }
    }
    /**
     * Return the type information of the given function.
     *
     * This method returns the minimal amount of information necessary to typecheck
     * a program, but not enough to drive the dialog agent.
     * This method is preferred to {@link SchemaRetriever.getMeta} when metadata
     * is not needed, because it reduces the load on the server (which can skip the
     * localization step) and reduces the amount of transferred data.
     *
     * @param {string} kind - the class identifier
     * @param {string} functionType - the type of function (either `query` or `action`)
     * @param {string} name - the function name
     * @return {Ast.FunctionDef} the function definition
     */
    getSchemaAndNames(kind, functionType, name) {
        return this._getFunction(kind, functionType, name, 'basic');
    }
    /**
     * Return the type information and metadata of the given function.
     *
     * This method returns the full amount of information necessary to typecheck
     * and drive the dialog agent, but might not include implementation only information
     * (such as loader or configuration mixins).
     *
     * @param {string} kind - the class identifier
     * @param {string} functionType - the type of function (either `query` or `action`)
     * @param {string} name - the function name
     * @return {Ast.FunctionDef} the function definition
     */
    getMeta(kind, functionType, name) {
        return this._getFunction(kind, functionType, name, 'everything');
    }
    async getMemorySchema(table, getMeta = false) {
        const resolved = await this._memoryClient.getSchema(table, null);
        if (!resolved)
            throw new TypeError(`No such table ${table}`);
        const { args: argnames, types } = resolved;
        const args = [];
        for (let i = 0; i < types.length; i++)
            args.push(new function_def_1.ArgumentDef(null, function_def_1.ArgDirection.OUT, argnames[i], type_1.default.fromString(types[i])));
        const functionDef = new function_def_1.FunctionDef(null, 'query', null, table, [], { is_list: true, is_monitorable: true }, args, {});
        // complete initialization of the function
        functionDef.setClass(null);
        (0, assert_1.default)(functionDef.minimal_projection);
        return functionDef;
    }
    async getMixins(kind) {
        const mixins = await this._thingpediaClient.getMixins();
        if (!(kind in mixins))
            throw new TypeError("Mixin " + kind + " not found.");
        const resolved = mixins[kind];
        const parsed = {
            kind: resolved.kind,
            types: resolved.types.map(type_1.default.fromString),
            args: resolved.args,
            required: resolved.required,
            is_input: resolved.is_input,
            facets: resolved.facets
        };
        return parsed;
    }
    async _makeDatasetRequest() {
        // delay the actual request so that further requests
        // in the same event loop iteration will be batched
        // toghether
        // batching is important because otherwise we can
        // make a lot of tiny HTTP requests at the same time
        // and kill the Thingpedia server just out of overhead
        await delay(0);
        const pending = this._pendingRequests.dataset;
        this._pendingRequests.dataset = [];
        this._currentRequest.dataset = null;
        if (pending.length === 0)
            return {};
        if (!this._silent)
            console.log(`Batched dataset request for ${pending}`);
        const code = await this._thingpediaClient.getExamplesByKinds(pending);
        const result = {};
        if (code.trim() === '') {
            // empty reply, this means none of the requested classes was found,
            // or all the datasets are empty
            for (const kind of pending)
                this._classCache.dataset.set(kind, result[kind] = new statement_1.Dataset(null, kind, []));
        }
        else {
            const parsed = Grammar.parse(code, Grammar.SyntaxType.Normal, { locale: this._thingpediaClient.locale, timezone: undefined });
            const examples = new Map();
            // flatten all examples in all datasets, and then split again by device
            // this is to account for the HTTP API (which returns one dataset),
            // developer mode (which returns one per device) and file client,
            // which returns one or more depending on the content of the files
            // on disk
            for (const dataset of parsed.datasets) {
                for (const example of dataset.examples) {
                    // typecheck each example individually, and ignore those that do not
                    // typecheck
                    // this can occur if the dataset we retrieved from Thingpedia is newer
                    // than the cached manifest and includes new functions or a parameter change
                    try {
                        await example.typecheck(this, true);
                    }
                    catch (e) {
                        console.log(`Failed to load dataset example ${example.id}: ${e.message}`);
                        continue;
                    }
                    const devices = new Set();
                    for (const [, prim] of example.iteratePrimitives(false))
                        devices.add(prim.selector.kind);
                    for (const device of devices) {
                        const list = examples.get(device);
                        if (list)
                            list.push(example);
                        else
                            examples.set(device, [example]);
                    }
                }
            }
            for (const kind of pending) {
                const dataset = new statement_1.Dataset(null, kind, examples.get(kind) || []);
                this._classCache.dataset.set(kind, result[kind] = dataset);
            }
        }
        return result;
    }
    _ensureDatasetRequest() {
        if (this._currentRequest.dataset !== null)
            return;
        this._currentRequest.dataset = this._makeDatasetRequest();
    }
    async getExamplesByKind(kind) {
        if (typeof kind !== 'string')
            throw new TypeError();
        const cached = this._classCache.dataset.get(kind);
        if (cached !== undefined)
            return cached;
        if (this._pendingRequests.dataset.indexOf(kind) < 0)
            this._pendingRequests.dataset.push(kind);
        this._ensureDatasetRequest();
        const everything = await this._currentRequest.dataset;
        const result = everything[kind];
        (0, assert_1.default)(result);
        if (result instanceof Error)
            throw result;
        else
            return result;
    }
    async _getEntityTypeRecord(entityType) {
        const cached = this._entityTypeCache.get(entityType);
        if (cached)
            return cached;
        // first try loading the class and looking for a declaration there
        // this is to support development of Thingpedia skills without editing
        // entities.json
        const [kind, name] = entityType.split(':');
        if (kind !== 'tt') {
            try {
                const classDef = await this._getClass(kind, 'everything');
                let found = null;
                for (const entity of classDef.entities) {
                    // load all the entities from this class, not just the one
                    // we're retrieving, otherwise we'll fallback to entities.json
                    // for all the entities, and be sad that entity records are
                    // wrong
                    const entityType = classDef.kind + ':' + entity.name;
                    const hasNer = entity.getImplementationAnnotation('has_ner');
                    const subTypeOf = entity.extends.map((e) => e.includes(':') ? e : classDef.kind + ':' + e);
                    const newRecord = {
                        type: entityType,
                        is_well_known: false,
                        has_ner_support: hasNer === undefined ? true : hasNer,
                        subtype_of: subTypeOf
                    };
                    this._entityTypeCache.set(entityType, newRecord);
                    if (entity.name === name)
                        found = newRecord; // keep going to more entities
                }
                if (found)
                    return found;
            }
            catch (e) {
                // ignore if there is no class with that name
            }
        }
        // then look up in thingpedia
        const allEntities = await this._thingpediaClient.getAllEntityTypes();
        let found = null;
        for (const record of allEntities) {
            // to support development of thingpedia skills, we don't want
            // entities.json to override actual classes, so we can't put
            // things in the cache unless we're sure about them
            // so we only put in the cache all the tt: entities (which
            // don't belong to any class) and the one entity we're looking for
            // this is a bit wasteful in that it results in multiple queries
            // to Thingpedia
            // we should change this back once Thingpedia actually knows
            // about entity subtyping
            if (record.type === entityType || record.type.startsWith('tt:'))
                this._entityTypeCache.set(record.type, record);
            if (record.type === entityType)
                found = record;
        }
        if (found)
            return found;
        // finally, make up a record with default info
        const newRecord = {
            type: entityType,
            is_well_known: false,
            has_ner_support: false
        };
        this._entityTypeCache.set(entityType, newRecord);
        return newRecord;
    }
    async getEntityParents(entityType) {
        const record = await this._getEntityTypeRecord(entityType);
        return record.subtype_of || [];
    }
}
exports.default = SchemaRetriever;
//# sourceMappingURL=schema.js.map