"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Functions = exports.Aggregations = exports.ScalarExpressionOps = exports.UnaryOps = exports.BinaryOps = void 0;
const type_1 = __importDefault(require("./type"));
const function_def_1 = require("./ast/function_def");
const values_1 = require("./ast/values");
/**
 * Definitions (type signatures) of ThingTalk binary comparison operators.
 *
 * @package
 */
exports.BinaryOps = {
    '>=': {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean],
            [new type_1.default.Measure(''), new type_1.default.Measure(''), type_1.default.Boolean],
            [type_1.default.Number, type_1.default.Number, type_1.default.Boolean],
            [type_1.default.Date, type_1.default.Date, type_1.default.Boolean],
            [type_1.default.Time, type_1.default.Time, type_1.default.Boolean],
            [type_1.default.Currency, type_1.default.Currency, type_1.default.Boolean]],
        op: '>='
    },
    '<=': {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean],
            [new type_1.default.Measure(''), new type_1.default.Measure(''), type_1.default.Boolean],
            [type_1.default.Number, type_1.default.Number, type_1.default.Boolean],
            [type_1.default.Date, type_1.default.Date, type_1.default.Boolean],
            [type_1.default.Time, type_1.default.Time, type_1.default.Boolean],
            [type_1.default.Currency, type_1.default.Currency, type_1.default.Boolean]],
        op: '<='
    },
    '==': {
        types: [['a', 'a', type_1.default.Boolean]],
        fn: 'equality',
    },
    '=~': {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean],
            [new type_1.default.Entity(''), type_1.default.String, type_1.default.Boolean]],
        fn: 'like',
    },
    '~=': {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean],
            [type_1.default.String, new type_1.default.Entity(''), type_1.default.Boolean]],
        fn: 'like',
        flip: true
    },
    starts_with: {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean]],
        fn: 'startsWith',
    },
    ends_with: {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean]],
        fn: 'endsWith',
    },
    prefix_of: {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean]],
        fn: 'startsWith',
        flip: true
    },
    suffix_of: {
        types: [[type_1.default.String, type_1.default.String, type_1.default.Boolean]],
        fn: 'endsWith',
        flip: true
    },
    /**
     * `contains`: array containment with equality
     *
     * `contains(a, b) = ∃ x. x ∈ a && b == x`
     */
    'contains': {
        types: [[new type_1.default.Array('a'), 'a', type_1.default.Boolean],
            [type_1.default.RecurrentTimeSpecification, type_1.default.Date, type_1.default.Boolean],
            [type_1.default.RecurrentTimeSpecification, type_1.default.Time, type_1.default.Boolean]],
        overload: (t1, t2, t3) => {
            if (t1 === type_1.default.RecurrentTimeSpecification)
                return { fn: 'recurrentTimeSpecContains', env: true };
            else
                return { fn: 'contains' };
        }
    },
    /**
     * `in_array`: array membership with equality
     *
     * `in_array(a, b) = ∃ x. x ∈ b && a == x`
     *
     * NOTE (Thm): `in_array(a, [x1, x2, ... xn]) = a == x1 || a == x2 || ... || x == xn`
     */
    'in_array': {
        types: [['a', new type_1.default.Array('a'), type_1.default.Boolean]],
        fn: 'contains',
        flip: true
    },
    /**
     * `contains~`: array containment with similarity
     *
     * `contains~(a, b) = ∃ x. x ∈ a && b =~ x`
     */
    'contains~': {
        types: [[new type_1.default.Array(type_1.default.String), type_1.default.String, type_1.default.Boolean],
            [new type_1.default.Array(new type_1.default.Entity('')), type_1.default.String, type_1.default.Boolean]],
        fn: 'containsLike',
    },
    /**
     * `in_array~`: array membership with similarity
     *
     * `in_array~(a, b) = ∃ x. x ∈ b && x =~ a`
     *
     * NOTE (Thm): `in_array~(a, [x1, x2, ... xn]) = x1 =~ a || x2 =~ a || ... || xn =~ a`
     */
    'in_array~': {
        types: [[type_1.default.String, new type_1.default.Array(type_1.default.String), type_1.default.Boolean],
            [new type_1.default.Entity(''), new type_1.default.Array(type_1.default.String), type_1.default.Boolean]],
        fn: 'inArrayLike',
    },
    /**
     * `~contains`: reverse array containment with similarity
     *
     * `~contains(a, b) = ∃ x. x ∈ a && b ~= x`
     *
     * NOTE (Thm): `~contains(a, b) = in_array~(b, a)`
     */
    '~contains': {
        types: [[new type_1.default.Array(type_1.default.String), type_1.default.String, type_1.default.Boolean],
            [new type_1.default.Array(type_1.default.String), new type_1.default.Entity(''), type_1.default.Boolean]],
        fn: 'inArrayLike',
        flip: true,
    },
    /**
     * `~in_array`: array membership with similarity
     *
     * `~in_array(a, b) = ∃ x. x ∈ b && x ~= a`
     *
     * NOTE (Thm): `~in_array(a, b) = contains~(b, a)`
     */
    '~in_array': {
        types: [[type_1.default.String, new type_1.default.Array(type_1.default.String), type_1.default.Boolean],
            [type_1.default.String, new type_1.default.Array(new type_1.default.Entity('')), type_1.default.Boolean]],
        fn: 'containsLike',
        flip: true,
    },
    'has_member': {
        types: [[new type_1.default.Entity('tt:contact_group'), new type_1.default.Entity('tt:contact'), type_1.default.Boolean]],
    },
    'group_member': {
        types: [[new type_1.default.Entity('tt:contact'), new type_1.default.Entity('tt:contact_group'), type_1.default.Boolean]],
    }
};
/**
 * Definitions (type signatures) of ThingTalk unary operators.
 */
exports.UnaryOps = {
    '!': {
        types: [[type_1.default.Boolean, type_1.default.Boolean]],
        op: '!'
    },
    'get_time': {
        types: [[type_1.default.Date, type_1.default.Time]],
        fn: 'getTime'
    },
    'get_currency': {
        types: [[type_1.default.Number, type_1.default.Currency]],
        fn: 'getCurrency'
    }
};
/**
 * Definitions (type signatures) of ThingTalk scalar operators.
 */
exports.ScalarExpressionOps = {
    '+': {
        types: [[type_1.default.String, type_1.default.String, type_1.default.String],
            [type_1.default.Number, type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Currency, type_1.default.Currency],
            [new type_1.default.Measure(''), new type_1.default.Measure(''), new type_1.default.Measure('')],
            [type_1.default.Date, new type_1.default.Measure('ms'), type_1.default.Date],
            [type_1.default.Time, new type_1.default.Measure('ms'), type_1.default.Time]],
        overload: (t1, t2, t3) => {
            if (t1 === type_1.default.Date)
                return { fn: 'dateAdd' };
            else if (t1 === type_1.default.Time)
                return { fn: 'timeAdd' };
            else
                return { op: '+' };
        }
    },
    '-': {
        types: [[type_1.default.Number, type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Currency, type_1.default.Currency],
            [new type_1.default.Measure(''), new type_1.default.Measure(''), new type_1.default.Measure('')],
            [type_1.default.Date, new type_1.default.Measure('ms'), type_1.default.Date],
            [type_1.default.Time, new type_1.default.Measure('ms'), type_1.default.Time]],
        op: '-',
        overload: (t1, t2, t3) => {
            if (t1 === type_1.default.Date)
                return { fn: 'dateSub' };
            else if (t1 === type_1.default.Time)
                return { fn: 'timeSub' };
            else
                return { op: '-' };
        }
    },
    '*': {
        types: [[type_1.default.Number, type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Number, type_1.default.Currency],
            [new type_1.default.Measure(''), type_1.default.Number, new type_1.default.Measure('')]],
        op: '*'
    },
    '/': {
        types: [[type_1.default.Number, type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Number, type_1.default.Currency],
            [new type_1.default.Measure(''), type_1.default.Number, new type_1.default.Measure('')]],
        op: '/'
    },
    '%': {
        types: [[type_1.default.Number, type_1.default.Number, type_1.default.Number]],
        op: '%'
    },
    '**': {
        types: [[type_1.default.Number, type_1.default.Number, type_1.default.Number]],
        op: '**'
    },
    'distance': {
        types: [[type_1.default.Location, type_1.default.Location, new type_1.default.Measure('m')]],
        fn: 'distance'
    },
    'max': {
        types: [[new type_1.default.Array(type_1.default.Number), type_1.default.Number],
            [new type_1.default.Array(type_1.default.Currency), type_1.default.Currency],
            [new type_1.default.Array(new type_1.default.Measure('')), new type_1.default.Measure('')]],
        fn: 'aggregateMax',
    },
    'min': {
        types: [[new type_1.default.Array(type_1.default.Number), type_1.default.Number],
            [new type_1.default.Array(type_1.default.Currency), type_1.default.Currency],
            [new type_1.default.Array(new type_1.default.Measure('')), new type_1.default.Measure('')]],
        fn: 'aggregateMin',
    },
    'sum': {
        types: [[new type_1.default.Array(type_1.default.Number), type_1.default.Number],
            [new type_1.default.Array(type_1.default.Currency), type_1.default.Currency],
            [new type_1.default.Array(new type_1.default.Measure('')), new type_1.default.Measure('')]],
        fn: 'aggregateSum',
    },
    'avg': {
        types: [[new type_1.default.Array(type_1.default.Number), type_1.default.Number],
            [new type_1.default.Array(type_1.default.Currency), type_1.default.Currency],
            [new type_1.default.Array(new type_1.default.Measure('')), new type_1.default.Measure('')]],
        fn: 'aggregateAvg',
    },
    'count': {
        types: [[new type_1.default.Array('x'), type_1.default.Number]],
        fn: 'count',
    },
    'set_time': {
        types: [[type_1.default.Date, type_1.default.Time, type_1.default.Date]],
        fn: 'setTime',
        env: true
    }
};
/**
 * Definitions (type signatures) of ThingTalk aggregation operators.
 */
exports.Aggregations = {
    'max': {
        types: [[type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Currency],
            [new type_1.default.Measure(''), new type_1.default.Measure('')]]
    },
    'min': {
        types: [[type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Currency],
            [new type_1.default.Measure(''), new type_1.default.Measure('')]]
    },
    'sum': {
        types: [[type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Currency],
            [new type_1.default.Measure(''), new type_1.default.Measure('')]]
    },
    'avg': {
        types: [[type_1.default.Number, type_1.default.Number],
            [type_1.default.Currency, type_1.default.Currency],
            [new type_1.default.Measure(''), new type_1.default.Measure('')]]
    },
    'count': {
        types: [[type_1.default.Any, type_1.default.Number]]
    }
};
const TIMER_SCHEMA = new function_def_1.FunctionDef(null, 'stream', null, // class
'timer', [], // extends
{
    is_list: false,
    is_monitorable: true
}, [
    new function_def_1.ArgumentDef(null, function_def_1.ArgDirection.IN_OPT, 'base', type_1.default.Date, { impl: {
            default: new values_1.DateValue(null) // $now
        } }),
    new function_def_1.ArgumentDef(null, function_def_1.ArgDirection.IN_REQ, 'interval', new type_1.default.Measure('ms')),
    new function_def_1.ArgumentDef(null, function_def_1.ArgDirection.IN_OPT, 'frequency', type_1.default.Number),
], {});
const AT_TIMER_SCHEMA = new function_def_1.FunctionDef(null, 'stream', null, // class
'attimer', [], // extends
{
    is_list: false,
    is_monitorable: true
}, [
    new function_def_1.ArgumentDef(null, function_def_1.ArgDirection.IN_REQ, 'time', new type_1.default.Array(type_1.default.Time)),
    new function_def_1.ArgumentDef(null, function_def_1.ArgDirection.IN_OPT, 'expiration_date', type_1.default.Date),
], {});
const ON_TIMER_SCHEMA = new function_def_1.FunctionDef(null, 'stream', null, //class
'ontimer', [], //extends
{
    is_list: false,
    is_monitorable: true
}, [
    new function_def_1.ArgumentDef(null, function_def_1.ArgDirection.IN_REQ, 'date', new type_1.default.Array(type_1.default.Date))
], {});
/**
 * Definitions (type signatures) of builtin ThingTalk functions.
 *
 * These are functions that are predefined and can be called without the @-sign.
 */
exports.Functions = {
    'timer': TIMER_SCHEMA,
    'attimer': AT_TIMER_SCHEMA,
    'ontimer': ON_TIMER_SCHEMA
};
//# sourceMappingURL=operators.js.map