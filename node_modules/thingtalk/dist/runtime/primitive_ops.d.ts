import { Temporal } from '@js-temporal/polyfill';
import type { ExecEnvironment } from './exec_environment';
import { LocationLike, Time, Currency, RecurrentTimeRule } from './values';
export declare function distance(a: LocationLike, b: LocationLike): number;
export declare function equality(a: unknown, b: unknown): boolean;
export declare function like(a: unknown, b: unknown): boolean;
export declare function startsWith(a: unknown, b: unknown): boolean;
export declare function endsWith(a: unknown, b: unknown): boolean;
export declare function recurrentTimeSpecContains(env: ExecEnvironment, spec: RecurrentTimeRule[], timeOrDate: Date | Temporal.ZonedDateTime | Temporal.PlainTime | Time): boolean;
export declare function contains(a: unknown[] | null | undefined, b: unknown): boolean;
export declare function containsLike(a: unknown[] | null | undefined, b: string): boolean;
export declare function inArrayLike(a: string, b: string[] | null | undefined): boolean;
export declare function getTime(d: Date): Time;
export declare function getCurrency(d: number): Currency;
export declare function sum(a: number, b: number): number;
export declare function max(a: number, b: number): number;
export declare function min(a: number, b: number): number;
export declare function argmax(value: number, previous: number): boolean;
export declare function argmin(value: number, previous: number): boolean;
export declare class EqualitySet {
    store: unknown[];
    constructor();
    has(value: unknown): boolean;
    add(value: unknown): void;
    get size(): number;
}
export declare type ArgMinMaxOp = (value: number, previous: number) => number;
export declare class ArgMinMaxState<T> {
    private _op;
    private _total;
    private _filled;
    private _tuples;
    private _outputTypes;
    private _values;
    private _base;
    constructor(op: ArgMinMaxOp, base: number, limit: number);
    [Symbol.iterator](): Generator<[string, unknown], void>;
    update(tuple: T, outputType: string, value: number): void;
}
export declare function count(x: unknown[]): number;
export declare function aggregateMax(array: number[]): number;
export declare function aggregateMin(array: number[]): number;
export declare function aggregateSum(array: number[]): number;
export declare function aggregateAvg(array: number[]): number;
export declare function setTime(env: ExecEnvironment, d: Date | Temporal.ZonedDateTime | Temporal.Instant | null, t: Time | Temporal.PlainTime | null): Date;
export declare function dateAdd(date: Date | Temporal.Instant | Temporal.ZonedDateTime, offset: number): Date;
export declare function dateSub(date: Date | Temporal.Instant | Temporal.ZonedDateTime, offset: number): Date;
export declare function timeAdd(time: Time | Temporal.PlainTime, offset: number): Time;
export declare function timeSub(time: Time, offset: number): Time;
