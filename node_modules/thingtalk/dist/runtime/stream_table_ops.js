"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2019 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAsyncIterator = exports.invokeStreamVarRef = exports.tableCrossJoin = exports.tableJoin = exports.streamUnion = exports.addTuple = exports.isNewTuple = void 0;
const assert_1 = __importDefault(require("assert"));
const consumer_queue_1 = __importDefault(require("consumer-queue"));
const output_type_ops_1 = require("./output_type_ops");
const primitive_ops_1 = require("./primitive_ops");
function tupleEquals(a, b, keys) {
    for (const key of keys) {
        if (!(0, primitive_ops_1.equality)(a[key], b[key]))
            return false;
    }
    return true;
}
/**
 * Check if a query returned a new result, compared to the previously returned results.
 *
 * This function checks if the state contains an identical tuple (comparing only `keys`)
 * in the immediately previous round of polling (according to `__timestamp`)
 *
 * This is used to identify the delta between two polling queries in the `monitor`
 * operator.
 *
 * @param state the monitoring state, consisting of the results returned in the prior
 *   two polling rounds
 * @param tuple the result tuple to check
 * @param keys which keys of `tuple` should be compared
 * @returns `true` if this is a new tuple, `false` otherwise
 */
function isNewTuple(state, tuple, keys) {
    // at the beginning no tuples are new, because we never polled and we don't want to spam
    // the results
    if (state === null)
        return false;
    // find the timestamp of the last round of polling in the state, and the immediately previous one
    let tlast, tprevious;
    for (let i = state.length - 1; i >= 0; i--) {
        if (tlast === undefined)
            tlast = state[i].__timestamp;
        else if (tprevious === undefined && state[i].__timestamp < tlast)
            tprevious = state[i].__timestamp;
        else if (tprevious !== undefined && state[i].__timestamp < tprevious)
            break;
    }
    // if this tuple belongs to a round of polling already in the state, shift the timestamps forward
    if (tuple.__timestamp === tlast)
        tlast = tprevious;
    // if the state is empty (tlast === undefined before the if statement), or the state contains exactly
    // one round of polling and we're in the same round of polling (tlast was assigned to tprevious,
    // and tprevious === undefined), this is the first polling, and this is not a new tuple
    if (tlast === undefined)
        return false;
    for (let i = 0; i < state.length; i++) {
        if (state[i].__timestamp !== tlast)
            continue;
        if (tupleEquals(state[i], tuple, keys))
            return false;
    }
    return true;
}
exports.isNewTuple = isNewTuple;
/**
 * Update the state used to monitor queries.
 *
 * @param state the monitoring state
 * @param tuple the result tuple to add to the state
 */
function addTuple(state, tuple) {
    if (state === null)
        return [tuple];
    state.push(tuple);
    // trim the state to the last two timestamps
    // (see the logic in isNewTuple)
    let tlast, tprevious;
    let i;
    for (i = state.length - 1; i >= 0; i--) {
        if (tlast === undefined)
            tlast = state[i].__timestamp;
        else if (tprevious === undefined && state[i].__timestamp < tlast)
            tprevious = state[i].__timestamp;
        else if (tprevious !== undefined && state[i].__timestamp < tprevious)
            break;
    }
    if (i >= 0) {
        (0, assert_1.default)(tprevious !== undefined);
        (0, assert_1.default)(state[i].__timestamp < tprevious);
        state = state.slice(i + 1);
    }
    return state;
}
exports.addTuple = addTuple;
function streamUnion(lhs, rhs) {
    const queue = new consumer_queue_1.default();
    let currentLeft = null;
    let currentRight = null;
    let doneLeft = false;
    let doneRight = false;
    function emit() {
        if (currentLeft === null || currentRight === null)
            return;
        const [leftType, leftValue] = currentLeft;
        const [rightType, rightValue] = currentRight;
        const newValue = {};
        Object.assign(newValue, leftValue);
        Object.assign(newValue, rightValue);
        const newType = (0, output_type_ops_1.combineOutputTypes)(leftType, rightType);
        queue.push({ value: [newType, newValue], done: false });
    }
    function checkDone() {
        if (doneLeft && doneRight)
            queue.push({ value: undefined, done: true });
    }
    lhs((...v) => {
        currentLeft = v;
        emit();
    }).then(() => {
        doneLeft = true;
        checkDone();
    }).catch((err) => queue.cancelWait(err));
    rhs((...v) => {
        currentRight = v;
        emit();
    }).then(() => {
        doneRight = true;
        checkDone();
    }).catch((err) => queue.cancelWait(err));
    return queue;
}
exports.streamUnion = streamUnion;
function accumulateStream(stream) {
    const into = [];
    return stream((type, value) => {
        into.push([type, value]);
    }).then(() => into);
}
class DelayedIterator {
    constructor(promise) {
        this._promise = promise;
        this._iterator = null;
    }
    next() {
        if (this._iterator !== null)
            return Promise.resolve(this._iterator.next());
        return this._promise.then((iterator) => {
            this._iterator = iterator;
            return this._iterator.next();
        });
    }
}
function tableJoin(lhs, rhs) {
    return new DelayedIterator(Promise.all([
        accumulateStream(lhs),
        accumulateStream(rhs)
    ]).then(([left, right]) => {
        return (function* () {
            for (const l of left) {
                for (const r of right) {
                    const [leftType, leftValue] = l;
                    const [rightType, rightValue] = r;
                    const newValue = {};
                    for (const [key, value] of Object.entries(leftValue))
                        newValue[`first.${key}`] = value;
                    for (const [key, value] of Object.entries(rightValue))
                        newValue[`second.${key}`] = value;
                    const newType = (0, output_type_ops_1.combineOutputTypes)(leftType, rightType);
                    yield [newType, newValue];
                }
            }
        })();
    }));
}
exports.tableJoin = tableJoin;
function tableCrossJoin(lhs, rhs) {
    return new DelayedIterator(Promise.all([
        accumulateStream(lhs),
        accumulateStream(rhs)
    ]).then(([left, right]) => {
        return (function* () {
            for (const l of left) {
                for (const r of right) {
                    const [leftType, leftValue] = l;
                    const [rightType, rightValue] = r;
                    const newValue = {};
                    Object.assign(newValue, leftValue);
                    Object.assign(newValue, rightValue);
                    const newType = (0, output_type_ops_1.combineOutputTypes)(leftType, rightType);
                    yield [newType, newValue];
                }
            }
        })();
    }));
}
exports.tableCrossJoin = tableCrossJoin;
function invokeStreamVarRef(env, varref, ...args) {
    const queue = new consumer_queue_1.default();
    function emit(type, value) {
        queue.push({ value: [type, value], done: false });
    }
    varref(env, emit, ...args).then(() => {
        queue.push({ value: undefined, done: true });
    }).catch((err) => {
        queue.cancelWait(err);
    });
    return queue;
}
exports.invokeStreamVarRef = invokeStreamVarRef;
function getAsyncIterator(obj) {
    const getAsync = obj[Symbol.asyncIterator];
    if (typeof getAsync === 'function')
        return getAsync.call(obj);
    return obj[Symbol.iterator]();
}
exports.getAsyncIterator = getAsyncIterator;
//# sourceMappingURL=stream_table_ops.js.map