import { Temporal } from '@js-temporal/polyfill';
/**
 * Runtime representation of an entity value.
 *
 */
export declare class Entity {
    /**
     * The entity identifier value.
     */
    value: string;
    /**
     * The entity display name.
     */
    display: string | null;
    /**
     * Match this entity against a query string.
     *
     * This optional property can be set to override the behavior of the `=~` operator
     * for this entity.
     *
     * Note that the evaluation order of ThingTalk is unspecified, so this method must
     * have no side effects.
     *
     * @param against the query to check against
     * @returns true if the query matches, false otherwise
     */
    softmatch?(against: string): boolean;
    /**
     * Construct a new entity value.
     *
     * @param value - the entity identifier value
     * @param display - optional human-readable display name for the entity
     */
    constructor(id: string, display?: string | null, options?: {
        softmatch?: (against: string) => boolean;
    });
    toString(): string;
    /**
     * Compile the entity value to JS code.
     *
     * @return {string} JS code that evaluates to this entity value
     */
    toJSSource(): string;
    /**
     * Check if this JS value looks like an entity.
     *
     * @param {any} obj - the JS value to check
     * @return {boolean} `true` if the value is a string or an instance of this class
     */
    static isEntity(obj: unknown): obj is (Entity | string);
}
/**
 * Runtime representation of a string-like object.
 *
 * Objects of this class can be used to override the behavior of
 * string operators at runtime.
 */
export declare class StringLike {
    /**
     * The underlying string value.
     */
    private value;
    /**
     * Match this string against a query string.
     *
     * This optional property can be set to override the behavior of the `=~` operator.
     *
     * Note that the evaluation order of ThingTalk is unspecified, so this method must
     * have no side effects.
     *
     * @param against the query to check against
     * @returns true if the query matches, false otherwise
     */
    softmatch?(against: string): boolean;
    /**
     * Construct a new string-like object.
     *
     * @param value - the string value
     */
    constructor(id: string, options?: {
        softmatch?: (against: string) => boolean;
    });
    toString(): string;
    valueOf(): string;
    /**
     * Compile this to JS code.
     *
     * @return {string} JS code that evaluates to this value
     * @package
     */
    toJSSource(): string;
}
export interface LocationLike {
    x: number;
    y: number;
    display?: string | null;
}
/**
 * Runtime representation of a location value.
 *
 */
export declare class Location implements LocationLike {
    /**
     * Longitude value.
     * @deprecated Use {@link lon}
     */
    x: number;
    /**
     * Latitude value.
     * @deprecated Use {@link lat}
     */
    y: number;
    /**
     * Display name for this location.
     */
    display: string | null;
    /**
     * Construct a new location value.
     *
     * @param {number} lat - latitude in degrees (between -90 and 90)
     * @param {number} lon - longitude in degrees (between -180 and 180)
     * @param {string|null} [display] - human-readable display name for this location
     */
    constructor(lat: number, lon: number, display?: string | null);
    /**
     * Latitude value.
     */
    get lat(): number;
    /**
     * Longitude value.
     */
    get lon(): number;
    toString(): string;
    /**
     * Compile the location value to JS code.
     *
     * @return {string} JS code that evaluates to this location value
     * @package
     */
    toJSSource(): string;
    /**
     * Check if this JS value looks like an location.
     *
     * For compatibility reasons, the runtime representation of a location is not required
     * to be an instance of the {@link Builtin.Location} class, and can be any object
     * with `x` and `y` own properties.
     *
     * @param {any} obj - the JS value to check
     * @return {boolean} `true` if the value looks like a location
     * @package
     */
    static isLocation(obj: unknown): obj is LocationLike;
}
/**
 * Runtime representation of a time value.
 *
 */
export declare class Time {
    /**
     * Hour value.
     */
    hour: number;
    /**
     * Minute value.
     */
    minute: number;
    /**
     * Second value.
     */
    second: number;
    /**
     * Construct a new time value.
     *
     * @param {number} hour - hour value (between 0 and 11)
     * @param {number} minute - minute value (between 0 and 59)
     * @param {number} [second] - second value (between 0 and 59)
     */
    constructor(hour: number, minute: number, second?: number);
    static fromSeconds(seconds: number): Time;
    static fromTemporal(time: Temporal.PlainTime): Time;
    /**
     * Convert this time value to the number of seconds since midnight.
     *
     * This can be used to compare time values using `<` and `>`
     * @return {number} the number of seconds since midnight
     */
    valueOf(): number;
    toString(): string;
    toJSON(): string;
    /**
     * Compile the time value to JS code.
     *
     * @return {string} JS code that evaluates to this time value
     * @package
     */
    toJSSource(): string;
}
/**
 * Runtime representation of a currency value.
 *
 */
export declare class Currency {
    value: number;
    code: string;
    constructor(value: number, code: string);
    valueOf(): number;
    toString(): string;
    toLocaleString(locale: string, options?: Intl.NumberFormatOptions): string;
    toJSSource(): string;
}
export interface RecurrentTimeRuleLike {
    beginTime: Time;
    endTime: Time;
    interval: number;
    frequency: number;
    dayOfWeek: number | null;
    beginDate: Date | null;
    endDate: Date | null;
    subtract: boolean;
}
/**
 * Runtime representation of a recurrent time rule (a single item in a recurrent time specification).
 *
 */
export declare class RecurrentTimeRule implements RecurrentTimeRuleLike {
    beginTime: Time;
    endTime: Time;
    interval: number;
    frequency: number;
    /**
     * Day of the week where this time rule applies, if any.
     *
     * This is a number between 0 and 6, where 0 is Monday and
     * 6 is Sunday.
     *
     * If null, this rule applies any day of the week.
     */
    dayOfWeek: number | null;
    beginDate: Date | null;
    endDate: Date | null;
    subtract: boolean;
    constructor({ beginTime, endTime, interval, frequency, dayOfWeek, beginDate, endDate, subtract }: RecurrentTimeRuleLike);
    toString(): string;
    toJSSource(): string;
    contains(dateOrTime: Date | Temporal.ZonedDateTime | Temporal.PlainTime | Time, timezone: string): boolean;
}
export declare class Aggregation {
    type: string;
    field: string;
    cols: string;
    count: number;
    constructor(type: string, field: string, cols: string, count: number);
}
