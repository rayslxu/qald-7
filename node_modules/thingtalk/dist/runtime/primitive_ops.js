"use strict";
// -*- mode: typescript; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2018-2020 The Board of Trustees of the Leland Stanford Junior University
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.timeSub = exports.timeAdd = exports.dateSub = exports.dateAdd = exports.setTime = exports.aggregateAvg = exports.aggregateSum = exports.aggregateMin = exports.aggregateMax = exports.count = exports.ArgMinMaxState = exports.EqualitySet = exports.argmin = exports.argmax = exports.min = exports.max = exports.sum = exports.getCurrency = exports.getTime = exports.inArrayLike = exports.containsLike = exports.contains = exports.recurrentTimeSpecContains = exports.endsWith = exports.startsWith = exports.like = exports.equality = exports.distance = void 0;
const assert_1 = __importDefault(require("assert"));
const polyfill_1 = require("@js-temporal/polyfill");
const Ast = __importStar(require("../ast"));
const values_1 = require("./values");
// Implementations of the ThingTalk operators
function arrayEquals(a, b) {
    if (a.length !== b.length)
        return false;
    for (let i = 0; i < a.length; i++) {
        if (!equality(a[i], b[i]))
            return false;
    }
    return true;
}
function objectEquals(a, b) {
    const a_props = Object.getOwnPropertyNames(a);
    const b_props = Object.getOwnPropertyNames(b);
    if (a_props.length !== b_props.length)
        return false;
    for (let i = 0; i < a_props.length; i++) {
        if (!equality(a[a_props[i]], b[a_props[i]]))
            return false;
    }
    return true;
}
function distance(a, b) {
    const R = 6371000; // meters
    const lat1 = a.y;
    const lat2 = b.y;
    const lon1 = a.x;
    const lon2 = b.x;
    function toRadians(deg) {
        return deg * Math.PI / 180.0;
    }
    // formula courtesy of http://www.movable-type.co.uk/scripts/latlong.html
    const φ1 = toRadians(lat1);
    const φ2 = toRadians(lat2);
    const Δφ = toRadians(lat2 - lat1);
    const Δλ = toRadians(lon2 - lon1);
    const x = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
        Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
    const c = 2 * Math.atan2(Math.sqrt(x), Math.sqrt(1 - x));
    return R * c;
}
exports.distance = distance;
function locationEquals(a, b) {
    if (a === b)
        return true;
    if (a.x === b.x && a.y === b.y)
        return true;
    //console.log('Comparing locations', [a,b]);
    const d = distance(a, b);
    //console.log('Distance (m): ' + d.toFixed(2));
    return d <= 2500;
}
function hasValueOf(x) {
    return typeof x === 'number' || typeof x === 'string' || x instanceof Date || x instanceof values_1.Time || x instanceof values_1.StringLike;
}
function editDistance(one, two) {
    if (typeof one === 'string' && typeof two === 'string') {
        if (one === two)
            return 0;
        if (one.indexOf(two) >= 0)
            return one.length - two.length;
        if (two.indexOf(one) >= 0)
            return two.length - one.length;
    }
    const R = one.length + 1;
    const C = two.length + 1;
    const matrix = new Array(R * C);
    function set(i, j, v) {
        (0, assert_1.default)(i * C + j < R * C);
        matrix[i * C + j] = v;
    }
    function get(i, j) {
        (0, assert_1.default)(i * C + j < R * C);
        return matrix[i * C + j];
    }
    for (let j = 0; j < C; j++)
        set(0, j, j);
    for (let i = 1; i < R; i++)
        set(i, 0, i);
    for (let i = 1; i <= one.length; i++) {
        for (let j = 1; j <= two.length; j++) {
            if (one[i - 1] === two[j - 1])
                set(i, j, get(i - 1, j - 1));
            else
                set(i, j, 1 + Math.min(Math.min(get(i - 1, j), get(i, j - 1)), get(i - 1, j - 1)));
        }
    }
    return get(one.length, two.length);
}
function isDateLike(a) {
    return a instanceof Date || a instanceof polyfill_1.Temporal.ZonedDateTime || a instanceof polyfill_1.Temporal.Instant;
}
function toInstant(a) {
    if (typeof a === 'string')
        return polyfill_1.Temporal.Instant.from(a);
    if (a instanceof Date)
        return polyfill_1.toTemporalInstant.call(a);
    else if (a instanceof polyfill_1.Temporal.ZonedDateTime)
        return a.toInstant();
    else
        return a;
}
function equality(a, b) {
    if (a === b)
        return true;
    if (a === null || b === null) // they can't be both null because a !== b
        return false;
    if (a === undefined || b === undefined)
        return false;
    if (Number.isNaN(a) && Number.isNaN(b))
        return true;
    if ((isDateLike(a) && isDateLike(b)) ||
        (isDateLike(a) && typeof b === 'string') ||
        (typeof a === 'string' && isDateLike(b)))
        return toInstant(a).equals(toInstant(b));
    if (hasValueOf(a) && hasValueOf(b))
        return a.valueOf() === b.valueOf();
    if (a instanceof values_1.Currency && b instanceof values_1.Currency)
        return a.value === b.value && a.code.toLowerCase() === b.code.toLowerCase();
    if (a instanceof values_1.Currency && typeof b === 'number')
        return +a === +b;
    if (b instanceof values_1.Currency && typeof a === 'number')
        return +a === +b;
    if (values_1.Location.isLocation(a) && values_1.Location.isLocation(b))
        return locationEquals(a, b);
    if (values_1.Entity.isEntity(a) && values_1.Entity.isEntity(b))
        return String(a) === String(b);
    if (a instanceof Ast.Example && b instanceof Ast.Example)
        return a.id === b.id;
    if (Array.isArray(a) && Array.isArray(b))
        return arrayEquals(a, b);
    if (typeof a === 'object' && typeof b === 'object') {
        (0, assert_1.default)(a !== null);
        (0, assert_1.default)(b !== null);
        return objectEquals(a, b);
    }
    return false;
}
exports.equality = equality;
function defaultLikeTest(a, b) {
    a = a.toLowerCase();
    a = a.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    a = a.replace(/[\p{Mark}\p{Punctuation}\p{Separator}\p{Other}_]/ug, ' ');
    a = a.replace(/\p{White_Space}+/ug, ' ');
    a = a.trim();
    b = b.toLowerCase();
    b = b.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    b = b.replace(/[\p{Mark}\p{Punctuation}\p{Separator}\p{Other}_]/ug, ' ');
    b = b.replace(/\p{White_Space}+/ug, ' ');
    b = b.trim();
    if (a.indexOf(b) >= 0)
        return true;
    for (const token_b of b.split(' ')) {
        let tokenFound = false;
        for (const token_a of a.split(' ')) {
            if (token_a === token_b || (editDistance(token_a, token_b) <= 1 && token_b.length > 1)) {
                tokenFound = true;
                break;
            }
        }
        if (!tokenFound)
            return false;
    }
    return true;
}
function anyToString(a) {
    if (a === undefined)
        return 'undefined';
    if (a === null)
        return 'null';
    return a.toString();
}
function like(a, b) {
    if (a === undefined || a === null ||
        b === undefined || b === null)
        return false;
    if (a instanceof values_1.Entity) {
        if (a.softmatch)
            return a.softmatch(anyToString(b));
        if (a.display)
            return defaultLikeTest(a.display, anyToString(b));
        return false;
    }
    if (a instanceof values_1.StringLike) {
        if (a.softmatch)
            return a.softmatch(anyToString(b));
    }
    return defaultLikeTest(anyToString(a), anyToString(b));
}
exports.like = like;
function startsWith(a, b) {
    return anyToString(a).toLowerCase().startsWith(anyToString(b).toLowerCase());
}
exports.startsWith = startsWith;
function endsWith(a, b) {
    return anyToString(a).toLowerCase().endsWith(anyToString(b).toLowerCase());
}
exports.endsWith = endsWith;
function recurrentTimeSpecContains(env, spec, timeOrDate) {
    (0, assert_1.default)(Array.isArray(spec));
    let contained = false;
    for (const rule of spec) {
        if (rule.contains(timeOrDate, env.timezone)) {
            if (rule.subtract)
                contained = false;
            else
                contained = true;
        }
    }
    return contained;
}
exports.recurrentTimeSpecContains = recurrentTimeSpecContains;
function contains(a, b) {
    if (a === null || a === undefined)
        return false;
    return a.some((x) => equality(x, b));
}
exports.contains = contains;
// b is a substring of any element of a
function containsLike(a, b) {
    if (a === null || a === undefined)
        return false;
    return a.some((x) => like(x, b));
}
exports.containsLike = containsLike;
// any element of b is a substring of a
function inArrayLike(a, b) {
    if (b === null || b === undefined)
        return false;
    return b.some((x) => like(a, x));
}
exports.inArrayLike = inArrayLike;
function getTime(d) {
    return new values_1.Time(d.getHours(), d.getMinutes(), d.getSeconds());
}
exports.getTime = getTime;
function getCurrency(d) {
    return new values_1.Currency(d, 'usd'); //Assumes that default location is USA
}
exports.getCurrency = getCurrency;
// aggregations
function sum(a, b) {
    return a + b;
}
exports.sum = sum;
function max(a, b) {
    return Math.max(a, b);
}
exports.max = max;
function min(a, b) {
    return Math.min(a, b);
}
exports.min = min;
function argmax(value, previous) {
    return value > previous;
}
exports.argmax = argmax;
function argmin(value, previous) {
    return value < previous;
}
exports.argmin = argmin;
// FIXME: replace with a faster implementation based on binary trees
// if we care
class EqualitySet {
    constructor() {
        this.store = [];
    }
    has(value) {
        for (const candidate of this.store) {
            if (equality(candidate, value))
                return true;
        }
        return false;
    }
    add(value) {
        for (const candidate of this.store) {
            if (equality(candidate, value))
                return;
        }
        this.store.push(value);
    }
    get size() {
        return this.store.length;
    }
}
exports.EqualitySet = EqualitySet;
class ArgMinMaxState {
    constructor(op, base, limit) {
        this._op = op;
        this._total = Math.max(base + limit - 1, 1);
        this._filled = 0;
        this._tuples = new Array(this._total);
        this._outputTypes = new Array(this._total);
        this._values = new Array(this._total);
        this._base = Math.max(base - 1, 0);
    }
    *[Symbol.iterator]() {
        for (let i = this._base; i < this._filled; i++)
            yield [this._outputTypes[i], this._tuples[i]];
    }
    update(tuple, outputType, value) {
        for (let i = 0; i < this._filled; i++) {
            const candidate = this._values[i];
            if (this._op(value, candidate)) {
                // shift everything by one
                let last;
                if (this._filled < this._total) {
                    last = this._filled;
                    this._filled++;
                }
                else {
                    last = this._filled - 1;
                }
                for (let j = last; j > i; j--) {
                    this._tuples[j] = this._tuples[j - 1];
                    this._outputTypes[j] = this._outputTypes[j - 1];
                    this._values[j] = this._values[j - 1];
                }
                this._tuples[i] = tuple;
                this._outputTypes[i] = outputType;
                this._values[i] = value;
                return;
            }
        }
        if (this._filled < this._total) {
            this._tuples[this._filled] = tuple;
            this._outputTypes[this._filled] = outputType;
            this._values[this._filled] = value;
            this._filled++;
        }
    }
}
exports.ArgMinMaxState = ArgMinMaxState;
function count(x) {
    return x.length;
}
exports.count = count;
function aggregateMax(array) {
    let value = -Infinity;
    for (const element of array)
        value = Math.max(element, value);
    return value;
}
exports.aggregateMax = aggregateMax;
function aggregateMin(array) {
    let value = Infinity;
    for (const element of array)
        value = Math.min(element, value);
    return value;
}
exports.aggregateMin = aggregateMin;
function aggregateSum(array) {
    let value = 0;
    for (const element of array)
        value += element;
    return value;
}
exports.aggregateSum = aggregateSum;
function aggregateAvg(array) {
    let sum = 0;
    let count = 0;
    for (const element of array) {
        sum += element;
        count += 1;
    }
    return sum / count;
}
exports.aggregateAvg = aggregateAvg;
function setTime(env, d, t) {
    let dtz;
    if (d === null)
        dtz = polyfill_1.Temporal.Now.zonedDateTime('iso8601', env.timezone);
    else if (d instanceof Date)
        dtz = polyfill_1.toTemporalInstant.call(d).toZonedDateTime({ timeZone: env.timezone, calendar: 'iso8601' });
    else if (d instanceof polyfill_1.Temporal.Instant)
        dtz = d.toZonedDateTime({ timeZone: env.timezone, calendar: 'iso8601' });
    else
        dtz = d;
    if (t !== null)
        dtz = dtz.withPlainTime(t);
    // convert back to legacy JS Date for compatibility with existing code
    return new Date(dtz.epochMilliseconds);
}
exports.setTime = setTime;
function dateAdd(date, offset) {
    return new Date(toInstant(date).epochMilliseconds + offset);
}
exports.dateAdd = dateAdd;
function dateSub(date, offset) {
    return new Date(toInstant(date).epochMilliseconds - offset);
}
exports.dateSub = dateSub;
function timeToNumber(time) {
    if (time instanceof polyfill_1.Temporal.PlainTime)
        return values_1.Time.fromTemporal(time).valueOf();
    else
        return time.valueOf();
}
function timeAdd(time, offset) {
    return values_1.Time.fromSeconds(timeToNumber(time) + Math.round(offset / 1000));
}
exports.timeAdd = timeAdd;
function timeSub(time, offset) {
    return values_1.Time.fromSeconds(timeToNumber(time) - Math.round(offset / 1000));
}
exports.timeSub = timeSub;
//# sourceMappingURL=primitive_ops.js.map