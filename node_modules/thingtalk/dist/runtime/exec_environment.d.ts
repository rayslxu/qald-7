import * as Ast from '../ast';
import type * as builtin from './values';
export declare type CompiledFilterHint = [
    string,
    string,
    unknown
] | [string, string, string, unknown] | [string, string, unknown, string, unknown];
export interface CompiledQueryHints {
    filter?: CompiledFilterHint[];
    sort?: [string, 'asc' | 'desc'];
    projection?: string[];
    limit?: number;
}
export interface StreamValue {
    [key: string]: unknown;
    __timestamp: number;
}
export declare type CompiledStatement = (env: ExecEnvironment) => Promise<void>;
export declare class CompiledProgram {
    hasTrigger: boolean;
    states: number;
    command: CompiledStatement | null;
    rules: CompiledStatement[];
    constructor(states: number, command: CompiledStatement | null, rules: CompiledStatement[]);
}
export declare abstract class ExecEnvironment {
    _scope: {
        [key: string]: any;
    };
    private _procedureFrameCounter;
    private _procedureFrame;
    private _procedureStack;
    constructor();
    get program_id(): builtin.Entity;
    get locale(): string;
    get timezone(): string;
    /**
     * Returns a unique id of the current stack frame.
     *
     * The ID is incremented for every procedure call.
     */
    get procedureFrame(): number;
    enterProcedure(procid: number, procname: string): void;
    exitProcedure(procid: number, procname: string): void;
    invokeMonitor(kind: string, attrs: Record<string, string>, fname: string, params: Record<string, unknown>, hints: CompiledQueryHints): AsyncIterator<[string, StreamValue]>;
    invokeTimer(base: Date, interval: number, frequency: number): AsyncIterator<StreamValue>;
    invokeAtTimer(timeArray: builtin.Time[], expiration_date?: Date): AsyncIterator<StreamValue>;
    invokeOnTimer(dateArray: Date[]): void;
    invokeQuery(kind: string, attrs: Record<string, string>, fname: string, params: Record<string, unknown>, hints: CompiledQueryHints): AsyncIterable<[string, Record<string, unknown>]>;
    invokeDBQuery(kind: string, attrs: Record<string, string>, query: Ast.Program): AsyncIterable<[string, Record<string, unknown>]>;
    invokeAction(kind: string, attrs: Record<string, string>, fname: string, params: Record<string, unknown>): AsyncIterable<[string, Record<string, unknown>]>;
    clearGetCache(): void;
    sendEndOfFlow(principal: string, flow: number): Promise<void>;
    output(outputType: string, output: Record<string, unknown>): Promise<void>;
    readState(stateId: number): Promise<unknown>;
    writeState(stateId: number, value: unknown): Promise<void>;
    reportError(message: string, err: Error): Promise<void>;
    formatEvent(outputType: string, output: Record<string, unknown>, hint: string): Promise<string>;
}
