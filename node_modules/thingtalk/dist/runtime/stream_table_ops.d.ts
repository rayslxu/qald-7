import AsyncQueue from 'consumer-queue';
import type { ExecEnvironment } from './exec_environment';
interface MonitorTupleLike {
    __timestamp: number;
}
/**
 * Check if a query returned a new result, compared to the previously returned results.
 *
 * This function checks if the state contains an identical tuple (comparing only `keys`)
 * in the immediately previous round of polling (according to `__timestamp`)
 *
 * This is used to identify the delta between two polling queries in the `monitor`
 * operator.
 *
 * @param state the monitoring state, consisting of the results returned in the prior
 *   two polling rounds
 * @param tuple the result tuple to check
 * @param keys which keys of `tuple` should be compared
 * @returns `true` if this is a new tuple, `false` otherwise
 */
export declare function isNewTuple<T extends MonitorTupleLike, K extends keyof T>(state: T[] | null, tuple: T, keys: K[]): boolean;
/**
 * Update the state used to monitor queries.
 *
 * @param state the monitoring state
 * @param tuple the result tuple to add to the state
 */
export declare function addTuple<T extends MonitorTupleLike>(state: T[] | null, tuple: T): T[];
export declare type ResultT<T> = [string, T];
export declare type EmitFunction<T> = (type: string, value: T) => void;
export declare type Stream<T> = (emit: EmitFunction<T>) => Promise<void>;
export declare function streamUnion<T>(lhs: Stream<T>, rhs: Stream<T>): AsyncIterator<ResultT<T>>;
export declare function tableJoin<T1, T2>(lhs: Stream<T1>, rhs: Stream<T2>): AsyncIterator<ResultT<T1 & T2>, void>;
export declare function tableCrossJoin<T>(lhs: Stream<T>, rhs: Stream<T>): AsyncIterator<ResultT<T>, void>;
export declare type StreamFunction<T> = (env: ExecEnvironment, emit: EmitFunction<T>, ...args: any[]) => Promise<void>;
export declare function invokeStreamVarRef<T>(env: ExecEnvironment, varref: StreamFunction<T>, ...args: any[]): AsyncQueue<IteratorResult<ResultT<T>, void>>;
export interface IterableOrAsyncIterable<T> {
    [Symbol.iterator]?: () => Iterator<T>;
    [Symbol.asyncIterator]?: () => AsyncIterator<T>;
}
export declare function getAsyncIterator<T>(obj: IterableOrAsyncIterable<T>): Iterator<T> | AsyncIterator<T>;
export {};
